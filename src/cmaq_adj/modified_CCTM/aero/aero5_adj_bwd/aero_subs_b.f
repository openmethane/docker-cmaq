!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.4 (r3376) - 10 Feb 2010 17:51
!
!  Differentiation of aeroproc in reverse (adjoint) mode:
!   gradient     of useful results: aeromode_diam moment0_conc
!                moment2_conc moment3_conc aeromode_dens aerospc_conc
!                aeromode_sdev aeromode_mass vapor_conc (global)precursor_conc[1:n_precursor]
!   with respect to varying inputs: aeromode_diam moment0_conc
!                moment2_conc moment3_conc aeromode_dens aerospc_conc
!                aeromode_sdev aeromode_mass vapor_conc orgprod_conc
!                (global)precursor_conc[1:n_precursor] (global)so4rate
!***********************************************************************
!   Portions of Models-3/CMAQ software were developed or based on      *
!   information from various groups: Federal Government employees,     *
!   contractors working on a United States Government contract, and    *
!   non-Federal sources (including research institutions).  These      *
!   research institutions have given the Government permission to      *
!   use, prepare derivative works, and distribute copies of their      *
!   work in Models-3/CMAQ to the public and to permit others to do     *
!   so.  EPA therefore grants similar permissions for use of the       *
!   Models-3/CMAQ software, but users are requested to provide copies  *
!   of derivative works to the Government without restrictions as to   *
!   use by others.  Users are responsible for acquiring their own      *
!   copies of commercial software associated with Models-3/CMAQ and    *
!   for complying with vendor requirements.  Software copyrights by    *
!   the MCNC Environmental Modeling Center are used with their         *
!   permissions subject to the above restrictions.                     *
!***********************************************************************
!
! RCS file, release, date & time of last delta, author, state, [and locker]
! $Header: /Volumes/Data/CVS/CMAQ_CVSrepos/CCTM/src/aero/aero5_adj_bwd/aero_subs_b.f,v 1.5 2011/06/17 17:42:39 shannon Exp $
!
! what(1) key, module and SID; SCCS file; date and time of last delta:
! %W% %P% %G% %U%
!
! routines for aerosol formation and transformation processes
!
      SUBROUTINE AEROPROC_B(dt, col, row, layer, gamma_n2o5)
        USE SOA_DEFN_B
        USE AERO_DATA_B
        USE MET_DATA
        USE precursor_data_b
        IMPLICIT NONE
!
! *** arguments:
!
! synchronization time step, sec
        REAL, INTENT(IN) :: dt
! Column of cell
        INTEGER, INTENT(IN) :: col
! Row of cell
        INTEGER, INTENT(IN) :: row
! Layer of cell
        INTEGER, INTENT(IN) :: layer
! N2O5 heterogeneous reaction probability [ ]
        REAL :: gamma_n2o5
!
! *** Parameters
! molecular diffusiviity for sulfuric acid
        REAL, PARAMETER :: diffsulf=9.36e-06
!  SQRT( 2 )
        REAL, PARAMETER :: sqrt2=1.4142135623731
! [ K ]
        REAL, PARAMETER :: t0=288.15
        REAL, PARAMETER :: twothirds=2.0/3.0
!
! *** local variables
!
! Correction to DIFFSULF & DIFFORG for pressure
        REAL :: diffcorr
! molecular diffusivity of H2SO4 vapor after correction for ambient conditions
        REAL :: dv_so4
! square root of ambient temperature
        REAL :: sqrt_temp
! atmospheric mean free path [m]
        REAL :: xlm
! atmospheric dynamic viscosity [kg/m s]
        REAL :: amu
! second moment concentration excluding H2O
        REAL :: m2_old
        REAL :: m2_oldb
! third moment concentration excluding H2O
        REAL :: m3_old
        REAL :: m3_oldb
!
! Aitken & Accum. modes
        REAL*8 :: cgr(n_mode-1)
!
! mean free path [ m ]
        REAL*8 :: lamda
! KNC = TWO3 * BOLTZ *  AIRTEMP / AMU
        REAL*8 :: knc
!
! *** Free Molecular regime (depends upon modal density)
! KFMAT = SQRT(3.0*BOLTZ*AIRTEMP/PDENSAT)
        REAL*8 :: kfmat
        REAL*8 :: kfmatb
! KFMAC = SQRT(3.0*BOLTZ*AIRTEMP/PDENSAC)
        REAL*8 :: kfmac
        REAL*8 :: kfmacb
! KFMATAC = SQRT( 6.0 * BOLTZ * AIRTEMP /
        REAL*8 :: kfmatac
        REAL*8 :: kfmatacb
!
! *** Intermodal coagulation rates [ m**3/s ] ( 0th & 2nd moments )
! Aitken to accumulation
        REAL*8 :: batac(2)
        REAL*8 :: batacb(2)
! accumulation from Aitken
        REAL*8 :: bacat(2)
        REAL*8 :: bacatb(2)
!
! *** Intramodal coagulation rates [ m**3/s ] ( 0th & 2nd moments )
! Aitken mode
        REAL*8 :: batat(2)
        REAL*8 :: batatb(2)
! accumulation mode
        REAL*8 :: bacac(2)
        REAL*8 :: bacacb(2)
!
! *** Intermodal coagulation rate [ m**3/s ] ( 3rd moment )
! Aitken to accumulation
        REAL*8 :: c3ij
        REAL*8 :: c3ijb
! Aitken to accumulation
        REAL*8 :: c30atac
        REAL*8 :: c30atacb
        REAL*8 :: dg_d(n_mode)
        REAL*8 :: dg_db(n_mode)
        REAL*8 :: sg_d(n_mode)
        REAL*8 :: xxl_d(n_mode)
        REAL*8 :: xxl_db(n_mode)
!
! *** variables for advancing concentrations one time step
        REAL*8 :: a, b
        REAL*8 :: ab, bb
        REAL*8 :: y0, y
        REAL*8 :: y0b, yb
        REAL*8 :: expdt
        REAL*8 :: expdtb
        REAL*8 :: loss, prod, pol, lossinv
        REAL*8 :: lossb, prodb, polb
        REAL :: tmass
        REAL :: tmassb
! special factor to compute mass transfer
        REAL :: factrans
        REAL :: factransb
! for initial condidtions in time stepping
        REAL :: m20
        REAL :: m20b
!
! *** Variables for mode merging
        REAL :: GETAF
        REAL :: aaa, xnum, xm2, xm3, xxm2, xxm3
        REAL :: aaab, xnumb, xm2b, xm3b, xxm2b, xxm3b
        REAL :: fnum, fm2, fm3, phnum, phm2, phm3
        REAL :: fnumb, fm2b, fm3b, phnumb, phm2b, phm3b
! Error and complementary error function
        REAL :: ERF, ERFC
! dummy argument for ERF and ERFC
        REAL :: xx
!
! *** local variables
! loop counter
        INTEGER :: spc
! loop counter
        INTEGER :: n
        LOGICAL :: m3_wet_flag
        LOGICAL :: limit_sg=.false.
        REAL :: result1
        REAL :: result1b
        INTEGER :: branch
        REAL*8 :: temp3
        REAL :: temp2
        REAL :: y1b
        REAL :: temp1
        REAL :: temp0
        REAL*8 :: temp7b
        INTRINSIC EXP
        REAL :: y4b
        REAL :: temp9b0
        INTRINSIC MAX
        REAL :: x2
        REAL :: x1
        REAL*8 :: temp7b0
        REAL*8 :: temp6b
        REAL :: y3b
        REAL*8 :: temp9b
        INTRINSIC REAL
        REAL :: tempb
        REAL :: temp2b
        REAL :: temp5b
        REAL*8 :: temp8b0
        REAL :: y2b
        REAL*8 :: temp8b
        REAL :: y5b
        INTRINSIC SQRT
        REAL :: temp
        REAL*8 :: temp6b0
        REAL :: y5
        REAL*8 :: temp8
        REAL :: y4
        REAL*8 :: temp7
        REAL :: y3
        REAL*8 :: temp6
        REAL :: y2
        REAL :: temp5
        REAL :: y1
        REAL*8 :: temp4

        ERF(XX) = SIGN( 1.0, XX) * SQRT(1.0 - EXP( -4.0 * XX * XX / PI ))
        ERFC( XX ) = 1.0 - ERF( XX )

	  
!	  integer pcontrol
!
!-----------------------------------------------------------------------
!
! *** square root of the ambient temperature for later use
        sqrt_temp = SQRT(airtemp)
! *** Calculate mean free path [ m ]:
!     6.6328E-8 is the sea level value given in Table I.2.8
!     on page 10 of U.S. Standard Atmosphere 1962
!
        xlm = 6.6328e-8*stdatmpa*airtemp/(t0*airprs)
!
! *** Calculate dynamic viscosity [ kg m**-1 s**-1 ]:
!     U.S. Standard Atmosphere 1962 page 14 expression
!     for dynamic viscosity is:
!     dynamic viscosity =  beta * T * sqrt(T) / ( T + S)
!     where beta = 1.458e-6 [ kg sec^-1 K**-0.5 ], s = 110.4 [ K ].
        amu = 1.458e-6*airtemp*sqrt_temp/(airtemp+110.4)
        IF (aeromode(n_mode)%min_num .LT. moment0_conc(n_mode)) THEN
          CALL PUSHINTEGER4(0)
          moment0_conc(n_mode) = moment0_conc(n_mode)
        ELSE
          moment0_conc(n_mode) = aeromode(n_mode)%min_num
          CALL PUSHINTEGER4(1)
        END IF
!
! *** Outside AEROPROC, the surface area concentration [ m**2 / m**3 ]
!     of the Aitken and accumulation modes is tracked.  Internally,
!     the 2nd moment concentration is the variable of interest.
!     Surface area = pi * 2nd moment.
        DO n=1,n_mode
          moment2_conc(n) = moment2_conc(n)/pi
        END DO
!
! *** Update the third moments, geometric mean diameters, geometric
!     standard deviations, modal mass totals, and modal particle
!     densities, based on the concentrations of M2, M0, and speciated
!     masses resulting from transport, cloud processing, and gas-phase
!     chemistry.  Ignore H2O and semi-volatile SOA (i.e., M3_WET_FLAG
!     = .FALSE.) because those species are not transported with the
!     2nd moment and their concentrations will be updated subsequently
!     to establish gas/particle equilibrium.
        m3_wet_flag = .false.
        limit_sg = .false.
        CALL PUSHREAL4ARRAY(aeromode_mass, n_mode)
        CALL PUSHREAL4ARRAY(aeromode_sdev, n_mode)
        CALL PUSHREAL4ARRAY(moment3_conc, n_mode)
        CALL PUSHREAL4ARRAY(moment2_conc, n_mode)
        CALL GETPAR(m3_wet_flag, limit_sg)
	  
C processControl
!	 call get_pcontrol(pcontrol)
C      pcontrol = 0     ! all or all but mode merging
C      pcontrol = 1     ! SOA
C      pcontrol = 2     ! hetCHEM
C      pcontrol = 3     ! secondary inorganic & mode merging
C      pcontrol = 4     ! coagulation
C      pcontrol = 5     !secondary inorganic
	
!	 if(pcontrol.eq.1.or.pcontrol.eq.0.or.pcontrol.eq.6) then
        CALL PUSHREAL4ARRAY(vapor_conc, n_vapor)
        CALL PUSHREAL4ARRAY(aerospc_conc, n_aerospc*n_mode)
        CALL PUSHREAL4ARRAY(moment3_conc, n_mode)
        CALL PUSHREAL4ARRAY(moment2_conc, n_mode)
        CALL PUSHREAL4ARRAY(aeromode_diam, n_mode)
        CALL ORGAER(dt, layer)
!	 end if
!
! *** Secondary Organics
!     Update the secondary organic aerosol (SOA) mass concentrations
!     and the SVOC mass concentrations by equilibrium absorptive
!     partitioning between the particle and vapor phases.  Assume all
!     SOA resides in the accumulation mode.
!	if(pcontrol.eq.2.or.pcontrol.eq.0.or.pcontrol.eq.6)
        call pushreal4array(precursor_conc, n_precursor)
         CALL HETCHEM(gamma_n2o5, dt)
!
! *** Heterogeneous Chemistry
!     Update the N2O5 and HNO3 concentrations to account for
!     heterogenous nitrate formation.
!
! *** Secondary Inorganics
!     The VOLINORG subroutine includes the treatment of new particle
!     production and a fully dynamic treatment of inorganic gas-to-
!     particle mass transfer.
!
C! *** Compute H2SO4 diffusivity, correct for temperature and pressure
C        diffcorr = stdatmpa/airprs*(airtemp/273.16)**1.75
C        dv_so4 = diffsulf*diffcorr
!
! *** Augment 2nd and 3rd moment concentrations with H2O and recompute
!     size distribution parameters because wetted distribution is
!     needed in subroutine VOLINORG
!
        DO n=1,n_mode
          CALL PUSHREAL4(m3_old)
          m3_old = moment3_conc(n)
          CALL PUSHREAL4(m2_old)
          m2_old = moment2_conc(n)
          CALL PUSHREAL4(moment3_conc(n))
!
          moment3_conc(n) = m3_old + h2ofac*aerospc_conc(ah2o_idx, n)
          CALL PUSHREAL4(moment2_conc(n))
          moment2_conc(n) = m2_old*(moment3_conc(n)/m3_old)**twothirds
        END DO
!
        m3_wet_flag = .true.
        CALL PUSHREAL4ARRAY(aeromode_mass, n_mode)
        CALL PUSHREAL4ARRAY(aeromode_sdev, n_mode)
        CALL PUSHREAL4ARRAY(moment3_conc, n_mode)
        CALL PUSHREAL4ARRAY(moment2_conc, n_mode)
        CALL PUSHREAL4ARRAY(aeromode_diam, n_mode)
        CALL GETPAR(m3_wet_flag, limit_sg)
	  
	  
!	  if(pcontrol.eq.3.or.pcontrol.eq.5.or.pcontrol.eq.0) then 
! *** Compute H2SO4 diffusivity, correct for temperature and pressure
        diffcorr = stdatmpa/airprs*(airtemp/273.16)**1.75
        dv_so4 = diffsulf*diffcorr	  
	  
C	  if(pcontrol.eq.3.or.pcontrol.eq.5.or.pcontrol.eq.0) then 
        CALL PUSHREAL4ARRAY(aeromode_mass, n_mode)
        CALL PUSHREAL4ARRAY(aeromode_sdev, n_mode)
        CALL PUSHREAL4ARRAY(aerospc_conc, n_aerospc*n_mode)
        CALL PUSHREAL4ARRAY(moment3_conc, n_mode)
        CALL PUSHREAL4ARRAY(moment2_conc, n_mode)
        CALL PUSHREAL4ARRAY(moment0_conc, n_mode)
        CALL PUSHREAL4ARRAY(aeromode_diam, n_mode)
        call pushreal4array(precursor_conc, n_precursor)
        CALL VOLINORG(dt, col, row, layer, dv_so4, cgr, m3_wet_flag)
!	  end if
!
!
!        if(pcontrol.eq.4.or.pcontrol.eq.0.or.pcontrol.eq.6) then
! *** Coagulation
!     Calculate coagulation coefficients using a method dictated by
!     the value of FASTCOAG_FLAG.  If TRUE, the computationally-
!     efficient GETCOAGS routine is used.  If FALSE, the more intensive
!     Gauss-Hermite numerical quadrature method is used.  See Section
!     2.1 of Bhave et al. (2004) for further discussion.
!
! *** set atmospheric mean free path in double precision
        lamda = xlm
!
! *** calculate term used in Equation A6 of Binkowski & Shankar (1995)
        knc = twothirds*boltzmann*airtemp/amu
!
! *** calculate terms used in Equation A5 of Binkowski & Shankar (1995)
        kfmat = SQRT(3.0*boltzmann*airtemp/aeromode_dens(1))
        kfmac = SQRT(3.0*boltzmann*airtemp/aeromode_dens(2))
        kfmatac = SQRT(6.0*boltzmann*airtemp/(aeromode_dens(1)+aeromode_dens(2
     +    )))
!
! *** transfer of number to accumulation mode from Aitken mode is zero
        bacat(1) = 0.0
	  
C	  if(pcontrol.eq.4.or.pcontrol.eq.0) then
! FASTCOAG_FLAG
!
        IF (fastcoag_flag) THEN
! Solve coagulation analytically
!
! *** set geometric mean diameters, geometric standard deviations, and
!     ln(GSD) in double precision
          DO n=1,n_mode
            dg_d(n) = aeromode_diam(n)
            sg_d(n) = EXP(aeromode_sdev(n))
            xxl_d(n) = aeromode_sdev(n)
          END DO
!
! *** calculate intermodal and intramodal coagulation coefficients
!     for zeroth and second moments, and intermodal coagulation
!     coefficient for third moment
          CALL GETCOAGS(lamda, kfmatac, kfmat, kfmac, knc, dg_d(1), dg_d(2),
     +            sg_d(1), sg_d(2), xxl_d(1), xxl_d(2), batat(2), batat(1),
     +            bacac(2), bacac(1), batac(2), bacat(2), batac(1), c3ij)
!
          CALL PUSHINTEGER4(0)
        ELSE
! Use Gauss-Hermite numerical quadrature
!
! *** calculate Aitken-mode intramodal coagulation coefficients
!     for zeroth and second moments
          CALL INTRACOAG_GH(lamda, kfmat, knc, aeromode_diam(1), aeromode_sdev
     +                (1), batat(2), batat(1))
!
! *** calculate accumulation-mode intramodal coagulation coefficients
!     for zeroth and second moments
          CALL INTRACOAG_GH(lamda, kfmac, knc, aeromode_diam(2), aeromode_sdev
     +                (2), bacac(2), bacac(1))
!
! *** calculate intermodal coagulation coefficients for zeroth, second,
!     and third moments
          CALL INTERCOAG_GH(lamda, kfmatac, knc, aeromode_diam(1),
     +                aeromode_diam(2), aeromode_sdev(1), aeromode_sdev(2),
     +                batac(2), bacat(2), batac(1), c3ij)
!
          CALL PUSHINTEGER4(1)
        END IF
!
! *** calculate 3rd moment intermodal transfer rate by coagulation
        c30atac = c3ij*moment0_conc(1)*moment0_conc(2)
!
! *** TAKE ONE FORWARD TIME STEP - Solve Modal Dynamics Equations
!     This code implements Section 1.4 of Binkowski and Roselle (2003)
!     with two notable exceptions.  1) emissions are treated in
!     CMAQ's vertical diffusion routine, so they do not appear in the
!     following equations. 2) new particle formation and condensational
!     growth are now treated in the VOLINORG subroutine, so they do not
!     appear in the following equations.
!     M2 is updated before M0 because the intermodal transfer rate of
!     M2 is a function of the number concentrations.  In contrast,
!     production and loss rates of M0 are independent of M2.  Advancing
!     M2 before M0 avoids operator splitting within the modal-dynamic-
!     equation solution.  A similar rearrangement would be necessary
!     for the M3 update, but the dependence of M3 on number
!     concentrations already is accounted for in the C30ATAC term.
!
! *** UPDATE SECOND MOMENT
!     For each lognormal mode, solve equations of form:
!       dM2/dt = P2 - L2*M2   ! if L2 > 0
!     with solution
!       M2(t) = P2/L2 + ( M2(t0) - P2/L2 ) * exp( -L2*dt )
!     OR
!       dM2/dt = P2           ! if L2 = 0
!     with solution
!       M2(t) = M2(t0) + P2*dt
!
! *** Aitken mode: initial value of M2
        m20 = moment2_conc(1)
!
! *** Loss of 2nd moment from Aitken mode is due to intermodal
!     coagulation with accumulation mode and intramodal coagulation.
!     Production term is removed, because new particle formation
!     and condensational growth are accounted for in VOLINORG.
        loss = (batat(2)*moment0_conc(1)+batac(2)*moment0_conc(2))*
     +    moment0_conc(1)/m20
! test on loss
!
! *** Solve for M2_Aitken based on LOSS during this time step
!     Note: LOSS is assumed to be non-negative.
        IF (loss .GT. 0.0) THEN
          y = m20*EXP(-(loss*dt))
          CALL PUSHINTEGER4(0)
        ELSE
          y = m20
          CALL PUSHINTEGER4(1)
        END IF
        x1 = REAL(aeromode(1)%min_m2)
        y1 = REAL(y)
        IF (x1 .LT. y1) THEN
          moment2_conc(1) = y1
          CALL PUSHINTEGER4(1)
        ELSE
          moment2_conc(1) = x1
          CALL PUSHINTEGER4(0)
        END IF
        CALL PUSHREAL4(m20)
!
! *** Accumulation mode: initial value of M2
        m20 = moment2_conc(2)
!
! *** Production of 2nd moment in accumulation mode is due to
!     intermodal coagulation Aitken mode
        prod = bacat(2)*moment0_conc(1)*moment0_conc(2)
!
! *** Loss of 2nd moment from accumulation mode is due only to
!     intramodal coagulation
        loss = bacac(2)*moment0_conc(2)*moment0_conc(2)/m20
! test on loss
!
! *** Solve for M2_accum based on PROD and LOSS during this time step
!     Note: LOSS is assumed to be non-negative.
        IF (loss .GT. 0.0) THEN
          pol = prod/loss
          y = pol + (m20-pol)*EXP(-(loss*dt))
          CALL PUSHINTEGER4(1)
        ELSE
          y = m20 + prod*dt
          CALL PUSHINTEGER4(0)
        END IF
        x2 = REAL(aeromode(2)%min_m2)
        y2 = REAL(y)
        IF (x2 .LT. y2) THEN
          moment2_conc(2) = y2
          CALL PUSHINTEGER4(1)
        ELSE
          moment2_conc(2) = x2
          CALL PUSHINTEGER4(0)
        END IF
!
! *** Coarse mode: no change because coagulation of coarse particles
!     is neglected in current model version.
!
! *** end of update for second moment
!
! *** Update Zeroth Moment (i.e. number concentration)
!
! *** Aitken mode: initial value of M0
!
        y0 = moment0_conc(1)
!
! *** The rate of change for M0_Aitken is described in Equation 8a of
!     Binkowski & Roselle (2003), with the c_i term equal to 0.
!
! intramodal coagulation
        a = batat(1)
! intermodal coagulation
        b = batac(1)*moment0_conc(2)
!
        expdt = EXP(-(b*dt))
        IF (expdt .LT. 1.0d0) THEN
          y = b*y0*expdt/(b+a*y0*(1.0d0-expdt))
          CALL PUSHINTEGER4(1)
        ELSE
! solution in the limit that B approaches zero
          y = y0
          CALL PUSHINTEGER4(0)
        END IF
        y3 = REAL(y)
        IF (aeromode(1)%min_num .LT. y3) THEN
          CALL PUSHREAL4(moment0_conc(1))
          moment0_conc(1) = y3
          CALL PUSHINTEGER4(1)
        ELSE
          CALL PUSHREAL4(moment0_conc(1))
          moment0_conc(1) = aeromode(1)%min_num
          CALL PUSHINTEGER4(0)
        END IF
!
! *** Accumulation mode: initial value of M0
        y0 = moment0_conc(2)
!
! *** The rate of change for M0_accum is described in Equation 8b of
!     Binkowski & Roselle (2003), except the coefficient C is zero
!     because emissions are treated outside the CMAQ aerosol module.
!     The equation reduces to the form: dY/dt = -A * Y**2 , where
! intramodal coagulation
        a = bacac(1)
!
! *** Solve for M0_accum using Smoluchowski's solution
        y = y0/(1.0d0+a*y0*dt)
        y4 = REAL(y)
        IF (aeromode(2)%min_num .LT. y4) THEN
          CALL PUSHREAL4(moment0_conc(2))
          moment0_conc(2) = y4
          CALL PUSHINTEGER4(1)
        ELSE
          CALL PUSHREAL4(moment0_conc(2))
          moment0_conc(2) = aeromode(2)%min_num
          CALL PUSHINTEGER4(0)
        END IF
!
! *** end of update for zeroth moment - note that the coarse mode number does
!     not change because coarse-mode coagulation is neglected in the model
!
! *** UPDATE MASS CONCENTRATIONS (for each species)
!     The following procedure is described in Paragraphs 21-23
!     of Binkowski & Roselle (2003), except the Ei,n and Ej,n terms
!     are excluded here because emissions are treated outside the
!     CMAQ aerosol module.
!
!     Aitken mode mass concentration rates of change are of the form:
!       dc/dt = P - L*c    ! Equation 9a of Binkowski & Roselle (2003)
!     with solution
!       c(t0 + dt) = P/L + ( c(t0) - P/L ) * exp(-L*dt)
!
!     For all species, loss of Aitken mode mass is due to intermodal
!     coagulation.
!       LOSSn = PI/6 * RHOn * C30ATAC / MASSn
!       RHOn  = MASSn / (M3 * PI/6)
!     When above equations are combined, the PI/6 terms cancel yielding
!       LOSSn = C30ATAC / M3
!     where LOSSn is the loss rate of species n, RHOn is the mass of
!     species n per unit of particle volume, C30ATAC is the 3rd moment
!     loss rate due to intermodal coagulation, MASSn is the mass
!     concentration of species n, and M3 is the 3rd moment
!     concentration.
!
        loss = c30atac/moment3_conc(1)
!
! *** Set up extra variables to solve for Aitken mode mass concentrations
        factrans = loss*dt
        CALL PUSHREAL8(expdt)
        expdt = EXP(-factrans)
!
! *** Secondary Organics and Inorganics
!     These species are produced by condensation, but their mass
!     concentrations have been updated in subroutine VOLINORG.  Therefore,
!     only the mass transfer due to intermodal coagulation is
!     treated here.
!
        DO spc=1,n_aerospc
          IF (spc .EQ. ana_idx) THEN
            CALL PUSHINTEGER4(1)
          ELSE IF (aerospc(spc)%name(1) .EQ. ' ') THEN
            CALL PUSHINTEGER4(2)
          ELSE
            tmass = aerospc_conc(spc, 1) + aerospc_conc(spc, 2)
            y5 = REAL(aerospc_conc(spc, 1)*expdt)
            IF (aerospc(spc)%min_conc(1) .LT. y5) THEN
              CALL PUSHREAL4(aerospc_conc(spc, 1))
              aerospc_conc(spc, 1) = y5
              CALL PUSHINTEGER4(1)
            ELSE
              CALL PUSHREAL4(aerospc_conc(spc, 1))
              aerospc_conc(spc, 1) = aerospc(spc)%min_conc(1)
              CALL PUSHINTEGER4(0)
            END IF
            IF (aerospc(spc)%min_conc(2) .LT. tmass - aerospc_conc(spc, 1))
     +      THEN
              CALL PUSHREAL4(aerospc_conc(spc, 2))
              aerospc_conc(spc, 2) = tmass - aerospc_conc(spc, 1)
              CALL PUSHINTEGER4(4)
            ELSE
              CALL PUSHREAL4(aerospc_conc(spc, 2))
              aerospc_conc(spc, 2) = aerospc(spc)%min_conc(2)
              CALL PUSHINTEGER4(3)
            END IF
          END IF
        END DO
! end check on necessity for merging
!
! *** end of update for species mass concentrations
!
!       end if ! pcontrol for coagulation

! *** Mode Merging
!     This code implements Section 1.5 of Binkowski and Roselle (2003).
!     If the Aitken mode mass is growing faster than accumulation mode
!     mass and the Aitken mode number concentration exceeds the
!     accumulation mode number concentration, then modes are merged by
!     renaming.
!

!	if(pcontrol.eq.3.or.pcontrol.eq.0) then
C      if(pcontrol.eq.3) then
        IF (cgr(1) .GT. cgr(2) .AND. moment0_conc(1) .GT. moment0_conc(2))
     +  THEN
          CALL PUSHREAL4ARRAY(aeromode_mass, n_mode)
          CALL PUSHREAL4ARRAY(aeromode_sdev, n_mode)
          CALL PUSHREAL4ARRAY(aeromode_dens, n_mode)
          CALL PUSHREAL4ARRAY(moment3_conc, n_mode)
          CALL PUSHREAL4ARRAY(moment2_conc, n_mode)
          CALL PUSHREAL4ARRAY(aeromode_diam, n_mode)
!
! *** Before mode merging, update the third moments, geometric mean
!     diameters, geometric standard deviations, modal mass totals, and
!     particle densities, based on the new concentrations of M2, M0, and
!     speciated masses calculated above.
          CALL GETPAR(m3_wet_flag, limit_sg)
!
! *** Calculate AAA = ln( Dij / DGATK ) / ( SQRT2 * XXLSGAT ), where Dij
!     is the diameter at which the Aitken-mode and accumulation-mode
!     number distributions intersect (i.e., overlap).  AAA is equivalent
!     to the "Xnum" term described below Equation 10a by Binkowski and
!     Roselle (2003).
          aaa = GETAF(moment0_conc(1), moment0_conc(2), aeromode_diam(1),
     +      aeromode_diam(2), aeromode_sdev(1), aeromode_sdev(2), sqrt2)
!
! *** Ensure that Xnum is large enough so that no more than half of
!     the Aitken mode mass is merged into the accumulation mode during
!     any given time step.  This criterion is described in Paragraph 26
!     of Binkowski and Roselle (2003).
          xxm3 = 3.0*aeromode_sdev(1)/sqrt2
          IF (aaa .LT. xxm3) THEN
            xnum = xxm3
            CALL PUSHINTEGER4(1)
          ELSE
            xnum = aaa
            CALL PUSHINTEGER4(0)
          END IF
!
! *** Factors used in error function calls for M2 and M3 mode merging
          xxm2 = twothirds*xxm3
! set up for 2nd moment transfer
          xm2 = xnum - xxm2
! set up for 3rd moment and mass transfers
          xm3 = xnum - xxm3
!
! *** Calculate the fractions of the number, 2nd, and 3rd moment
!     distributions with diameter greater than the intersection diameter
! Eq 10a of B&R 2003
          result1 = ERFC(xnum)
          fnum = 0.5*result1
! Eq 10b of B&R 2003
          result1 = ERFC(xm2)
          fm2 = 0.5*result1
! Eq 10b of B&R 2003
          result1 = ERFC(xm3)
          fm3 = 0.5*result1
!
! *** Calculate the fractions of the number, 2nd, and 3rd moment
!     distributions with diameters less than the intersection diameter.
! Eq 10c of B&R 2003
          result1 = ERF(xnum)
          phnum = 0.5*(1.0+result1)
! Eq 10d of B&R 2003
          result1 = ERF(xm2)
          phm2 = 0.5*(1.0+result1)
! Eq 10d of B&R 2003
          result1 = ERF(xm3)
          phm3 = 0.5*(1.0+result1)
          CALL PUSHREAL4(moment0_conc(2))
!
! *** Update accumulation-mode moment concentrations using
!     Equations 11a - 11c of Binkowski and Roselle (2003).
          moment0_conc(2) = moment0_conc(2) + moment0_conc(1)*fnum
          CALL PUSHREAL4(moment2_conc(2))
          moment2_conc(2) = moment2_conc(2) + moment2_conc(1)*fm2
          CALL PUSHREAL4(moment3_conc(2))
          moment3_conc(2) = moment3_conc(2) + moment3_conc(1)*fm3
          CALL PUSHREAL4(moment0_conc(1))
!
! *** Update Aitken-mode moment concentrations using
!     Equations 11d - 11f of Binkowski and Roselle (2003).
          moment0_conc(1) = moment0_conc(1)*phnum
          CALL PUSHREAL4(moment2_conc(1))
          moment2_conc(1) = moment2_conc(1)*phm2
          CALL PUSHREAL4(moment3_conc(1))
          moment3_conc(1) = moment3_conc(1)*phm3
! *** Rename masses of each species from Aitken mode to acumulation mode
!     using Equation 11b of Binkowski and Roselle (2003).
          DO spc=1,n_aerospc
            IF (spc .EQ. ana_idx) THEN
              CALL PUSHINTEGER4(1)
            ELSE IF (spc .EQ. acl_idx) THEN
              CALL PUSHINTEGER4(2)
            ELSE IF (aerospc(spc)%name(1) .EQ. ' ') THEN
              CALL PUSHINTEGER4(3)
            ELSE
              CALL PUSHREAL4(aerospc_conc(spc, 2))
!
              aerospc_conc(spc, 2) = aerospc_conc(spc, 2) + aerospc_conc(spc,
     +          1)*fm3
              CALL PUSHREAL4(aerospc_conc(spc, 1))
              aerospc_conc(spc, 1) = aerospc_conc(spc, 1)*phm3
              CALL PUSHINTEGER4(4)
            END IF
          END DO
          CALL PUSHINTEGER4(1)
        ELSE
          CALL PUSHINTEGER4(0)
        END IF
	  
	  
!	  end if ! pcontrol for mode merging
!
! *** Set minimum value for all concentrations in the CBLK array
!
        DO n=1,n_mode
          DO spc=1,n_aerospc
            IF (aerospc_conc(spc, n) .LT. aerospc(spc)%min_conc(n)) THEN
              CALL PUSHINTEGER4(2)
            ELSE
              CALL PUSHINTEGER4(1)
            END IF
          END DO
        END DO
	  
	  
! reverse	  
	  
        DO n=n_mode,1,-1
          DO spc=n_aerospc,1,-1
            CALL POPINTEGER4(branch)
            IF (.NOT.branch .LT. 2) aerospc_concb(spc, n) = 0.0
          END DO
        END DO
        CALL GETPAR_B(m3_wet_flag, limit_sg)
	  
!	  if(pcontrol.eq.3.or.pcontrol.eq.0) then
C	  if(pcontrol.eq.3) then   ! mode merging
	  
        CALL POPINTEGER4(branch)
        IF (.NOT.branch .LT. 1) THEN
          fm3b = 0.0
          phm3b = 0.0
          DO spc=n_aerospc,1,-1
            CALL POPINTEGER4(branch)
            IF (.NOT.branch .LT. 3) THEN
              IF (.NOT.branch .LT. 4) THEN
                CALL POPREAL4(aerospc_conc(spc, 1))
                phm3b = phm3b + aerospc_conc(spc, 1)*aerospc_concb(spc, 1)
                aerospc_concb(spc, 1) = fm3*aerospc_concb(spc, 2) + phm3*
     +            aerospc_concb(spc, 1)
                CALL POPREAL4(aerospc_conc(spc, 2))
                fm3b = fm3b + aerospc_conc(spc, 1)*aerospc_concb(spc, 2)
              END IF
            END IF
          END DO
          CALL POPREAL4(moment3_conc(1))
          phm3b = phm3b + moment3_conc(1)*moment3_concb(1)
          moment3_concb(1) = fm3*moment3_concb(2) + phm3*moment3_concb(1)
          CALL POPREAL4(moment2_conc(1))
          phm2b = moment2_conc(1)*moment2_concb(1)
          moment2_concb(1) = fm2*moment2_concb(2) + phm2*moment2_concb(1)
          CALL POPREAL4(moment0_conc(1))
          phnumb = moment0_conc(1)*moment0_concb(1)
          moment0_concb(1) = fnum*moment0_concb(2) + phnum*moment0_concb(1)
          CALL POPREAL4(moment3_conc(2))
          fm3b = fm3b + moment3_conc(1)*moment3_concb(2)
          CALL POPREAL4(moment2_conc(2))
          fm2b = moment2_conc(1)*moment2_concb(2)
          CALL POPREAL4(moment0_conc(2))
          fnumb = moment0_conc(1)*moment0_concb(2)
          result1b = 0.5*phm3b
          xm3b = 0.0
          CALL ERF_B(xm3, xm3b, result1b)
          result1b = 0.5*phm2b
          xm2b = 0.0
          CALL ERF_B(xm2, xm2b, result1b)
          result1b = 0.5*phnumb
          xnumb = 0.0
          CALL ERF_B(xnum, xnumb, result1b)
          result1b = 0.5*fm3b
          CALL ERFC_B(xm3, xm3b, result1b)
          result1b = 0.5*fm2b
          CALL ERFC_B(xm2, xm2b, result1b)
          result1b = 0.5*fnumb
          CALL ERFC_B(xnum, xnumb, result1b)
          xnumb = xnumb + xm2b + xm3b
          xxm2b = -xm2b
          xxm3b = twothirds*xxm2b - xm3b
          CALL POPINTEGER4(branch)
          IF (branch .LT. 1) THEN
            aaab = xnumb
          ELSE
            xxm3b = xxm3b + xnumb
            aaab = 0.0
          END IF
          aeromode_sdevb(1) = aeromode_sdevb(1) + 3.0*xxm3b/sqrt2
          CALL GETAF_B(moment0_conc(1), moment0_concb(1), moment0_conc(2),
     +           moment0_concb(2), aeromode_diam(1), aeromode_diamb(1),
     +           aeromode_diam(2), aeromode_diamb(2), aeromode_sdev(1),
     +           aeromode_sdevb(1), aeromode_sdev(2), aeromode_sdevb(2), sqrt2
     +           , aaab)
          CALL POPREAL4ARRAY(aeromode_diam, n_mode)
          CALL POPREAL4ARRAY(moment2_conc, n_mode)
          CALL POPREAL4ARRAY(moment3_conc, n_mode)
          CALL POPREAL4ARRAY(aeromode_dens, n_mode)
          CALL POPREAL4ARRAY(aeromode_sdev, n_mode)
          CALL POPREAL4ARRAY(aeromode_mass, n_mode)
          CALL GETPAR_B(m3_wet_flag, limit_sg)
        END IF
	  
!	  end if ! pcontrol for mode merging
	  
!	  if(pcontrol.eq.4.or.pcontrol.eq.0.or.pcontrol.eq.6) then
        expdtb = 0.0_8
        DO spc=n_aerospc,1,-1
          CALL POPINTEGER4(branch)
          IF (.NOT.branch .LT. 3) THEN
            IF (branch .LT. 4) THEN
              CALL POPREAL4(aerospc_conc(spc, 2))
              aerospc_concb(spc, 2) = 0.0
              tmassb = 0.0
            ELSE
              CALL POPREAL4(aerospc_conc(spc, 2))
              tmassb = aerospc_concb(spc, 2)
              aerospc_concb(spc, 1) = aerospc_concb(spc, 1) - aerospc_concb(
     +          spc, 2)
              aerospc_concb(spc, 2) = 0.0
            END IF
            CALL POPINTEGER4(branch)
            IF (branch .LT. 1) THEN
              CALL POPREAL4(aerospc_conc(spc, 1))
              aerospc_concb(spc, 1) = 0.0
              y5b = 0.0
            ELSE
              CALL POPREAL4(aerospc_conc(spc, 1))
              y5b = aerospc_concb(spc, 1)
              aerospc_concb(spc, 1) = 0.0
            END IF
            temp9b0 = y5b
            aerospc_concb(spc, 1) = aerospc_concb(spc, 1) + tmassb + expdt*
     +        temp9b0
            expdtb = expdtb + aerospc_conc(spc, 1)*temp9b0
            aerospc_concb(spc, 2) = aerospc_concb(spc, 2) + tmassb
          END IF
        END DO
        CALL POPREAL8(expdt)
        factransb = -(EXP(-factrans)*expdtb)
        lossb = dt*factransb
        temp9b = lossb/moment3_conc(1)
        c30atacb = temp9b
        moment3_concb(1) = moment3_concb(1) - c30atac*temp9b/moment3_conc(1)
        CALL POPINTEGER4(branch)
        IF (branch .LT. 1) THEN
          CALL POPREAL4(moment0_conc(2))
          moment0_concb(2) = 0.0
          y4b = 0.0
        ELSE
          CALL POPREAL4(moment0_conc(2))
          y4b = moment0_concb(2)
          moment0_concb(2) = 0.0
        END IF
        yb = y4b
        temp8 = dt*a*y0 + 1.0d0
        temp8b0 = -(y0*dt*yb/temp8**2)
        y0b = a*temp8b0 + yb/temp8
        ab = y0*temp8b0
        bacacb = 0.0_8
        bacacb(1) = ab
        moment0_concb(2) = moment0_concb(2) + y0b
        CALL POPINTEGER4(branch)
        IF (branch .LT. 1) THEN
          CALL POPREAL4(moment0_conc(1))
          moment0_concb(1) = 0.0
          y3b = 0.0
        ELSE
          CALL POPREAL4(moment0_conc(1))
          y3b = moment0_concb(1)
          moment0_concb(1) = 0.0
        END IF
        yb = y3b
        a = batat(1)
        y0 = moment0_conc(1)
        CALL POPINTEGER4(branch)
        IF (branch .LT. 1) THEN
          y0b = yb
          expdtb = 0.0_8
          ab = 0.0_8
          bb = 0.0_8
        ELSE
          temp7 = b + a*y0*(-expdt+1.0d0)
          temp8b = yb/temp7
          temp7b0 = -(b*y0*expdt*temp8b/temp7)
          bb = temp7b0 + expdt*y0*temp8b
          y0b = (1.0d0-expdt)*a*temp7b0 + expdt*b*temp8b
          expdtb = b*y0*temp8b - a*y0*temp7b0
          ab = (1.0d0-expdt)*y0*temp7b0
        END IF
        bb = bb - EXP(-(dt*b))*dt*expdtb
        batacb = 0.0_8
        batacb(1) = moment0_conc(2)*bb
        moment0_concb(2) = moment0_concb(2) + batac(1)*bb
        batatb = 0.0_8
        batatb(1) = ab
        moment0_concb(1) = moment0_concb(1) + y0b
        CALL POPINTEGER4(branch)
        IF (branch .LT. 1) THEN
          moment2_concb(2) = 0.0
          y2b = 0.0
        ELSE
          y2b = moment2_concb(2)
          moment2_concb(2) = 0.0
        END IF
        yb = y2b
        loss = bacac(2)*moment0_conc(2)*moment0_conc(2)/m20
        CALL POPINTEGER4(branch)
        IF (branch .LT. 1) THEN
          m20b = yb
          prodb = dt*yb
          lossb = 0.0_8
        ELSE
          temp7b = EXP(-(dt*loss))*yb
          polb = yb - temp7b
          m20b = temp7b
          lossb = -(prod*polb/loss**2) - (m20-pol)*EXP(-(dt*loss))*dt*yb
          prodb = polb/loss
        END IF
        temp6b0 = moment0_conc(2)**2*lossb/m20
        temp6 = bacac(2)/m20
        bacacb(2) = bacacb(2) + temp6b0
        m20b = m20b - temp6*temp6b0
        moment0_concb(2) = moment0_concb(2) + temp6*2*moment0_conc(2)*lossb
        bacatb = 0.0_8
        bacatb(2) = moment0_conc(2)*moment0_conc(1)*prodb
        moment0_concb(1) = moment0_concb(1) + moment0_conc(2)*bacat(2)*prodb
        moment0_concb(2) = moment0_concb(2) + bacat(2)*moment0_conc(1)*prodb
        CALL POPREAL4(m20)
        moment2_concb(2) = moment2_concb(2) + m20b
        CALL POPINTEGER4(branch)
        IF (branch .LT. 1) THEN
          moment2_concb(1) = 0.0
          y1b = 0.0
        ELSE
          y1b = moment2_concb(1)
          moment2_concb(1) = 0.0
        END IF
        yb = y1b
        CALL POPINTEGER4(branch)
        IF (branch .LT. 1) THEN
          loss = (batat(2)*moment0_conc(1)+batac(2)*moment0_conc(2))*
     +      moment0_conc(1)/m20
          m20b = EXP(-(dt*loss))*yb
          lossb = -(m20*EXP(-(dt*loss))*dt*yb)
        ELSE
          m20b = yb
          lossb = 0.0_8
        END IF
        temp5 = moment0_conc(1)/m20
        temp6b = temp5*lossb
        temp5b = (batat(2)*moment0_conc(1)+batac(2)*moment0_conc(2))*lossb/m20
        batatb(2) = batatb(2) + moment0_conc(1)*temp6b
        moment0_concb(1) = moment0_concb(1) + temp5b + batat(2)*temp6b
        batacb(2) = batacb(2) + moment0_conc(2)*temp6b
        moment0_concb(2) = moment0_concb(2) + batac(2)*temp6b
        m20b = m20b - temp5*temp5b
        moment2_concb(1) = moment2_concb(1) + m20b
        c3ijb = moment0_conc(2)*moment0_conc(1)*c30atacb
        moment0_concb(1) = moment0_concb(1) + moment0_conc(2)*c3ij*c30atacb
        moment0_concb(2) = moment0_concb(2) + c3ij*moment0_conc(1)*c30atacb
        CALL POPINTEGER4(branch)
        IF (branch .LT. 1) THEN
!          CALL GETCOAGS_B(lamda, kfmatac, kfmatacb, kfmat, kfmatb, kfmac,
!     +              kfmacb, knc, dg_d(1), dg_db(1), dg_d(2), dg_db(2), sg_d(1)
!     +              , sg_d(2), xxl_d(1), xxl_db(1), xxl_d(2), xxl_db(2), batat
!     +              (2), batatb(2), batat(1), batatb(1), bacac(2), bacacb(2),
!     +              bacac(1), bacacb(1), batac(2), batacb(2), bacat(2), bacatb
!     +              (2), batac(1), batacb(1), c3ij, c3ijb)
          CALL GETCOAGS_ADJ(lamda, kfmatac, kfmatacb, kfmat, kfmatb, kfmac,
     +              kfmacb, knc, dg_d(1), dg_db(1), dg_d(2), dg_db(2), sg_d(1)
     +              , sg_d(2), xxl_d(1), xxl_db(1), xxl_d(2), xxl_db(2), batat
     +              (2), batatb(2), batat(1), batatb(1), bacac(2), bacacb(2),
     +              bacac(1), bacacb(1), batac(2), batacb(2), bacat(2), bacatb
     +              (2), batac(1), batacb(1), c3ij, c3ijb)
          DO n=n_mode,1,-1
            aeromode_sdevb(n) = aeromode_sdevb(n) + xxl_db(n)
            xxl_db(n) = 0.0_8
            aeromode_diamb(n) = aeromode_diamb(n) + dg_db(n)
            dg_db(n) = 0.0_8
          END DO
        ELSE
!          CALL INTERCOAG_GH_B(lamda, kfmatac, kfmatacb, knc, aeromode_diam(1)
!     +                  , aeromode_diamb(1), aeromode_diam(2), aeromode_diamb(
!     +                  2), aeromode_sdev(1), aeromode_sdevb(1), aeromode_sdev
!     +                  (2), aeromode_sdevb(2), batac(2), batacb(2), bacat(2)
!     +                  , bacatb(2), batac(1), batacb(1), c3ij, c3ijb)
          CALL INTERCOAG_GH_ADJ(lamda, kfmatac, kfmatacb, knc, aeromode_diam(1)
     +                  , aeromode_diamb(1), aeromode_diam(2), aeromode_diamb(
     +                  2), aeromode_sdev(1), aeromode_sdevb(1), aeromode_sdev
     +                  (2), aeromode_sdevb(2), batac(2), batacb(2), bacat(2)
     +                  , bacatb(2), batac(1), batacb(1), c3ij, c3ijb)

!          CALL INTRACOAG_GH_B(lamda, kfmac, kfmacb, knc, aeromode_diam(2),
!     +                  aeromode_diamb(2), aeromode_sdev(2), aeromode_sdevb(2)
!     +                  , bacac(2), bacacb(2), bacac(1), bacacb(1))
!          CALL INTRACOAG_GH_B(lamda, kfmat, kfmatb, knc, aeromode_diam(1),
!     +                  aeromode_diamb(1), aeromode_sdev(1), aeromode_sdevb(1)
!     +                  , batat(2), batatb(2), batat(1), batatb(1))
          CALL INTRACOAG_GH_ADJ(lamda, kfmac, kfmacb, knc, aeromode_diam(2),
     +                  aeromode_diamb(2), aeromode_sdev(2), aeromode_sdevb(2)
     +                  , bacac(2), bacacb(2), bacac(1), bacacb(1))
          CALL INTRACOAG_GH_ADJ(lamda, kfmat, kfmatb, knc, aeromode_diam(1),
     +                  aeromode_diamb(1), aeromode_sdev(1), aeromode_sdevb(1)
     +                  , batat(2), batatb(2), batat(1), batatb(1))
        END IF
	  
!C	  end if ! pcontrol for coagulation
	  
	  
        temp2 = aeromode_dens(1) + aeromode_dens(2)
        temp4 = 6.0*boltzmann*airtemp
        temp3 = temp4/temp2
        IF (temp3 .EQ. 0.0) THEN
          temp2b = 0.0
        ELSE
          temp2b = -(temp3*kfmatacb/(2.0*SQRT(temp3)*temp2))
        END IF
        aeromode_densb(1) = aeromode_densb(1) + temp2b
        temp1 = airtemp/aeromode_dens(2)
        IF (boltzmann*3.0*temp1 .EQ. 0.0) THEN
          aeromode_densb(2) = aeromode_densb(2) + temp2b
        ELSE
          aeromode_densb(2) = aeromode_densb(2) + temp2b - boltzmann*3.0*temp1
     +      *kfmacb/(2.0*SQRT(boltzmann*3.0*temp1)*aeromode_dens(2))
        END IF
        temp0 = airtemp/aeromode_dens(1)
        IF (.NOT.boltzmann*3.0*temp0 .EQ. 0.0) aeromode_densb(1) =
     +      aeromode_densb(1) - boltzmann*3.0*temp0*kfmatb/(2.0*SQRT(boltzmann
     +      *3.0*temp0)*aeromode_dens(1))
     

!	  end if ! pcontrol for coagulation     
     
     
!        if(pcontrol.eq.3.or.pcontrol.eq.5.or.pcontrol.eq.0) then
        call popreal4array(precursor_conc, n_precursor)
        CALL POPREAL4ARRAY(aeromode_diam, n_mode)
        CALL POPREAL4ARRAY(moment0_conc, n_mode)
        CALL POPREAL4ARRAY(moment2_conc, n_mode)
        CALL POPREAL4ARRAY(moment3_conc, n_mode)
        CALL POPREAL4ARRAY(aerospc_conc, n_aerospc*n_mode)
        CALL POPREAL4ARRAY(aeromode_sdev, n_mode)
        CALL POPREAL4ARRAY(aeromode_mass, n_mode)
        CALL VOLINORG_B(dt, col, row, layer, dv_so4, cgr, m3_wet_flag)
!	  end if
	  
        CALL POPREAL4ARRAY(aeromode_diam, n_mode)
        CALL POPREAL4ARRAY(moment2_conc, n_mode)
        CALL POPREAL4ARRAY(moment3_conc, n_mode)
        CALL POPREAL4ARRAY(aeromode_sdev, n_mode)
        CALL POPREAL4ARRAY(aeromode_mass, n_mode)
        CALL GETPAR_B(m3_wet_flag, limit_sg)
        DO n=n_mode,1,-1
          CALL POPREAL4(moment2_conc(n))
          temp = moment3_conc(n)/m3_old
          IF (temp .LE. 0.0 .AND. (twothirds .EQ. 0.0 .OR. twothirds .NE. INT(
     +        twothirds))) THEN
            tempb = 0.0
          ELSE
            tempb = m2_old*twothirds*temp**(twothirds-1)*moment2_concb(n)/
     +        m3_old
          END IF
          m2_oldb = temp**twothirds*moment2_concb(n)
          moment3_concb(n) = moment3_concb(n) + tempb
          m3_oldb = moment3_concb(n) - temp*tempb
          moment2_concb(n) = m2_oldb
          CALL POPREAL4(moment3_conc(n))
          aerospc_concb(ah2o_idx, n) = aerospc_concb(ah2o_idx, n) + h2ofac*
     +      moment3_concb(n)
          moment3_concb(n) = m3_oldb
          CALL POPREAL4(m2_old)
          CALL POPREAL4(m3_old)
        END DO
	  
!	  if(pcontrol.eq.2.or.pcontrol.eq.0.or.pcontrol.eq.6)
        call popreal4array(precursor_conc, n_precursor)
!     &     CALL HETCHEM_B(gamma_n2o5, dt)
           CALL HETCHEM_ADJ(gamma_n2o5, dt)
	 
!	  if(pcontrol.eq.1.or.pcontrol.eq.0.or.pcontrol.eq.6) then
        CALL POPREAL4ARRAY(aeromode_diam, n_mode)
        CALL POPREAL4ARRAY(moment2_conc, n_mode)
        CALL POPREAL4ARRAY(moment3_conc, n_mode)
        CALL POPREAL4ARRAY(aerospc_conc, n_aerospc*n_mode)
        CALL POPREAL4ARRAY(vapor_conc, n_vapor)
        CALL ORGAER_B(dt, layer)
!	  else
!	    orgprod_concb = 0.0
!	  end if
	  
        m3_wet_flag = .false.
        CALL POPREAL4ARRAY(moment2_conc, n_mode)
        CALL POPREAL4ARRAY(moment3_conc, n_mode)
        CALL POPREAL4ARRAY(aeromode_sdev, n_mode)
        CALL POPREAL4ARRAY(aeromode_mass, n_mode)
        CALL GETPAR_B(m3_wet_flag, limit_sg)
        DO n=n_mode,1,-1
          moment2_concb(n) = moment2_concb(n)/pi
        END DO
        CALL POPINTEGER4(branch)
        IF (.NOT.branch .LT. 1) moment0_concb(n_mode) = 0.0
      END SUBROUTINE AEROPROC_B

!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.4 (r3376) - 10 Feb 2010 17:51
!
!  Differentiation of volinorg in reverse (adjoint) mode:
!   gradient     of useful results: aeromode_diam moment0_conc
!                moment2_conc moment3_conc aeromode_dens aerospc_conc
!                aeromode_sdev aeromode_mass precursor_conc
!   with respect to varying inputs: aeromode_diam moment0_conc
!                moment2_conc moment3_conc aeromode_dens aerospc_conc
!                aeromode_sdev aeromode_mass so4rate precursor_conc
!                precursor_mw hclrat hno3rat nh3rat anthfac soilfac
!                dfh2or8 df h2so4ratm1 cofcbar_so4
!
! /////////////////////////////////////////////////////////////////////
!
      SUBROUTINE VOLINORG_B(dt, col, row, layer, dv_so4, cgr, m3_wet_flag)
        USE SOA_DEFN_B
        USE AERO_DATA_B
        USE PRECURSOR_DATA_B
        USE MET_DATA
        IMPLICIT NONE
!
! *** Calculates the partitioning of inorganic components (CL,NO3,NH4,SO4)
!     between the aerosol and gas phase over the operator synchronization
!     timestep (DT). Partitioning is calculated using the Hybrid approach,
!     where dynamic mass transfer of species to/from the coarse mode is
!     calculated using multiple sub-operator time steps (TSTEP) and the
!     fine modes are equilibrated with the gas phase. The mass transfer
!     calculations are made using the H+ flux-limiting approach of Pilinis
!     et al. (2000). If 'OPTIONFLAG' is not set to 'Hybrid', the mass
!     transfer calculations for the coarse mode are skipped, and the fine
!     modes are equilibrated with the gas phase.
!
!     Returns updated volatile inorganic species concentrations in the gas
!     and particulate phase, and the aerosol modal parameters
!
! *** Revision history: 4/07 - Moved HCOND3 and NEWPART3 calls from
!                              AEROPROC to this subroutine for
!                              mass transfer calculation
!     15 Jul 08, J.Young, P.Bhave: increased cutoff to hybrid from .01 to .05 ug/m**3
!                J.Young: change 'OPTIONFLAG' to just a logical variable, 'Hybrid'
!
! *** References
! 1. Pilinis C, Capaldo KP, Nenes A, Pandis SN (2000) MADM - A new
!    multicomponent aerosol dynamics model. AEROSOL SCIENCE AND TECHNOLOGY.
!    32(5):482-502
!
! 2. Capaldo KP, Pilinis C, Pandis SN (2000) A computationally efficient hybrid
!    approach for dynamic gas/aerosol transfer in air quality models. ATMOSPHERIC
!    ENVIRONMENT. 34(21):3617-3627
!
!
! *** Arguments:
!
! time step [sec]
        REAL :: dt
! grid column index
        INTEGER :: col
! grid row index
        INTEGER :: row
! model layer index
        INTEGER :: layer
! molecular diffusivity of H2SO4 vapor
! after correction for ambient conditions
        REAL :: dv_so4
! 3rd moment SO4 growth rate [m^3/m^3-s]
        REAL*8 :: cgr(n_mode-1)
! flag to include water in GETPAR update
        LOGICAL :: m3_wet_flag
!
! *** Parameters:
!
! number of inorganic species
        INTEGER, PARAMETER :: ninorg=6
! number of volatile inorganic species
! indices for inorganic species
        INTEGER, PARAMETER :: nvolinorg=3
!
        INTEGER, PARAMETER :: knh4=1, kno3=2, kcl=3, kso4=4, kna=5, khp=6
!
! molecular weight for H2SO4
        REAL*8, PARAMETER :: mwh2so4=98.0
        REAL*8, PARAMETER :: faerh2so4=1.0e-6/mwh2so4
        REAL*8, PARAMETER :: d_twothirds=2.0d0/3.0d0
!
! [ug/m**3]
        REAL, PARAMETER :: cutoff=0.05
!
! Accommodation coefficient for sulfuric acid
! see Capaldo et al. (2000)
        REAL, PARAMETER :: alphsulf=0.1
!
! *** Local Variables:
!
! *** Inputs to subroutine HCOND3
!
! Temperature-independent coefficients
! for caculating molecular vel [m/s]
! = sqrt((8*Rgas)/(pi*MW))
        REAL, SAVE :: cofcbar_so4
        REAL, SAVE :: cofcbar_so4b
! molecular velocity of H2SO4
        REAL :: cbar_so4
!
! zeroth moments
        REAL*8 :: am0(n_mode)
        REAL*8 :: am0b(n_mode)
! first moments
        REAL*8 :: am1(n_mode)
        REAL*8 :: am1b(n_mode)
! second moments
        REAL*8 :: am2(n_mode)
        REAL*8 :: am2b(n_mode)
!
! *** Outputs from HCOND3: size-dependent term in the condensational-growth
!     expressions defined in Equations A13-A14 of [Binkowski & Shankar,1995]
! All sizes 2nd and 3rd moments
        REAL*8 :: fconc_so4(n_mode, 2)
        REAL*8 :: fconc_so4b(n_mode, 2)
! reciprocals of total SO4 cond rates
        REAL*8 :: fconcm1_so4
        REAL*8 :: fconcm1_so4b
!
! *** Modal partition factors [ dimensionless ]
!     defined in Equations A17-A18 of [Binkowski & Shankar,1995]
! Aitken mode 2nd and 3rd moments
        REAL*8 :: omega_at_so4
        REAL*8 :: omega_at_so4b
! Accumulation mode 2nd and 3rd moments
        REAL*8 :: omega_ac_so4
        REAL*8 :: omega_ac_so4b
! partitioning coefficient for equilibrium PM mass
        REAL*8 :: omega(2)
        REAL*8 :: omegab(2)
!
! *** Variables for new particle formation:
! steady state H2SO4 concentration
        REAL :: xh2so4
        REAL :: xh2so4b
! particle mass production rate [ ug/m**3 s ]
        REAL*8 :: dmdt_so4
        REAL*8 :: dmdt_so4b
! particle number production rate [ # / m**3 s ]
        REAL*8 :: dndt
        REAL*8 :: dndtb
! second moment production rate [ m**2 / m**3 s]
        REAL*8 :: dm2dt
        REAL*8 :: dm2dtb
! SO4 condensation rate [ ug/m**3 s ]
        REAL*8 :: scondrate
        REAL*8 :: scondrateb
!
! *** Mode-specific sulfate production rate [ ug/m**3 s ]
! sulfate condensation rate [ ug/m**3 s ]
        REAL*8 :: condso4(n_mode)
        REAL*8 :: condso4b(n_mode)
! CONDSO4 or cond+nucl rate
        REAL*8 :: rate
        REAL*8 :: rateb
!
! *** Size-dependent portion of mass-transfer rate equation
! 2nd moment [ m**2/m**3-s ]
        REAL*8 :: grfac1(n_mode)
        REAL*8 :: grfac1b(n_mode)
! 3rd moment [ m**3/m**3-s ]
        REAL*8 :: grfac2(n_mode)
        REAL*8 :: grfac2b(n_mode)
! *** ISORROPIA input variables
! species array
        REAL*8 :: wi(ninorg-1)
        REAL*8 :: wib(ninorg-1)
! relative humidity
        REAL*8 :: rhi
! temperature
        REAL*8 :: tempi
! control parameters
        REAL*8 :: cntrl(2)
!
! *** ISORROPIA output variables
! species output array
        REAL*8 :: wt(ninorg-1)
! gas-phase   "     "
        REAL*8 :: gas(3)
        REAL*8 :: gasb(3)
! liq aerosol "     "
        REAL*8 :: aerliq(12)
        REAL*8 :: aerliqb(12)
! solid "     "     "
        REAL*8 :: aersld(9)
! supplmentary output array
        REAL*8 :: other(6)
! subcase number output
        CHARACTER(len=15) :: scasi
!
! *** Variables to account for mass conservation violations in ISRP3F
! false if ISOROPIA's partitioning
!  of NH4/NH3 is to be ignored
        LOGICAL :: trustnh4
! false if ISOROPIA's partitioning
!  of Cl/HCl is to be ignored
        LOGICAL :: trustcl
!
! *** Initial (double-precision) concentrations [ug/m3]
! gas-phase ammonia
        REAL*8 :: gnh3r8
        REAL*8 :: gnh3r8b
! gas-phase nitric acid
        REAL*8 :: gno3r8
        REAL*8 :: gno3r8b
! gas-phase hydrochloric acid
        REAL*8 :: gclr8
        REAL*8 :: gclr8b
! aerosol LWC
        REAL*8 :: h2or8
!
! *** Variables for volatile species mass transfer between gas and aerosol and
!     mass partitioning between the modes
! mass transfer option flag (mass transfer if .TRUE.)
        LOGICAL :: hybrid
! time step DT [s]
        REAL*8 :: delt
! scratch var for H+ [umol/m**3]
        REAL*8 :: hplus(n_mode)
        REAL*8 :: hplusb(n_mode)
!
! Mol. wt. ratio of SO4/H2SO4
        REAL*8, SAVE :: h2so4ratm1
        REAL*8, SAVE :: h2so4ratm1b
!
! flux of cond./evap. H2SO4 (mol/m3/s)
        REAL*8 :: jh2so4
! concentration of H2SO4 before cond/evap (mol/m3)
        REAL*8 :: ch2so4
! vol inorg spcs mass to be xferred [mol/m3]
        REAL*8 :: dvolinorg(nvolinorg)
        REAL*8 :: dvolinorgb(nvolinorg)
! max value for DVOLINORG
        REAL*8 :: dvolmax
        REAL*8 :: dvolmaxb
! scratch array for inorg spcs [ug/m**3]
        REAL*8 :: cinorg(ninorg, n_mode)
        REAL*8 :: cinorgb(ninorg, n_mode)
! internal mass transfer time (s)
        REAL*8 :: int_time
! mass transfer time step [s]
        REAL*8 :: tstep
! scratch vars for 2nd moment [m**2/m**3]
        REAL*8 :: drym20, y
        REAL*8 :: drym20b, yb
! vars for 3rd moment calculation [m**3/m**3]
        REAL*8 :: m3othr, m3soa
        REAL*8 :: m3othrb, m3soab
! scratch array for mole -> ug conversion
        REAL*8, SAVE :: df(nvolinorg)
        REAL*8, SAVE :: dfb(nvolinorg)
! mole -> ug conversion for H2O
        REAL*8, SAVE :: dfh2or8
        REAL*8, SAVE :: dfh2or8b
! conversion factor for SO4 conc from DH2SO4/DT
        REAL*8 :: convfac
! condensation/evaporation flux [mol/m**3-s]
        REAL*8 :: j(nvolinorg)
        REAL*8 :: jb(nvolinorg)
! conc after mass xfer step [ug/m**3]
        REAL*8 :: cfinal(nvolinorg, n_mode)
        REAL*8 :: cfinalb(nvolinorg, n_mode)
! Scratch LWC variable for output
        REAL*8 :: h2o
        REAL*8 :: h2ob
! Update of LWC after condensation
        REAL*8 :: h2o_new
        REAL*8 :: h2o_newb
! modal SO4 after condensation or cond + nucl
        REAL*8 :: so4
        REAL*8 :: so4b
! excess mass in fine mode partitioning
        REAL*8 :: dmass(nvolinorg)
        REAL*8 :: dmassb(nvolinorg)
! rate of 3rd moment transfer - dry inorg spcs
        REAL*8 :: ddrym3dt
        REAL*8 :: ddrym3dtb
! rate of 2nd moment transfer -  "     "    "
        REAL*8 :: ddrym2dt
        REAL*8 :: ddrym2dtb
! scratch vars for 3rd moment calc [m**3/m**3]
        REAL*8 :: drym3, wetm3
        REAL*8 :: drym3b, wetm3b
! scratch vars for 2nd moment calc [m**2/m**3]
        REAL*8 :: drym2, wetm2
        REAL*8 :: drym2b, wetm2b
! rate of loss of second moment [1/s]
        REAL*8 :: loss
        REAL*8 :: lossb
!
        REAL*8 :: tmp
        REAL*8 :: tmpb
! loop and array indices
        INTEGER :: i, n
! mode loop index
        INTEGER :: imode
! loop index, mass transfer time step loop
        INTEGER :: istep
! loop index, species loop
        INTEGER :: isp
        INTEGER :: logdev
! fix Sg at current value?
        LOGICAL, PARAMETER :: limit_sg=.true.
! For negative vap. press., TrustIso = F
        LOGICAL :: trustiso
!
! *** Local Saved Variables
        LOGICAL, SAVE :: firstime=.true.
        LOGICAL, SAVE :: firstwrite=.true.
!  F6DPIM9 / RHOSO4
        REAL*8, SAVE :: so4fac
!  F6DPIM9 / RHOSOIL
        REAL*8, SAVE :: soilfac
        REAL*8, SAVE :: soilfacb
!  F6DPIM9 / RHOANTH
        REAL*8, SAVE :: anthfac
        REAL*8, SAVE :: anthfacb
! Mol. wt ratios NH3/NH4
        REAL*8, SAVE :: nh3rat
        REAL*8, SAVE :: nh3ratb
! Mol. wt ratios HNO3/NO3
        REAL*8, SAVE :: hno3rat
        REAL*8, SAVE :: hno3ratb
! Mol. wt ratios HCL/CL
        REAL*8, SAVE :: hclrat
        REAL*8, SAVE :: hclratb
        REAL*8 :: tmp0
        INTEGER :: branch
        REAL*8 :: temp3
        DOUBLE PRECISION :: y1b
        REAL*8 :: temp2
        REAL*8 :: temp1
        REAL :: temp0
        INTRINSIC EXP
        REAL*8 :: temp4b5
        REAL*8 :: temp4b4
        REAL*8 :: temp4b3
        REAL*8 :: temp4b2
        REAL*8 :: temp4b1
        REAL*8 :: temp4b0
        REAL*8 :: temp0b
        INTRINSIC MAX
        REAL*8 :: tmp0b
        REAL*8 :: temp3b
        INTRINSIC ABS
        DOUBLE PRECISION :: x2
        DOUBLE PRECISION :: x1
        REAL*8 :: temp2b5
        REAL*8 :: temp2b4
        REAL*8 :: temp2b3
        REAL*8 :: temp2b2
        REAL*8 :: temp2b1
        REAL*8 :: temp2b0
        REAL*8 :: tempb
        REAL*8 :: temp2b
        REAL*8 :: temp3b9
        REAL*8 :: temp3b8
        REAL*8 :: temp3b7
        REAL*8 :: temp3b6
        REAL*8 :: temp3b5
        REAL*8 :: temp3b4
        REAL*8 :: temp3b3
        INTRINSIC DBLE
        REAL*8 :: temp3b2
        INTEGER :: ad_count
        REAL*8 :: temp3b1
        REAL*8 :: temp3b0
        REAL*8 :: abs1
        INTRINSIC MIN
        REAL*8 :: temp1b
        INTRINSIC SQRT
        REAL :: temp
        INTEGER :: i0
        REAL*8 :: temp4b
        DOUBLE PRECISION :: y1
        REAL*8 :: temp4
!
! *** Begin Execution
        IF (firstime) THEN
          firstime=.false.
          cofcbar_so4 = SQRT(8.0*rgasuniv/(pi*mwh2so4*1.0e-3))
          h2so4ratm1 = aerospc_mw(aso4_idx)/mwh2so4
          soilfac = 1.0e-9*f6dpi/aerospc(asoil_idx)%density
          anthfac = 1.0e-9*f6dpi/aerospc(acors_idx)%density
!
          df(knh4) = 1.0d6*aerospc_mw(anh4_idx)
          df(kno3) = 1.0d6*aerospc_mw(ano3_idx)
          df(kcl) = 1.0d6*aerospc_mw(acl_idx)
! aerospc_mw(AH2O_IDX) (18.0 != 18.0153)
! Mol. wt ratios NH3/NH4, HNO3/NO3, HCL/CL
          dfh2or8 = 1.0d6*mwwat
!
          nh3rat = precursor_mw(nh3_idx)/aerospc_mw(anh4_idx)
          hno3rat = precursor_mw(hno3_idx)/aerospc_mw(ano3_idx)
          hclrat = precursor_mw(hcl_idx)/aerospc_mw(acl_idx)
        END IF
!
! *** Determine if Hybrid
        tmp = 0.0
        DO i=1,n_aerospc
          IF (aerospc(i)%charge .NE. 0) tmp = tmp + aerospc_conc(i, n_mode)
        END DO
        hybrid = tmp .GE. cutoff .AND. airrh .GE. 0.18
C######	
	  HYBRID = .false.	  
!
        delt = DBLE(dt)
        convfac = delt*h2so4ratm1
!
! assume const within synch timestep
        tempi = airtemp
        IF (0.95 .GT. airrh) THEN
          rhi = airrh
        ELSE
          rhi = 0.95
        END IF
!
! *** Calculate molecular velocities (temperature dependent) and
!     H+ concentration
!
        cbar_so4 = cofcbar_so4*SQRT(airtemp)
!
        hplus = 0.0
        DO i=1,n_mode
          DO n=1,n_aerospc
            hplus(i) = hplus(i) + aerospc(n)%charge*aerospc_conc(n, i)/
     +        aerospc_mw(n)
          END DO
        END DO
!
! *** Condensational Growth (Size-dependent terms)
!     Calculate intermediate variables needed to determine the 2nd and
!     3rd moment condensational-growth rates.  3rd moment terms are
!     needed for the calculation of new particle production.  See
!     Section 3.3 of Jiang & Roth (2003) for a detailed discussion.
!
! *** Calculate first moments using Equation 4 of Binkowski & Shankar
!     (1995) or Equation 3 of Binkowski and Roselle (2003).
!     N.B: these are for a "wet" size distribution
!
        DO i=1,n_mode
          am0(i) = moment0_conc(i)
          am1(i) = moment0_conc(i)*aeromode_diam(i)*EXP(0.5*aeromode_sdev(i)*
     +      aeromode_sdev(i))
          am2(i) = moment2_conc(i)
        END DO
! *** Calculate the size-dependent terms in the condensational-
!     growth factor expressions for sulfate using
!     Equations A13-A14 of Binkowski & Shankar (1995).
        DO i=1,n_mode
          CALL HCOND3(am0(i), am1(i), am2(i), dv_so4, alphsulf, cbar_so4,
     +          fconc_so4(i, :))
        END DO
!
        IF (.NOT.hybrid) THEN
          fconc_so4(n_mode, 1) = 0.d0
          fconc_so4(n_mode, 2) = 0.d0
          CALL PUSHINTEGER4(1)
        ELSE
          CALL PUSHINTEGER4(0)
        END IF
!
        DO i=1,n_mode
          grfac1(i) = fconc_so4(i, 1)
          grfac2(i) = fconc_so4(i, 2)
        END DO
!
! *** New Particle Production
!     Calculate the new particle production rate due to binary
!     nucleation of H2O and H2SO4.  These calculations are performed
!     only when the gas-phase production rate of H2SO4 (i.e., SO4RATE)
!     is non-zero.  The condensation rate of H2SO4 is calculated as the
!     gas-phase production rate minus the new particle production rate.
!
! *** Initialize Variables
        dmdt_so4 = 0.0d0
        dndt = 0.0d0
        scondrate = 0.0d0
! SO4RATE .NE. 0
!
! *** Produce new particles only during time steps when the gas-phase
!     production rate of H2SO4 is non-zero
!
        IF (so4rate .NE. 0.0d0) THEN
!
! *** Adjust sulfuric acid vapor concentration to a value in
!     equilibrium with the production of new particles and the
!     condensation of sulfuric acid vapor on existing particles, based
!     on Equations A21 and A23 of Binkowski & Shankar (1995).
          tmp = 0.0
          DO i=1,n_mode
            tmp = tmp + fconc_so4(i, 2)
          END DO
!
          xh2so4 = so4rate/tmp
          IF (xh2so4 .LT. conmin) THEN
            xh2so4 = conmin
            CALL PUSHINTEGER4(1)
          ELSE
            CALL PUSHINTEGER4(0)
            xh2so4 = xh2so4
          END IF
          precursor_conc(sulf_idx) = xh2so4
!
! *** Calculate new particle production rate for 0th, 2nd, & 3rd moments
          CALL NEWPART3(airrh, airtemp, xh2so4, so4rate, dndt, dmdt_so4,
     +               dm2dt)
          IF (so4rate - dmdt_so4 .LT. 0.0d0) THEN
            scondrate = 0.0d0
            CALL PUSHINTEGER4(2)
          ELSE
            scondrate = so4rate - dmdt_so4
            CALL PUSHINTEGER4(1)
          END IF
        ELSE
          CALL PUSHINTEGER4(0)
        END IF
        CALL PUSHREAL8(tmp)
!
! *** Sulfate Condensation (Size-resolved)
!     Calculate rate at which condensing sulfate should be added to each
!     mode.  The "omega" factors are defined in Equations 7a and 7b of
!     Binkowski & Shankar (1995). The i-mode and j-mode factors are
!     calculated using Equation A17 of Binkowski & Shankar (1995). The
!     condensation rate for accumulation mode (fine-equilibrium scheme) or
!     coarse mode (hybrid and dynamic schemes) is computed by difference,
!     to avoid mass conservation violations arising from numerical error.
!
        tmp = 0.0
        DO i=1,n_mode
          tmp = tmp + fconc_so4(i, 2)
        END DO
!
        fconcm1_so4 = 1.0d0/tmp
        omega_at_so4 = fconcm1_so4*fconc_so4(1, 2)
        omega_ac_so4 = fconcm1_so4*fconc_so4(2, 2)
!
! *** Growth values for mode merge condition
!
        condso4(1) = omega_at_so4*scondrate
        IF (hybrid) THEN
          condso4(2) = omega_ac_so4*scondrate
          condso4(3) = scondrate - (condso4(1)+condso4(2))
          CALL PUSHINTEGER4(0)
        ELSE
! fine equilibrium
          condso4(2) = scondrate - condso4(1)
! no coarse mode chemistry
          condso4(3) = 0.0d0
          CALL PUSHINTEGER4(1)
        END IF
! endif for 'Hybrid' method
!
!
! *** For Hybrid approach, calculate dynamic mass trasfer for
!     semi-volatile components of coarse mode (NO3, CL, NH4)
!
        IF (hybrid) THEN
!
          int_time = 0.0d0
          tstep = 90.0d0
          istep = 1
          imode = 3
          trustiso = .true.
          ad_count = 0
          DO WHILE (int_time .LT. delt)
!
            IF (int_time + tstep .GT. delt) THEN
              CALL PUSHREAL8(tstep)
              tstep = delt - int_time
              CALL PUSHINTEGER4(1)
            ELSE
              CALL PUSHINTEGER4(0)
            END IF
            int_time = int_time + tstep
            istep = istep + 1
! if ISTEP .GT. 1
!
            IF (istep .GT. 1) THEN
              CALL PUSHREAL8(am0(3))
!
! *** Calculate first moments using Equation 4 of Binkowski & Shankar
!     (1995) or Equation 3 of Binkowski and Roselle (2003).
!     N.B: these are for a "wet" size distribution
!
              am0(3) = moment0_conc(3)
              CALL PUSHREAL8(am1(3))
              am1(3) = moment0_conc(3)*aeromode_diam(3)*EXP(0.5*aeromode_sdev(
     +          3)*aeromode_sdev(3))
              CALL PUSHREAL8(am2(3))
              am2(3) = moment2_conc(3)
              CALL PUSHREAL8ARRAY(fconc_so4(3, :), 2)
!
! *** Calculate the size-dependent terms in the condensational-
!     growth factor expressions for sulfate using
!     Equations A13-A14 of Binkowski & Shankar (1995).
              CALL HCOND3(am0(3), am1(3), am2(3), dv_so4, alphsulf, cbar_so4,
     +              fconc_so4(3, :))
              CALL PUSHREAL8(grfac1(3))
! adapted from Eq A14
!
              grfac1(3) = fconc_so4(3, 1)
              CALL PUSHREAL8(grfac2(3))
              grfac2(3) = fconc_so4(3, 2)
!
              CALL PUSHINTEGER4(1)
            ELSE
              CALL PUSHINTEGER4(0)
            END IF
!
! *** Set conc array to aerosol concentrations prior to mass transfer
!
            cinorg(knh4, imode) = aerospc_conc(anh4_idx, imode)
            cinorg(kno3, imode) = aerospc_conc(ano3_idx, imode)
            cinorg(kcl, imode) = aerospc_conc(acl_idx, imode)
            cinorg(kso4, imode) = aerospc_conc(aso4_idx, imode)
            cinorg(kna, imode) = aerospc_conc(ana_idx, imode)
            cinorg(khp, imode) = hplus(imode)
!
            m3othr = soilfac*aerospc_conc(asoil_idx, imode) + anthfac*
     +        aerospc_conc(acors_idx, imode)
            m3soa = 0.0d0
            CALL PUSHREAL8(wetm3)
            wetm3 = moment3_conc(imode)
            wetm2 = moment2_conc(imode)
            CALL PUSHREAL8(drym3)
            drym3 = wetm3 - DBLE(h2ofac*aerospc_conc(ah2o_idx, imode))
            drym20 = wetm2*(drym3/wetm3)**d_twothirds
!
! *** Initial vapor-phase concentrations [ug/m3]
            gno3r8 = precursor_conc(hno3_idx)
            gnh3r8 = precursor_conc(nh3_idx)
            gclr8 = precursor_conc(hcl_idx)
!
! *** This section of code calculates the distribution of ammonia/
!     ammonium, nitric acid/nitrate, and water between the gas and
!     aerosol phases as a function of total sulfate, total ammonia,
!     total nitrate, relative humidity, and temperature.  It is assumed
!     that the aerosol is entirely aqueous (i.e., metastable assumption),
!     irrespective of ambient relative humidity.
!
! *** Compute sulfate production rate [ug/m3 s] for coarse mode
!
            rate = condso4(imode)
            so4 = cinorg(kso4, imode) + rate*tstep*h2so4ratm1
! TrustIso
!
            IF (trustiso) THEN
              CALL PUSHREAL8(wi(1))
!
! *** Double Precision vars for ISORROPIA [mole/m3]
              wi(1) = cinorg(kna, imode)*(1.0d-6/aerospc_mw(ana_idx))
              CALL PUSHREAL8(wi(2))
              wi(2) = so4*(1.0d-6/aerospc_mw(aso4_idx))
              CALL PUSHREAL8(wi(3))
              wi(3) = cinorg(knh4, imode)*(1.0d-6/aerospc_mw(anh4_idx))
              CALL PUSHREAL8(wi(4))
              wi(4) = cinorg(kno3, imode)*(1.0d-6/aerospc_mw(ano3_idx))
              CALL PUSHREAL8(wi(5))
              wi(5) = cinorg(kcl, imode)*(1.0d-6/aerospc_mw(acl_idx))
!
! reverse problem
! aerosol in metastable state
!
! *** Set flags to account for mass conservation violations in ISRP3F
!
!
!     WI( 1 ) = NA    [mol/m3]
!     WI( 2 ) = SO4      "
!     WI( 3 ) = NH4      "
!     WI( 4 ) = NO3      "
!     WI( 5 ) = CL       "
!     GAS(1) = NH3, GAS(2) = HNO3, GAS(3) = HCl

              CALL ISOROPIA(wi, rhi, tempi, cntrl, wt, gas, aerliq, aersld,
     +                scasi, other, trustiso)
     
!		   GAS( 1 ) = GNH3R8 * ( 1.0D-6 / dble(PRECURSOR_MW( NH3_IDX ) ))
!               GAS( 2 ) = GNO3R8 * ( 1.0D-6 / dble(PRECURSOR_MW( HNO3_IDX ) ))
!               GAS( 3 ) = GCLR8  * ( 1.0D-6 / dble(PRECURSOR_MW( HCL_IDX )) )
!
              IF ((gas(1) .LT. 0.0d0 .OR. gas(2) .LT. 0.0d0) .OR. gas(3) .LT.
     +            0.0d0) THEN
                CALL PUSHINTEGER4(1)
                IF (firstwrite) THEN
                  firstwrite = .false.
                  WRITE(logdev, 2023)
                END IF
                WRITE(logdev, 2029) col, row, layer, gas(1), gas(2), gas(3)
                trustiso = .false.
              ELSE
                CALL PUSHINTEGER4(1)
              END IF
            ELSE
              CALL PUSHINTEGER4(0)
            END IF
!
!
! *** Change in volatile inorganic PM concentration to achieve
!     equilibrium, calculated as initial-gas-phase concentration minus
!     equilibrium gas-phase concentration. DVOLINORG is positive for
!     condensation and negative for evaporation.
!
            dvolinorg(knh4) = gnh3r8*(1.0d-6/precursor_mw(nh3_idx)) - gas(1)
            dvolinorg(kno3) = gno3r8*(1.0d-6/precursor_mw(hno3_idx)) - gas(2)
            dvolinorg(kcl) = gclr8*(1.0d-6/precursor_mw(hcl_idx)) - gas(3)
! *** Calculate condensation/evaporation flux for this time step and update
!     volatile species concentrations.  final aerosol conc set to be
!     no less than the minimum aerosol conc
!
            IF (trustiso) THEN
              CALL COMPUTE_FLUX(nvolinorg, gnh3r8, gno3r8, gclr8, knh4, kno3,
     +                    kcl, gas(1:3), grfac2(imode), aerliq(1), rate, j)
              CALL PUSHINTEGER4(0)
            ELSE
              j(:) = 0.0d0
              CALL PUSHINTEGER4(1)
            END IF
!
            IF (j(knh4)*tstep*df(knh4)*nh3rat .GT. gnh3r8) THEN
              WRITE(logdev, *) 'Condensed amt. exceeds NH3 conc: aero_subs.f'
              j(knh4) = gnh3r8/(tstep*df(knh4)*nh3rat)
              CALL PUSHINTEGER4(1)
            ELSE
              CALL PUSHINTEGER4(0)
            END IF
            IF (j(kno3)*tstep*df(kno3)*hno3rat .GT. gno3r8) THEN
              WRITE(logdev, *) 'Condensed amt. exceeds HNO3 conc: aero_subs.f'
              j(kno3) = gno3r8/(tstep*df(kno3)*hno3rat)
              CALL PUSHINTEGER4(1)
            ELSE
              CALL PUSHINTEGER4(0)
            END IF
            IF (j(kcl)*tstep*df(kcl)*hclrat .GT. gclr8) THEN
              WRITE(logdev, *) 'Condensed amt. exceeds HCl conc: aero_subs.f'
              j(kcl) = gclr8/(tstep*df(kcl)*hclrat)
              CALL PUSHINTEGER4(1)
            ELSE
              CALL PUSHINTEGER4(0)
            END IF
!
! *** Integrate mass transfer equation, convert flux from molar to mass
!
            DO isp=1,nvolinorg
              y1 = cinorg(isp, imode) + j(isp)*tstep*df(isp)
              IF (0.0d0 .LT. y1) THEN
                cfinal(isp, imode) = y1
                CALL PUSHINTEGER4(3)
              ELSE
                cfinal(isp, imode) = 0.0d0
                CALL PUSHINTEGER4(2)
              END IF
            END DO
!
! *** Calculate updated H+ concentration
!
            hplus(imode) = 2.0d0*so4/aerospc_mw(aso4_idx) + cfinal(kno3, imode
     +        )/aerospc_mw(ano3_idx) + cfinal(kcl, imode)/aerospc_mw(acl_idx)
     +        - cfinal(knh4, imode)/aerospc_mw(anh4_idx) - cinorg(kna, imode)/
     +        aerospc_mw(ana_idx)
            CALL PUSHREAL8(wi(1))
!
! *** Equilibrate aerosol LWC with CFINAL by calling CALC_H2O
!
            wi(1) = cinorg(kna, imode)*(1.0d-6/aerospc_mw(ana_idx))
            CALL PUSHREAL8(wi(2))
            wi(2) = so4*(1.0d-6/aerospc_mw(aso4_idx))
            CALL PUSHREAL8(wi(3))
            wi(3) = cfinal(knh4, imode)*(1.0d-6/aerospc_mw(anh4_idx))
            CALL PUSHREAL8(wi(4))
            wi(4) = cfinal(kno3, imode)*(1.0d-6/aerospc_mw(ano3_idx))
            CALL PUSHREAL8(wi(5))
            wi(5) = cfinal(kcl, imode)*(1.0d-6/aerospc_mw(acl_idx))
!
            CALL CALC_H2O(wi, rhi, tempi, h2o_new)
!
            h2o = h2o_new*dfh2or8
            CALL PUSHREAL8(ddrym3dt)
!
! *** Compute net change in 3rd moment due to dry inorganic mass transfer
!
            ddrym3dt = ((cfinal(knh4, imode)-cinorg(knh4, imode))*(1.0d-9*
     +        f6dpi/aerospc(anh4_idx)%density)+(cfinal(kno3, imode)-cinorg(
     +        kno3, imode))*(1.0d-9*f6dpi/aerospc(ano3_idx)%density)+(cfinal(
     +        kcl, imode)-cinorg(kcl, imode))*(1.0d-9*f6dpi/aerospc(acl_idx)%
     +        density)+(so4-cinorg(kso4, imode))*(1.0d-9*f6dpi/aerospc(
     +        aso4_idx)%density))/tstep
!
! *** Compute net change in 2nd moment due to dry inorganic mass transfer
!     (including nucleation) using equation A7 of Binkowski & Shankar (1995)
            ddrym2dt = d_twothirds*grfac1(imode)/grfac2(imode)*ddrym3dt
!
! *** Update dry 2nd moment for condensation/evaporation based on whether
!     net change in dry 2nd moment is production or loss
            IF (ddrym2dt .LT. 0.0d0) THEN
              loss = ddrym2dt/drym20
              y = drym20*EXP(loss*tstep)
              CALL PUSHINTEGER4(0)
            ELSE
              y = drym20 + ddrym2dt*tstep
              CALL PUSHINTEGER4(1)
            END IF
            CALL PUSHREAL8(drym3)
!
! *** Add water and SOA to 2nd moment while preserving standard deviation
!
            drym3 = 1.0d-9*f6dpi/aerospc(aso4_idx)%density*so4 + 1.0d-9*f6dpi/
     +        aerospc(anh4_idx)%density*cfinal(knh4, imode) + 1.0d-9*f6dpi/
     +        aerospc(ano3_idx)%density*cfinal(kno3, imode) + 1.0d-9*f6dpi/
     +        aerospc(acl_idx)%density*cfinal(kcl, imode) + 1.0d-9*f6dpi/
     +        aerospc(ana_idx)%density*cinorg(kna, imode) + m3othr
            CALL PUSHREAL8(wetm3)
!
            wetm3 = drym3 + m3soa + 1.0d-9*f6dpi/aerospc(ah2o_idx)%density*h2o
            x1 = DBLE(aeromode(imode)%min_m2)
            IF (x1 .LT. y) THEN
              CALL PUSHREAL8(drym2)
              drym2 = y
              CALL PUSHINTEGER4(1)
            ELSE
              CALL PUSHREAL8(drym2)
              drym2 = x1
              CALL PUSHINTEGER4(0)
            END IF
            CALL PUSHREAL8(wetm2)
            wetm2 = drym2*(wetm3/drym3)**d_twothirds
!
!
            precursor_conc(nh3_idx) = gnh3r8 + (cinorg(knh4, imode)-cfinal(
     +        knh4, imode))*nh3rat
            precursor_conc(hno3_idx) = gno3r8 + (cinorg(kno3, imode)-cfinal(
     +        kno3, imode))*hno3rat
            precursor_conc(hcl_idx) = gclr8 + (cinorg(kcl, imode)-cfinal(kcl,
     +        imode))*hclrat
            CALL PUSHREAL4(aerospc_conc(anh4_idx, imode))
!
            aerospc_conc(anh4_idx, imode) = cfinal(knh4, imode)
            CALL PUSHREAL4(aerospc_conc(ano3_idx, imode))
            aerospc_conc(ano3_idx, imode) = cfinal(kno3, imode)
            CALL PUSHREAL4(aerospc_conc(acl_idx, imode))
            aerospc_conc(acl_idx, imode) = cfinal(kcl, imode)
            CALL PUSHREAL4(aerospc_conc(aso4_idx, imode))
            aerospc_conc(aso4_idx, imode) = so4
            CALL PUSHREAL4(aerospc_conc(ah2o_idx, imode))
            aerospc_conc(ah2o_idx, imode) = h2o
            moment2_conc(imode) = wetm2
            CALL PUSHREAL4ARRAY(aeromode_mass, n_mode)
            CALL PUSHREAL4ARRAY(aeromode_sdev, n_mode)
            CALL PUSHREAL4ARRAY(moment3_conc, n_mode)
            CALL PUSHREAL4ARRAY(moment2_conc, n_mode)
            CALL PUSHREAL4ARRAY(aeromode_diam, n_mode)
!
! *** Update the third moments, geometric mean diameters, geometric
!     standard deviations, modal mass totals, and modal particle
!     densities.
            CALL GETPAR(m3_wet_flag, limit_sg)
            ad_count = ad_count + 1
          END DO
          CALL PUSHINTEGER4(ad_count)
          CALL PUSHINTEGER4(1)
        ELSE
          CALL PUSHINTEGER4(0)
        END IF
!
! end mass transfer time step loop
!
! *** End of dynamic mass transfer calculations for coarse mode
!
! *** Call ISORROPIA in forward mode to calculate gas-particle equilibrium in
!     the fine aerosol modes
!
	  CALL PUSHREAL8(gnh3r8)
	  CALL PUSHREAL8(gno3r8)
	  CALL PUSHREAL8(gclr8)
        gnh3r8 = precursor_conc(nh3_idx)
        gno3r8 = precursor_conc(hno3_idx)
        gclr8 = precursor_conc(hcl_idx)
!
! *** Compute sulfate from total sulfate production rate [ug/m3-s] for fine
!     modes; add in H2SO4 nucleated in model timestep
!
        so4 = aerospc_conc(aso4_idx, 1) + aerospc_conc(aso4_idx, 2)
        so4 = so4 + (dmdt_so4+condso4(1)+condso4(2))*delt*h2so4ratm1
        CALL PUSHREAL8(wi(1))
!
        wi(1) = (aerospc_conc(ana_idx, 1)+aerospc_conc(ana_idx, 2))*(1.0d-6/
     +    aerospc_mw(ana_idx))
        CALL PUSHREAL8(wi(2))
        wi(2) = so4*(1.0d-6/aerospc_mw(aso4_idx))
        CALL PUSHREAL8(wi(3))
        wi(3) = precursor_conc(nh3_idx)*(1.0d-6/precursor_mw(nh3_idx)) + (
     +    aerospc_conc(anh4_idx, 1)+aerospc_conc(anh4_idx, 2))*(1.0d-6/
     +    aerospc_mw(anh4_idx))
        CALL PUSHREAL8(wi(4))
        wi(4) = precursor_conc(hno3_idx)*(1.0d-6/precursor_mw(hno3_idx)) + (
     +    aerospc_conc(ano3_idx, 1)+aerospc_conc(ano3_idx, 2))*(1.0d-6/
     +    aerospc_mw(ano3_idx))
        CALL PUSHREAL8(wi(5))
!
        wi(5) = precursor_conc(hcl_idx)*(1.0d-6/precursor_mw(hcl_idx)) + (
     +    aerospc_conc(acl_idx, 1)+aerospc_conc(acl_idx, 2))*(1.0d-6/
     +    aerospc_mw(acl_idx))
!
!
! Forward Problem
! Aerosol in Metastable State
!
! *** Set flags to account for mass conservation violations in ISRP3F
!
        trustcl = .true.
        IF (wi(1) + wi(5) .LT. 1.0d-20) THEN
          trustcl = .false.
        ELSE IF (wi(5) .LT. 1.0d-10) THEN
          trustcl = .false.
        END IF
	  
	  
C	  if(wi(1).lt.0 .or. wi(2).lt.0 .or. wi(3).lt.0. .or. wi(4).lt.0 .or. wi(5).lt.0) then
C	   write(*,*) "negative wi in volinorg_b"
C	   write(*,*) wi
C	   write(*,*) precursor_conc
C	   write(*,*) aerospc_conc
C	   
C	   stop
C	  end if
	  
C	   GAS( 1 ) = GNH3R8 * ( 1.0D-6 / dble(PRECURSOR_MW( NH3_IDX ) ))
C         GAS( 2 ) = GNO3R8 * ( 1.0D-6 / dble(PRECURSOR_MW( HNO3_IDX ) ))
C         GAS( 3 ) = GCLR8  * ( 1.0D-6 / dble(PRECURSOR_MW( HCL_IDX )) )
	  
	        CALL PUSHREAL8ARRAY(aerliq, 12)
		  CALL PUSHREAL8ARRAY(wi, 5)
		  
		  CALL PUSHINTEGER4(0)
		  CNTRL( 1 ) = 0.0D0   ! Forward Problem
              CNTRL( 2 ) = 1.0D0   ! Aerosol in Metastable State

      ! To prevent calls to ISO at T & P at which
      !    equilibrium thermodynamics do not govern partitioning
      ! slc.8.2013 - tested in CMAQv.5.0.1 by Jia Xing
      if (( AIRTEMP .GT. 250.0 )
     +       .AND.( AIRPRS .GT. 20000.0 ) ) THEN

              CALL ISOROPIA(wi, rhi, tempi, cntrl, wt, gas, aerliq, aersld,
     +                scasi, other, TrustIso)
      else 
         TrustIso = .false.
      endif

              IF ( .NOT.TrustIso ) THEN		     
                 CALL POPREAL8ARRAY(wi, 5)
                 CALL POPREAL8ARRAY(aerliq, 12)
		     CALL POPINTEGER4(branch)
		     CALL PUSHINTEGER4(1)
  		     GAS( 1 ) = GNH3R8 * ( 1.0D-6 / dble(PRECURSOR_MW( NH3_IDX ) ))
                 GAS( 2 ) = GNO3R8 * ( 1.0D-6 / dble(PRECURSOR_MW( HNO3_IDX ) ))
                 GAS( 3 ) = GCLR8  * ( 1.0D-6 / dble(PRECURSOR_MW( HCL_IDX )) )
		  end if
!
! *** Update gas-phase concentrations
!
!
! *** Change in volatile inorganic PM concentration to achieve
!     equilibrium, calculated as initial-gas-phase concentration minus
!     equilibrium gas-phase concentration. DVOLINORG is positive for
!     condensation and negative for evaporation.
!
        dvolinorg(knh4) = gnh3r8*1.0d-6/DBLE(precursor_mw(nh3_idx)) - gas(1)
        dvolinorg(kno3) = gno3r8*1.0d-6/DBLE(precursor_mw(hno3_idx)) - gas(2)
!
        IF (trustcl) THEN
          dvolinorg(kcl) = gclr8*1.0d-6/DBLE(precursor_mw(hcl_idx)) - gas(3)
          CALL PUSHINTEGER4(0)
        ELSE
          dvolinorg(kcl) = 0.0d0
          CALL PUSHINTEGER4(1)
        END IF
!
        IF (dvolinorg(knh4) .LT. 0.0d0) THEN
          dvolmax = -((DBLE(aerospc_conc(anh4_idx, 1))+DBLE(aerospc_conc(
     +      anh4_idx, 2)))/df(knh4))
          IF (dvolinorg(knh4) .LT. dvolmax) THEN
            dvolinorg(knh4) = dvolmax
            CALL PUSHINTEGER4(2)
          ELSE
            dvolinorg(knh4) = dvolinorg(knh4)
            CALL PUSHINTEGER4(1)
          END IF
        ELSE
          CALL PUSHINTEGER4(0)
        END IF
!
        IF (dvolinorg(kno3) .LT. 0.0d0) THEN
          dvolmax = -((DBLE(aerospc_conc(ano3_idx, 1))+DBLE(aerospc_conc(
     +      ano3_idx, 2)))/df(kno3))
          IF (dvolinorg(kno3) .LT. dvolmax) THEN
            dvolinorg(kno3) = dvolmax
            CALL PUSHINTEGER4(2)
          ELSE
            dvolinorg(kno3) = dvolinorg(kno3)
            CALL PUSHINTEGER4(1)
          END IF
        ELSE
          CALL PUSHINTEGER4(0)
        END IF
!
        IF (dvolinorg(kcl) .LT. 0.0d0) THEN
          dvolmax = -((DBLE(aerospc_conc(acl_idx, 1))+DBLE(aerospc_conc(
     +      acl_idx, 2)))/df(kcl))
          IF (dvolinorg(kcl) .LT. dvolmax) THEN
            dvolinorg(kcl) = dvolmax
            CALL PUSHINTEGER4(2)
          ELSE
            dvolinorg(kcl) = dvolinorg(kcl)
            CALL PUSHINTEGER4(1)
          END IF
        ELSE
          CALL PUSHINTEGER4(0)
        END IF
!
! partitioning cof
        omega(1) = grfac2(1)/(grfac2(1)+grfac2(2))
        omega(2) = 1.0d0 - omega(1)
!
! *** Initialize excess evaporated mass array
!
        dmass = 0.0d0
        CALL PUSHINTEGER4(imode)
!
! modal partitioning of equilibrium aerosol mass
        DO imode=1,2
!
          cinorg(kso4, imode) = aerospc_conc(aso4_idx, imode)
          cinorg(knh4, imode) = aerospc_conc(anh4_idx, imode)
          cinorg(kno3, imode) = aerospc_conc(ano3_idx, imode)
          cinorg(kna, imode) = aerospc_conc(ana_idx, imode)
          cinorg(kcl, imode) = aerospc_conc(acl_idx, imode)
          CALL PUSHREAL8(wetm3)
!
          wetm3 = moment3_conc(imode)
          wetm2 = moment2_conc(imode)
!
          IF (imode .EQ. 1) THEN
            rate = dmdt_so4 + condso4(imode)
            CALL PUSHINTEGER4(0)
          ELSE
            rate = condso4(imode)
            CALL PUSHINTEGER4(1)
          END IF
!
          m3othr = 0.0
          m3soa = 0.0
! Skip organic species
          DO i=1,n_aerospc
!
            IF (((((i .EQ. aso4_idx .OR. i .EQ. anh4_idx) .OR. i .EQ. ano3_idx
     +          ) .OR. i .EQ. ana_idx) .OR. i .EQ. acl_idx) .OR. i .EQ.
     +          ah2o_idx) THEN
              CALL PUSHINTEGER4(2)
            ELSE IF (aerospc(i)%iswet) THEN
!
              m3soa = m3soa + 1.0d-9*f6dpi/aerospc(i)%density*aerospc_conc(i,
     +          imode)
              CALL PUSHINTEGER4(3)
            ELSE
              m3othr = m3othr + 1.0d-9*f6dpi/aerospc(i)%density*aerospc_conc(i
     +          , imode)
              CALL PUSHINTEGER4(4)
            END IF
          END DO
          CALL PUSHREAL8(drym3)
!
!
! N_AEROSPC loop
!
          drym3 = wetm3 - DBLE(h2ofac*aerospc_conc(ah2o_idx, imode)) - m3soa
          drym20 = wetm2*(drym3/wetm3)**d_twothirds
!
          DO isp=1,nvolinorg
            cfinal(isp, imode) = cinorg(isp, imode) + omega(imode)*dvolinorg(
     +        isp)*df(isp)
! IMODE = 1
!
            IF (imode .EQ. 1) THEN
!
              IF (cfinal(isp, imode) .LT. 0.0d0) THEN
                dmass(isp) = cfinal(isp, imode)
                cfinal(isp, imode) = 0.0d0
                CALL PUSHINTEGER4(2)
              ELSE
                CALL PUSHINTEGER4(1)
              END IF
            ELSE
!
!
              cfinal(isp, imode) = cfinal(isp, imode) + dmass(isp)
!
              IF (cfinal(isp, imode) .LT. 0.0d0) THEN
                tmp0 = cfinal(isp, 1) + cfinal(isp, imode)
                cfinal(isp, 1) = tmp0
                cfinal(isp, imode) = 0.0d0
!
                IF (cfinal(isp, 1) .LT. 0.0d0) THEN
                  IF (cfinal(isp, 1) .GE. 0.) THEN
                    abs1 = cfinal(isp, 1)
                  ELSE
                    abs1 = -cfinal(isp, 1)
                  END IF
                  IF (abs1 .LT. 1.0d-15) THEN
                    cfinal(isp, 1) = 0.0d0
                    CALL PUSHINTEGER4(6)
                  ELSE
                    PRINT*, 'Too much evaporation: aero_subs.f'
                    cfinal(isp, 1) = 0.0d0
!                       STOP
                    CALL PUSHINTEGER4(5)
                  END IF
                ELSE
                  CALL PUSHINTEGER4(4)
                END IF
              ELSE
                CALL PUSHINTEGER4(3)
              END IF
            END IF
          END DO
!
          so4 = cinorg(kso4, imode) + rate*convfac
          CALL PUSHREAL8(wi(1))
!
! *** Double precision vars for ISORROPIA
!
          wi(1) = cinorg(kna, imode)*1.0d-6/aerospc_mw(ana_idx)
          CALL PUSHREAL8(wi(2))
          wi(2) = so4*1.0d-6/aerospc_mw(aso4_idx)
          CALL PUSHREAL8(wi(3))
          wi(3) = cfinal(knh4, imode)*1.0d-6/aerospc_mw(anh4_idx)
          CALL PUSHREAL8(wi(4))
          wi(4) = cfinal(kno3, imode)*1.0d-6/aerospc_mw(ano3_idx)
          CALL PUSHREAL8(wi(5))
          wi(5) = cfinal(kcl, imode)*1.0d-6/aerospc_mw(acl_idx)
!
          CALL CALC_H2O(wi, rhi, tempi, h2o_new)
          h2o = h2o_new*dfh2or8
          CALL PUSHREAL8(ddrym3dt)
!
!
! *** Compute net change in 3rd moment due to dry inorganic mass transfer
!     (includes nucleated sulfate mass)
!
          ddrym3dt = ((cfinal(knh4, imode)-cinorg(knh4, imode))*(1.0d-9*f6dpi/
     +      aerospc(anh4_idx)%density)+(cfinal(kno3, imode)-cinorg(kno3, imode
     +      ))*(1.0d-9*f6dpi/aerospc(ano3_idx)%density)+(cfinal(kcl, imode)-
     +      cinorg(kcl, imode))*(1.0d-9*f6dpi/aerospc(acl_idx)%density)+(so4-
     +      cinorg(kso4, imode))*(1.0d-9*f6dpi/aerospc(aso4_idx)%density))/
     +      delt
!
! *** Compute net change in 2nd moment due to dry inorganic mass transfer
!     (including nucleation) using equation A7 of Binkowski & Shankar (1995)
          ddrym2dt = d_twothirds*grfac1(imode)/grfac2(imode)*ddrym3dt
!
!
! *** Update dry 2nd moment for condensation/evaporation based on whether
!     net change in dry 2nd moment is production or loss
!
          IF (ddrym2dt .LT. 0.0d0) THEN
            loss = ddrym2dt/drym20
            y = drym20*EXP(loss*delt)
            CALL PUSHINTEGER4(0)
          ELSE
            y = drym20 + ddrym2dt*delt
            CALL PUSHINTEGER4(1)
          END IF
          CALL PUSHREAL8(drym3)
! *** Add water and SOA to 2nd moment while preserving standard deviation
!
          drym3 = 1.0e-9*f6dpi/aerospc(aso4_idx)%density*so4 + 1.0e-9*f6dpi/
     +      aerospc(anh4_idx)%density*cfinal(knh4, imode) + 1.0e-9*f6dpi/
     +      aerospc(ano3_idx)%density*cfinal(kno3, imode) + 1.0e-9*f6dpi/
     +      aerospc(acl_idx)%density*cfinal(kcl, imode) + 1.0d-9*f6dpi/aerospc
     +      (ana_idx)%density*cinorg(kna, imode) + m3othr
          CALL PUSHREAL8(wetm3)
!
          wetm3 = drym3 + m3soa + DBLE(h2ofac)*h2o
          x2 = DBLE(aeromode(imode)%min_m2)
          IF (x2 .LT. y) THEN
            CALL PUSHREAL8(drym2)
            drym2 = y
            CALL PUSHINTEGER4(1)
          ELSE
            CALL PUSHREAL8(drym2)
            drym2 = x2
            CALL PUSHINTEGER4(0)
          END IF
          CALL PUSHREAL8(wetm2)
          wetm2 = drym2*(wetm3/drym3)**d_twothirds
          CALL PUSHREAL4(aerospc_conc(anh4_idx, imode))
!
          aerospc_conc(anh4_idx, imode) = cfinal(knh4, imode)
          CALL PUSHREAL4(aerospc_conc(ano3_idx, imode))
          aerospc_conc(ano3_idx, imode) = cfinal(kno3, imode)
          CALL PUSHREAL4(aerospc_conc(acl_idx, imode))
          aerospc_conc(acl_idx, imode) = cfinal(kcl, imode)
          CALL PUSHREAL4(aerospc_conc(aso4_idx, imode))
          aerospc_conc(aso4_idx, imode) = so4
          CALL PUSHREAL4(aerospc_conc(ah2o_idx, imode))
          aerospc_conc(ah2o_idx, imode) = h2o
          IF (imode .EQ. 1) THEN
            CALL PUSHREAL4(moment0_conc(imode))
            moment0_conc(imode) = am0(imode) + dndt*delt
            CALL PUSHINTEGER4(1)
          ELSE
            CALL PUSHINTEGER4(0)
          END IF
          moment2_conc(imode) = wetm2
        END DO
        CALL GETPAR_B(m3_wet_flag, limit_sg)
        omegab = 0.0_8
        dmassb = 0.0_8
        dndtb = 0.0_8
        am0b = 0.0_8
        dvolinorgb = 0.0_8
        grfac1b = 0.0_8
        grfac2b = 0.0_8
        dmdt_so4b = 0.0_8
        cfinalb = 0.0_8
        cinorgb = 0.0_8
        condso4b = 0.0_8
        wib = 0.0_8
        DO imode=2,1,-1
          wetm2b = moment2_concb(imode)
          moment2_concb(imode) = 0.0
          CALL POPINTEGER4(branch)
          IF (.NOT.branch .LT. 1) THEN
            CALL POPREAL4(moment0_conc(imode))
            am0b(imode) = am0b(imode) + moment0_concb(imode)
            dndtb = dndtb + delt*moment0_concb(imode)
            moment0_concb(imode) = 0.0
          END IF
          CALL POPREAL4(aerospc_conc(ah2o_idx, imode))
          h2ob = aerospc_concb(ah2o_idx, imode)
          aerospc_concb(ah2o_idx, imode) = 0.0
          CALL POPREAL4(aerospc_conc(aso4_idx, imode))
          so4b = aerospc_concb(aso4_idx, imode)
          aerospc_concb(aso4_idx, imode) = 0.0
          CALL POPREAL4(aerospc_conc(acl_idx, imode))
          cfinalb(kcl, imode) = cfinalb(kcl, imode) + aerospc_concb(acl_idx,
     +      imode)
          aerospc_concb(acl_idx, imode) = 0.0
          CALL POPREAL4(aerospc_conc(ano3_idx, imode))
          cfinalb(kno3, imode) = cfinalb(kno3, imode) + aerospc_concb(ano3_idx
     +      , imode)
          aerospc_concb(ano3_idx, imode) = 0.0
          CALL POPREAL4(aerospc_conc(anh4_idx, imode))
          cfinalb(knh4, imode) = cfinalb(knh4, imode) + aerospc_concb(anh4_idx
     +      , imode)
          aerospc_concb(anh4_idx, imode) = 0.0
          CALL POPREAL8(wetm2)
          temp4 = wetm3/drym3
          IF (temp4 .LE. 0.0 .AND. (d_twothirds .EQ. 0.0 .OR. d_twothirds .NE.
     +        INT(d_twothirds))) THEN
            temp4b5 = 0.0
          ELSE
            temp4b5 = drym2*d_twothirds*temp4**(d_twothirds-1)*wetm2b/drym3
          END IF
          drym2b = temp4**d_twothirds*wetm2b
          wetm3b = temp4b5
          drym3b = -(temp4*temp4b5)
          CALL POPINTEGER4(branch)
          IF (branch .LT. 1) THEN
            CALL POPREAL8(drym2)
            yb = 0.0_8
          ELSE
            CALL POPREAL8(drym2)
            yb = drym2b
          END IF
          CALL POPREAL8(wetm3)
          drym3b = drym3b + wetm3b
          m3soab = wetm3b
          h2ob = h2ob + DBLE(h2ofac)*wetm3b
          CALL POPREAL8(drym3)
          so4b = so4b + f6dpi*1.0e-9*drym3b/aerospc(aso4_idx)%density
          cfinalb(knh4, imode) = cfinalb(knh4, imode) + f6dpi*1.0e-9*drym3b/
     +      aerospc(anh4_idx)%density
          cfinalb(kno3, imode) = cfinalb(kno3, imode) + f6dpi*1.0e-9*drym3b/
     +      aerospc(ano3_idx)%density
          cfinalb(kcl, imode) = cfinalb(kcl, imode) + f6dpi*1.0e-9*drym3b/
     +      aerospc(acl_idx)%density
          cinorgb(kna, imode) = cinorgb(kna, imode) + f6dpi*1.0d-9*drym3b/
     +      aerospc(ana_idx)%density
     
          m3othrb = drym3b
          CALL POPINTEGER4(branch)
          IF (branch .LT. 1) THEN
            wetm3 = moment3_conc(imode)
            drym20 = wetm2*(drym3/wetm3)**d_twothirds
            ddrym2dt = d_twothirds*grfac1(imode)/grfac2(imode)*ddrym3dt
            loss = ddrym2dt/drym20
            lossb = drym20*EXP(delt*loss)*delt*yb
            drym20b = EXP(delt*loss)*yb - ddrym2dt*lossb/drym20**2
            ddrym2dtb = lossb/drym20
          ELSE
            drym20b = yb
            ddrym2dtb = delt*yb
          END IF
          temp4b = d_twothirds*ddrym2dtb/grfac2(imode)
          grfac1b(imode) = grfac1b(imode) + ddrym3dt*temp4b
          ddrym3dtb = grfac1(imode)*temp4b
          grfac2b(imode) = grfac2b(imode) - grfac1(imode)*ddrym3dt*temp4b/
     +      grfac2(imode)
          CALL POPREAL8(ddrym3dt)
          temp4b0 = ddrym3dtb/delt
          temp4b1 = f6dpi*1.0d-9*temp4b0/aerospc(anh4_idx)%density
          temp4b2 = f6dpi*1.0d-9*temp4b0/aerospc(ano3_idx)%density
          temp4b3 = f6dpi*1.0d-9*temp4b0/aerospc(acl_idx)%density
          temp4b4 = f6dpi*1.0d-9*temp4b0/aerospc(aso4_idx)%density
          cfinalb(knh4, imode) = cfinalb(knh4, imode) + temp4b1
          cinorgb(knh4, imode) = cinorgb(knh4, imode) - temp4b1
          cfinalb(kno3, imode) = cfinalb(kno3, imode) + temp4b2
          cinorgb(kno3, imode) = cinorgb(kno3, imode) - temp4b2
	    
          h2o_newb = dfh2or8*h2ob
          CALL CALC_H2O_B(wi, wib, rhi, tempi, h2o_new, h2o_newb)
          cfinalb(kcl, imode) = cfinalb(kcl, imode) + 1.0d-6*wib(5)/aerospc_mw
     +      (acl_idx) + temp4b3
          cinorgb(kcl, imode) = cinorgb(kcl, imode) - temp4b3
          wib(5) = 0.0_8
          cfinalb(kno3, imode) = cfinalb(kno3, imode) + 1.0d-6*wib(4)/
     +      aerospc_mw(ano3_idx)
          wib(4) = 0.0_8
          cfinalb(knh4, imode) = cfinalb(knh4, imode) + 1.0d-6*wib(3)/
     +      aerospc_mw(anh4_idx)
          wib(3) = 0.0_8
          so4b = so4b + 1.0d-6*wib(2)/aerospc_mw(aso4_idx) + temp4b4
          cinorgb(kso4, imode) = cinorgb(kso4, imode) - temp4b4
	    
          CALL POPREAL8(wi(5))
          CALL POPREAL8(wi(4))
          CALL POPREAL8(wi(3))
          CALL POPREAL8(wi(2))
          wib(2) = 0.0_8
          CALL POPREAL8(wi(1))
          cinorgb(kna, imode) = cinorgb(kna, imode) + 1.0d-6*wib(1)/aerospc_mw
     +      (ana_idx)
          wib(1) = 0.0_8
          cinorgb(kso4, imode) = cinorgb(kso4, imode) + so4b
          rateb = convfac*so4b
          DO isp=nvolinorg,1,-1
            CALL POPINTEGER4(branch)
            IF (branch .LT. 4) THEN
              IF (branch .LT. 3) THEN
                IF (.NOT.branch .LT. 2) THEN
                  cfinalb(isp, imode) = dmassb(isp)
                  dmassb(isp) = 0.0_8
                END IF
                GOTO 100
              END IF
            ELSE
              IF (branch .LT. 6) THEN
                IF (.NOT.branch .LT. 5) cfinalb(isp, 1) = 0.0_8
              ELSE
                cfinalb(isp, 1) = 0.0_8
              END IF
              cfinalb(isp, imode) = 0.0_8
              tmp0b = cfinalb(isp, 1)
              cfinalb(isp, 1) = tmp0b
              cfinalb(isp, imode) = cfinalb(isp, imode) + tmp0b
            END IF
		
            dmassb(isp) = dmassb(isp) + cfinalb(isp, imode)
100       cinorgb(isp, imode) = cinorgb(isp, imode) + cfinalb(isp, imode)
            omegab(imode) = omegab(imode) + df(isp)*dvolinorg(isp)*cfinalb(isp
     +        , imode)
            dvolinorgb(isp) = dvolinorgb(isp) + df(isp)*omega(imode)*cfinalb(
     +        isp, imode)
            cfinalb(isp, imode) = 0.0_8
          END DO
          temp3 = drym3/wetm3
          IF (temp3 .LE. 0.0 .AND. (d_twothirds .EQ. 0.0 .OR. d_twothirds .NE.
     +        INT(d_twothirds))) THEN
            temp3b9 = 0.0
          ELSE
            temp3b9 = wetm2*d_twothirds*temp3**(d_twothirds-1)*drym20b/wetm3
          END IF
          wetm2b = temp3**d_twothirds*drym20b
          drym3b = temp3b9
          wetm3b = drym3b - temp3*temp3b9
          CALL POPREAL8(drym3)
          aerospc_concb(ah2o_idx, imode) = aerospc_concb(ah2o_idx, imode) -
     +      h2ofac*drym3b
          m3soab = m3soab - drym3b
          DO i=n_aerospc,1,-1
            CALL POPINTEGER4(branch)
            IF (branch .LT. 4) THEN
              IF (.NOT.branch .LT. 3) aerospc_concb(i, imode) = aerospc_concb(
     +            i, imode) + f6dpi*1.0d-9*m3soab/aerospc(i)%density
            ELSE
              aerospc_concb(i, imode) = aerospc_concb(i, imode) + f6dpi*1.0d-9
     +          *m3othrb/aerospc(i)%density
            END IF
          END DO
          CALL POPINTEGER4(branch)
          IF (branch .LT. 1) THEN
            dmdt_so4b = dmdt_so4b + rateb
            condso4b(imode) = condso4b(imode) + rateb
          ELSE
            condso4b(imode) = condso4b(imode) + rateb
          END IF
          moment2_concb(imode) = moment2_concb(imode) + wetm2b
          CALL POPREAL8(wetm3)
          moment3_concb(imode) = moment3_concb(imode) + wetm3b
          aerospc_concb(acl_idx, imode) = aerospc_concb(acl_idx, imode) +
     +      cinorgb(kcl, imode)
          cinorgb(kcl, imode) = 0.0_8
          aerospc_concb(ana_idx, imode) = aerospc_concb(ana_idx, imode) +
     +      cinorgb(kna, imode)
          cinorgb(kna, imode) = 0.0_8
          aerospc_concb(ano3_idx, imode) = aerospc_concb(ano3_idx, imode) +
     +      cinorgb(kno3, imode)
          cinorgb(kno3, imode) = 0.0_8
          aerospc_concb(anh4_idx, imode) = aerospc_concb(anh4_idx, imode) +
     +      cinorgb(knh4, imode)
          cinorgb(knh4, imode) = 0.0_8
          aerospc_concb(aso4_idx, imode) = aerospc_concb(aso4_idx, imode) +
     +      cinorgb(kso4, imode)
          cinorgb(kso4, imode) = 0.0_8
        END DO
        CALL POPINTEGER4(imode)
        omegab(1) = omegab(1) - omegab(2)
        omegab(2) = 0.0_8
        temp3b7 = omegab(1)/(grfac2(1)+grfac2(2))
        temp3b8 = -(grfac2(1)*temp3b7/(grfac2(1)+grfac2(2)))
        grfac2b(1) = grfac2b(1) + temp3b8 + temp3b7
        grfac2b(2) = grfac2b(2) + temp3b8
        CALL POPINTEGER4(branch)
        IF (branch .LT. 2) THEN
          IF (branch .LT. 1) THEN
            GOTO 110
          ELSE
            dvolmaxb = 0.0_8
          END IF
        ELSE
          dvolmaxb = dvolinorgb(kcl)
          dvolinorgb(kcl) = 0.0_8
        END IF
        temp3b6 = -(dvolmaxb/df(kcl))
        aerospc_concb(acl_idx, 1) = aerospc_concb(acl_idx, 1) + temp3b6
        aerospc_concb(acl_idx, 2) = aerospc_concb(acl_idx, 2) + temp3b6
110      CALL POPINTEGER4(branch)
        IF (branch .LT. 2) THEN
          IF (branch .LT. 1) THEN
            GOTO 120
          ELSE
            dvolmaxb = 0.0_8
          END IF
        ELSE
          dvolmaxb = dvolinorgb(kno3)
          dvolinorgb(kno3) = 0.0_8
        END IF
        temp3b5 = -(dvolmaxb/df(kno3))
        aerospc_concb(ano3_idx, 1) = aerospc_concb(ano3_idx, 1) + temp3b5
        aerospc_concb(ano3_idx, 2) = aerospc_concb(ano3_idx, 2) + temp3b5
120      CALL POPINTEGER4(branch)
        IF (branch .LT. 2) THEN
          IF (branch .LT. 1) THEN
            GOTO 130
          ELSE
            dvolmaxb = 0.0_8
          END IF
        ELSE
          dvolmaxb = dvolinorgb(knh4)
          dvolinorgb(knh4) = 0.0_8
        END IF
        temp3b4 = -(dvolmaxb/df(knh4))
        aerospc_concb(anh4_idx, 1) = aerospc_concb(anh4_idx, 1) + temp3b4
        aerospc_concb(anh4_idx, 2) = aerospc_concb(anh4_idx, 2) + temp3b4
130      CALL POPINTEGER4(branch)
        IF (branch .LT. 1) THEN
          gasb = 0.0_8
          gclr8b = 1.0d-6*dvolinorgb(kcl)/DBLE(precursor_mw(hcl_idx))
          gasb(3) = -dvolinorgb(kcl)
          dvolinorgb(kcl) = 0.0_8
        ELSE
          dvolinorgb(kcl) = 0.0_8
          gasb = 0.0_8
          gclr8b = 0.0_8
        END IF
        gno3r8b = 1.0d-6*dvolinorgb(kno3)/DBLE(precursor_mw(hno3_idx))
        gasb(2) = gasb(2) - dvolinorgb(kno3)
        dvolinorgb(kno3) = 0.0_8
        gnh3r8b = 1.0d-6*dvolinorgb(knh4)/DBLE(precursor_mw(nh3_idx))
        gasb(1) = gasb(1) - dvolinorgb(knh4)
        dvolinorgb(knh4) = 0.0_8
        gasb(3) = gasb(3) + precursor_mw(hcl_idx)*1.0e6*precursor_concb(
     +    hcl_idx)
        precursor_concb(hcl_idx) = 0.0
        gasb(2) = gasb(2) + precursor_mw(hno3_idx)*1.0e6*precursor_concb(
     +    hno3_idx)
        precursor_concb(hno3_idx) = 0.0
        gasb(1) = gasb(1) + precursor_mw(nh3_idx)*1.0e6*precursor_concb(
     +    nh3_idx)
        precursor_concb(nh3_idx) = 0.0
        aerliqb = 0.0_8
	  
         CALL POPINTEGER4(branch)
	   IF (branch .EQ. 0) THEN
            CALL POPREAL8ARRAY(wi, 5)
            CALL POPREAL8ARRAY(aerliq, 12)
		
C		write(*,*) "enter isoropia_b"
C		write(*,*) "wi:", wi
C		write(*,*) "wib:", wib
C		write(*,*) "gas:", gas
C		write(*,*) "gasb:", gasb
C		write(*,*) "rhi,tempi,cntrl(2)", rhi, tempi, cntrl
C		write(*,*) "wt:", wt
C		write(*,*) "aerliq:", aerliq
C		write(*,*) "aerliqb:", aerliqb
C		write(*,*) "aersld", aersld
C		write(*,*) "scasi", scasi
C		write(*,*) "other", other
C		write(*,*) "-------------"
		CNTRL( 1 ) = 0.0D0   ! Forward Problem
            CNTRL( 2 ) = 1.0D0   ! Aerosol in Metastable State
	      CALL ISOROPIA_B(wi, wib, rhi, tempi, cntrl, wt, gas, gasb, aerliq,
     +            aerliqb, aersld, scasi, other, TrustIso)
     
C		write(*,*) "wi:", wi
C		write(*,*) "wib:", wib
C		write(*,*) "gas:", gas
C		write(*,*) "gasb:", gasb
C		write(*,*) "rhi,tempi,cntrl(2)", rhi, tempi, cntrl
C		write(*,*) "wt:", wt
C		write(*,*) "aerliq:", aerliq
C		write(*,*) "aerliqb:", aerliqb
C		write(*,*) "aersld", aersld
C		write(*,*) "scasi", scasi
C		write(*,*) "other", other
C            write(*,*) "exit isoropia_b"
C		gnh3r8b=gnh3r8b+gasb(1)*( 1.0D-6 / DBLE(PRECURSOR_MW( NH3_IDX )) )
C	      gno3r8b=gno3r8b+gasb(2)*( 1.0D-6 / DBLE(PRECURSOR_MW( HNO3_IDX )) )
C	      gclr8b=gclr8b+gasb(3)* ( 1.0D-6 / DBLE(PRECURSOR_MW( HCL_IDX )) )
         ELSE
 	      gnh3r8b=gnh3r8b+gasb(1)*( 1.0D-6 / DBLE(PRECURSOR_MW( NH3_IDX )) )
	      gno3r8b=gno3r8b+gasb(2)*( 1.0D-6 / DBLE(PRECURSOR_MW( HNO3_IDX )) )
	      gclr8b=gclr8b+gasb(3)* ( 1.0D-6 / DBLE(PRECURSOR_MW( HCL_IDX )) )
	   END IF
     
        CALL POPREAL8(wi(5))
        temp3b = 1.0d-6*wib(5)/aerospc_mw(acl_idx)
        precursor_concb(hcl_idx) = precursor_concb(hcl_idx) + 1.0d-6*wib(5)/
     +    precursor_mw(hcl_idx)
        aerospc_concb(acl_idx, 1) = aerospc_concb(acl_idx, 1) + temp3b
        aerospc_concb(acl_idx, 2) = aerospc_concb(acl_idx, 2) + temp3b
        wib(5) = 0.0_8
        CALL POPREAL8(wi(4))
        temp3b0 = 1.0d-6*wib(4)/aerospc_mw(ano3_idx)
        precursor_concb(hno3_idx) = precursor_concb(hno3_idx) + 1.0d-6*wib(4)/
     +    precursor_mw(hno3_idx)
        aerospc_concb(ano3_idx, 1) = aerospc_concb(ano3_idx, 1) + temp3b0
        aerospc_concb(ano3_idx, 2) = aerospc_concb(ano3_idx, 2) + temp3b0
        wib(4) = 0.0_8
        CALL POPREAL8(wi(3))
        temp3b1 = 1.0d-6*wib(3)/aerospc_mw(anh4_idx)
        precursor_concb(nh3_idx) = precursor_concb(nh3_idx) + 1.0d-6*wib(3)/
     +    precursor_mw(nh3_idx)
        aerospc_concb(anh4_idx, 1) = aerospc_concb(anh4_idx, 1) + temp3b1
        aerospc_concb(anh4_idx, 2) = aerospc_concb(anh4_idx, 2) + temp3b1
        wib(3) = 0.0_8
        CALL POPREAL8(wi(2))
        so4b = 1.0d-6*wib(2)/aerospc_mw(aso4_idx)
        wib(2) = 0.0_8
        CALL POPREAL8(wi(1))
        temp3b2 = 1.0d-6*wib(1)/aerospc_mw(ana_idx)
        aerospc_concb(ana_idx, 1) = aerospc_concb(ana_idx, 1) + temp3b2
        aerospc_concb(ana_idx, 2) = aerospc_concb(ana_idx, 2) + temp3b2
        wib(1) = 0.0_8
        temp3b3 = delt*h2so4ratm1*so4b
        dmdt_so4b = dmdt_so4b + temp3b3
        condso4b(1) = condso4b(1) + temp3b3
        condso4b(2) = condso4b(2) + temp3b3
        aerospc_concb(aso4_idx, 1) = aerospc_concb(aso4_idx, 1) + so4b
        aerospc_concb(aso4_idx, 2) = aerospc_concb(aso4_idx, 2) + so4b
	  
	  CALL POPREAL8(gnh3r8)
	  CALL POPREAL8(gno3r8)
	  CALL POPREAL8(gclr8)
	  
        precursor_concb(hcl_idx) = precursor_concb(hcl_idx) + gclr8b
        precursor_concb(hno3_idx) = precursor_concb(hno3_idx) + gno3r8b
        precursor_concb(nh3_idx) = precursor_concb(nh3_idx) + gnh3r8b
        CALL POPINTEGER4(branch)
        IF (branch .LT. 1) THEN
          hplusb = 0.0_8
          am1b = 0.0_8
          am2b = 0.0_8
          fconc_so4b = 0.0_8
        ELSE
          aerliqb = 0.0_8
          gasb = 0.0_8
          hplusb = 0.0_8
          am1b = 0.0_8
          am2b = 0.0_8
          fconc_so4b = 0.0_8
          CALL POPINTEGER4(ad_count)
          DO i0=1,ad_count
            CALL POPREAL4ARRAY(aeromode_diam, n_mode)
            CALL POPREAL4ARRAY(moment2_conc, n_mode)
            CALL POPREAL4ARRAY(moment3_conc, n_mode)
            CALL POPREAL4ARRAY(aeromode_sdev, n_mode)
            CALL POPREAL4ARRAY(aeromode_mass, n_mode)
            CALL GETPAR_B(m3_wet_flag, limit_sg)
            wetm2b = moment2_concb(imode)
            moment2_concb(imode) = 0.0
            CALL POPREAL4(aerospc_conc(ah2o_idx, imode))
            h2ob = aerospc_concb(ah2o_idx, imode)
            aerospc_concb(ah2o_idx, imode) = 0.0
            CALL POPREAL4(aerospc_conc(aso4_idx, imode))
            so4b = aerospc_concb(aso4_idx, imode)
            aerospc_concb(aso4_idx, imode) = 0.0
            CALL POPREAL4(aerospc_conc(acl_idx, imode))
            cfinalb(kcl, imode) = cfinalb(kcl, imode) + aerospc_concb(acl_idx
     +        , imode)
            aerospc_concb(acl_idx, imode) = 0.0
            CALL POPREAL4(aerospc_conc(ano3_idx, imode))
            cfinalb(kno3, imode) = cfinalb(kno3, imode) + aerospc_concb(
     +        ano3_idx, imode)
            aerospc_concb(ano3_idx, imode) = 0.0
            CALL POPREAL4(aerospc_conc(anh4_idx, imode))
            cfinalb(knh4, imode) = cfinalb(knh4, imode) + aerospc_concb(
     +        anh4_idx, imode)
            aerospc_concb(anh4_idx, imode) = 0.0
            gclr8b = precursor_concb(hcl_idx)
            cinorgb(kcl, imode) = cinorgb(kcl, imode) + hclrat*precursor_concb
     +        (hcl_idx)
            cfinalb(kcl, imode) = cfinalb(kcl, imode) - hclrat*precursor_concb
     +        (hcl_idx)
            precursor_concb(hcl_idx) = 0.0
            gno3r8b = precursor_concb(hno3_idx)
            cinorgb(kno3, imode) = cinorgb(kno3, imode) + hno3rat*
     +        precursor_concb(hno3_idx)
            cfinalb(kno3, imode) = cfinalb(kno3, imode) - hno3rat*
     +        precursor_concb(hno3_idx)
            precursor_concb(hno3_idx) = 0.0
            gnh3r8b = precursor_concb(nh3_idx)
            cinorgb(knh4, imode) = cinorgb(knh4, imode) + nh3rat*
     +        precursor_concb(nh3_idx)
            cfinalb(knh4, imode) = cfinalb(knh4, imode) - nh3rat*
     +        precursor_concb(nh3_idx)
            precursor_concb(nh3_idx) = 0.0
            CALL POPREAL8(wetm2)
            temp2 = wetm3/drym3
            IF (temp2 .LE. 0.0 .AND. (d_twothirds .EQ. 0.0 .OR. d_twothirds
     +          .NE. INT(d_twothirds))) THEN
              temp2b5 = 0.0
            ELSE
              temp2b5 = drym2*d_twothirds*temp2**(d_twothirds-1)*wetm2b/drym3
            END IF
            drym2b = temp2**d_twothirds*wetm2b
            wetm3b = temp2b5
            drym3b = -(temp2*temp2b5)
            CALL POPINTEGER4(branch)
            IF (branch .LT. 1) THEN
              CALL POPREAL8(drym2)
              yb = 0.0_8
            ELSE
              CALL POPREAL8(drym2)
              yb = drym2b
            END IF
            CALL POPREAL8(wetm3)
            drym3b = drym3b + wetm3b
            h2ob = h2ob + f6dpi*1.0d-9*wetm3b/aerospc(ah2o_idx)%density
            CALL POPREAL8(drym3)
            so4b = so4b + f6dpi*1.0d-9*drym3b/aerospc(aso4_idx)%density
            cfinalb(knh4, imode) = cfinalb(knh4, imode) + f6dpi*1.0d-9*drym3b/
     +        aerospc(anh4_idx)%density
            cfinalb(kno3, imode) = cfinalb(kno3, imode) + f6dpi*1.0d-9*drym3b/
     +        aerospc(ano3_idx)%density
            cfinalb(kcl, imode) = cfinalb(kcl, imode) + f6dpi*1.0d-9*drym3b/
     +        aerospc(acl_idx)%density
            cinorgb(kna, imode) = cinorgb(kna, imode) + f6dpi*1.0d-9*drym3b/
     +        aerospc(ana_idx)%density
            m3othrb = drym3b
            CALL POPINTEGER4(branch)
            IF (branch .LT. 1) THEN
              drym20 = wetm2*(drym3/wetm3)**d_twothirds
              ddrym2dt = d_twothirds*grfac1(imode)/grfac2(imode)*ddrym3dt
              loss = ddrym2dt/drym20
              lossb = drym20*EXP(tstep*loss)*tstep*yb
              drym20b = EXP(tstep*loss)*yb - ddrym2dt*lossb/drym20**2
              ddrym2dtb = lossb/drym20
            ELSE
              drym20b = yb
              ddrym2dtb = tstep*yb
            END IF
            temp2b = d_twothirds*ddrym2dtb/grfac2(imode)
            grfac1b(imode) = grfac1b(imode) + ddrym3dt*temp2b
            ddrym3dtb = grfac1(imode)*temp2b
            grfac2b(imode) = grfac2b(imode) - grfac1(imode)*ddrym3dt*temp2b/
     +        grfac2(imode)
            CALL POPREAL8(ddrym3dt)
            temp2b0 = ddrym3dtb/tstep
            temp2b1 = f6dpi*1.0d-9*temp2b0/aerospc(anh4_idx)%density
            temp2b2 = f6dpi*1.0d-9*temp2b0/aerospc(ano3_idx)%density
            temp2b3 = f6dpi*1.0d-9*temp2b0/aerospc(acl_idx)%density
            temp2b4 = f6dpi*1.0d-9*temp2b0/aerospc(aso4_idx)%density
            cfinalb(knh4, imode) = cfinalb(knh4, imode) + temp2b1
            cinorgb(knh4, imode) = cinorgb(knh4, imode) - temp2b1
            cfinalb(kno3, imode) = cfinalb(kno3, imode) + temp2b2
            cinorgb(kno3, imode) = cinorgb(kno3, imode) - temp2b2
            h2o_newb = dfh2or8*h2ob
            CALL CALC_H2O_B(wi, wib, rhi, tempi, h2o_new, h2o_newb)
            cfinalb(kcl, imode) = cfinalb(kcl, imode) + 1.0d-6*wib(5)/
     +        aerospc_mw(acl_idx) + temp2b3
            cinorgb(kcl, imode) = cinorgb(kcl, imode) - temp2b3
            wib(5) = 0.0_8
            cfinalb(kno3, imode) = cfinalb(kno3, imode) + 1.0d-6*wib(4)/
     +        aerospc_mw(ano3_idx)
            wib(4) = 0.0_8
            cfinalb(knh4, imode) = cfinalb(knh4, imode) + 1.0d-6*wib(3)/
     +        aerospc_mw(anh4_idx)
            wib(3) = 0.0_8
            so4b = so4b + 1.0d-6*wib(2)/aerospc_mw(aso4_idx) + 2.0d0*hplusb(
     +        imode)/aerospc_mw(aso4_idx) + temp2b4
            cinorgb(kso4, imode) = cinorgb(kso4, imode) - temp2b4
            CALL POPREAL8(wi(5))
            CALL POPREAL8(wi(4))
            CALL POPREAL8(wi(3))
            CALL POPREAL8(wi(2))
            wib(2) = 0.0_8
            CALL POPREAL8(wi(1))
            cinorgb(kna, imode) = cinorgb(kna, imode) + 1.0d-6*wib(1)/
     +        aerospc_mw(ana_idx) - hplusb(imode)/aerospc_mw(ana_idx)
            wib(1) = 0.0_8
            cfinalb(kno3, imode) = cfinalb(kno3, imode) + hplusb(imode)/
     +        aerospc_mw(ano3_idx)
            cfinalb(kcl, imode) = cfinalb(kcl, imode) + hplusb(imode)/
     +        aerospc_mw(acl_idx)
            cfinalb(knh4, imode) = cfinalb(knh4, imode) - hplusb(imode)/
     +        aerospc_mw(anh4_idx)
            hplusb(imode) = 0.0_8
            jb = 0.0_8
            DO isp=nvolinorg,1,-1
              CALL POPINTEGER4(branch)
              IF (branch .LT. 3) THEN
                cfinalb(isp, imode) = 0.0_8
                y1b = 0.D0
              ELSE
                y1b = cfinalb(isp, imode)
                cfinalb(isp, imode) = 0.0_8
              END IF
              cinorgb(isp, imode) = cinorgb(isp, imode) + y1b
              jb(isp) = jb(isp) + tstep*df(isp)*y1b
            END DO
            CALL POPINTEGER4(branch)
            IF (.NOT.branch .LT. 1) THEN
              gclr8b = gclr8b + jb(kcl)/(df(kcl)*tstep*hclrat)
              jb(kcl) = 0.0_8
            END IF
            CALL POPINTEGER4(branch)
            IF (.NOT.branch .LT. 1) THEN
              gno3r8b = gno3r8b + jb(kno3)/(df(kno3)*tstep*hno3rat)
              jb(kno3) = 0.0_8
            END IF
            CALL POPINTEGER4(branch)
            IF (.NOT.branch .LT. 1) THEN
              gnh3r8b = gnh3r8b + jb(knh4)/(df(knh4)*tstep*nh3rat)
              jb(knh4) = 0.0_8
            END IF
            CALL POPINTEGER4(branch)
            IF (branch .LT. 1) THEN
              CALL COMPUTE_FLUX_B(nvolinorg, gnh3r8, gnh3r8b, gno3r8, gno3r8b
     +                      , gclr8, gclr8b, knh4, kno3, kcl, gas(1:3), gasb(1
     +                      :3), grfac2(imode), grfac2b(imode), aerliq(1),
     +                      aerliqb(1), rate, rateb, j, jb)
            ELSE
              rateb = 0.0_8
            END IF
            gclr8b = gclr8b + 1.0d-6*dvolinorgb(kcl)/precursor_mw(hcl_idx)
            gasb(3) = gasb(3) - dvolinorgb(kcl)
            dvolinorgb(kcl) = 0.0_8
            gno3r8b = gno3r8b + 1.0d-6*dvolinorgb(kno3)/precursor_mw(hno3_idx)
            gasb(2) = gasb(2) - dvolinorgb(kno3)
            dvolinorgb(kno3) = 0.0_8
            gnh3r8b = gnh3r8b + 1.0d-6*dvolinorgb(knh4)/precursor_mw(nh3_idx)
            gasb(1) = gasb(1) - dvolinorgb(knh4)
            dvolinorgb(knh4) = 0.0_8
            CALL POPINTEGER4(branch)
            IF (.NOT.branch .LT. 1) THEN
		
!	  gnh3r8b=gnh3r8b+gasb(1)*( 1.0D-6 / DBLE(PRECURSOR_MW( NH3_IDX )) )
!	  gno3r8b=gno3r8b+gasb(2)*( 1.0D-6 / DBLE(PRECURSOR_MW( HNO3_IDX )) )
!	  gclr8b=gclr8b+gasb(3)* ( 1.0D-6 / DBLE(PRECURSOR_MW( HCL_IDX )) )
		  
              CALL ISOROPIA_B(wi, wib, rhi, tempi, cntrl, wt, gas, gasb,
     +                  aerliq, aerliqb, aersld, scasi, other, trustiso)
              CALL POPREAL8(wi(5))
              cinorgb(kcl, imode) = cinorgb(kcl, imode) + 1.0d-6*wib(5)/
     +          aerospc_mw(acl_idx)
              wib(5) = 0.0_8
              CALL POPREAL8(wi(4))
              cinorgb(kno3, imode) = cinorgb(kno3, imode) + 1.0d-6*wib(4)/
     +          aerospc_mw(ano3_idx)
              wib(4) = 0.0_8
              CALL POPREAL8(wi(3))
              cinorgb(knh4, imode) = cinorgb(knh4, imode) + 1.0d-6*wib(3)/
     +          aerospc_mw(anh4_idx)
              wib(3) = 0.0_8
              CALL POPREAL8(wi(2))
              so4b = so4b + 1.0d-6*wib(2)/aerospc_mw(aso4_idx)
              wib(2) = 0.0_8
              CALL POPREAL8(wi(1))
              cinorgb(kna, imode) = cinorgb(kna, imode) + 1.0d-6*wib(1)/
     +          aerospc_mw(ana_idx)
              wib(1) = 0.0_8
              aerliqb = 0.0_8
              gasb = 0.0_8
            END IF
            cinorgb(kso4, imode) = cinorgb(kso4, imode) + so4b
            rateb = rateb + tstep*h2so4ratm1*so4b
            condso4b(imode) = condso4b(imode) + rateb
            precursor_concb(hcl_idx) = precursor_concb(hcl_idx) + gclr8b
            precursor_concb(nh3_idx) = precursor_concb(nh3_idx) + gnh3r8b
            precursor_concb(hno3_idx) = precursor_concb(hno3_idx) + gno3r8b
            temp1 = drym3/wetm3
            IF (temp1 .LE. 0.0 .AND. (d_twothirds .EQ. 0.0 .OR. d_twothirds
     +          .NE. INT(d_twothirds))) THEN
              temp1b = 0.0
            ELSE
              temp1b = wetm2*d_twothirds*temp1**(d_twothirds-1)*drym20b/wetm3
            END IF
            wetm2b = temp1**d_twothirds*drym20b
            drym3b = temp1b
            wetm3b = drym3b - temp1*temp1b
            CALL POPREAL8(drym3)
            aerospc_concb(ah2o_idx, imode) = aerospc_concb(ah2o_idx, imode) -
     +        h2ofac*drym3b
            moment2_concb(imode) = moment2_concb(imode) + wetm2b
            CALL POPREAL8(wetm3)
            moment3_concb(imode) = moment3_concb(imode) + wetm3b
            aerospc_concb(asoil_idx, imode) = aerospc_concb(asoil_idx, imode)
     +        + soilfac*m3othrb
            aerospc_concb(acors_idx, imode) = aerospc_concb(acors_idx, imode)
     +        + anthfac*m3othrb
            hplusb(imode) = hplusb(imode) + cinorgb(khp, imode)
            cinorgb(khp, imode) = 0.0_8
            aerospc_concb(ana_idx, imode) = aerospc_concb(ana_idx, imode) +
     +        cinorgb(kna, imode)
            cinorgb(kna, imode) = 0.0_8
            aerospc_concb(aso4_idx, imode) = aerospc_concb(aso4_idx, imode) +
     +        cinorgb(kso4, imode)
            cinorgb(kso4, imode) = 0.0_8
            aerospc_concb(acl_idx, imode) = aerospc_concb(acl_idx, imode) +
     +        cinorgb(kcl, imode)
            cinorgb(kcl, imode) = 0.0_8
            aerospc_concb(ano3_idx, imode) = aerospc_concb(ano3_idx, imode) +
     +        cinorgb(kno3, imode)
            cinorgb(kno3, imode) = 0.0_8
            aerospc_concb(anh4_idx, imode) = aerospc_concb(anh4_idx, imode) +
     +        cinorgb(knh4, imode)
            cinorgb(knh4, imode) = 0.0_8
            CALL POPINTEGER4(branch)
            IF (.NOT.branch .LT. 1) THEN
              CALL POPREAL8(grfac2(3))
              fconc_so4b(3, 2) = fconc_so4b(3, 2) + grfac2b(3)
              grfac2b(3) = 0.0_8
              CALL POPREAL8(grfac1(3))
              fconc_so4b(3, 1) = fconc_so4b(3, 1) + grfac1b(3)
              grfac1b(3) = 0.0_8
              CALL POPREAL8ARRAY(fconc_so4(3, :), 2)
!              CALL HCOND3_B(am0(3), am0b(3), am1(3), am1b(3), am2(3), am2b(3)
!     +                , dv_so4, alphsulf, cbar_so4, fconc_so4(3, :),
!     +                fconc_so4b(3, :))
              CALL HCOND3_ADJ(am0(3), am0b(3), am1(3), am1b(3), am2(3), am2b(3)
     +                , dv_so4, alphsulf, cbar_so4, fconc_so4(3, :),
     +                fconc_so4b(3, :))
              CALL POPREAL8(am2(3))
              moment2_concb(3) = moment2_concb(3) + am2b(3)
              am2b(3) = 0.0_8
              CALL POPREAL8(am1(3))
              temp0 = 0.5*aeromode_sdev(3)**2
              temp0b = EXP(temp0)*am1b(3)
              moment0_concb(3) = moment0_concb(3) + am0b(3) + aeromode_diam(3)
     +          *temp0b
              aeromode_diamb(3) = aeromode_diamb(3) + moment0_conc(3)*temp0b
              aeromode_sdevb(3) = aeromode_sdevb(3) + moment0_conc(3)*
     +          aeromode_diam(3)*EXP(temp0)*0.5*2*aeromode_sdev(3)*am1b(3)
              am1b(3) = 0.0_8
              CALL POPREAL8(am0(3))
              am0b(3) = 0.0_8
            END IF
            CALL POPINTEGER4(branch)
            IF (.NOT.branch .LT. 1) CALL POPREAL8(tstep)
          END DO
        END IF
        CALL POPINTEGER4(branch)
        IF (branch .LT. 1) THEN
          scondrateb = condso4b(3)
          condso4b(1) = condso4b(1) - condso4b(3)
          condso4b(2) = condso4b(2) - condso4b(3)
          condso4b(3) = 0.0_8
          omega_ac_so4b = scondrate*condso4b(2)
          scondrateb = scondrateb + omega_ac_so4*condso4b(2)
          condso4b(2) = 0.0_8
        ELSE
          condso4b(3) = 0.0_8
          scondrateb = condso4b(2)
          condso4b(1) = condso4b(1) - condso4b(2)
          condso4b(2) = 0.0_8
          omega_ac_so4b = 0.0_8
        END IF
        omega_at_so4b = scondrate*condso4b(1)
        scondrateb = scondrateb + omega_at_so4*condso4b(1)
        fconcm1_so4b = fconc_so4(1, 2)*omega_at_so4b + fconc_so4(2, 2)*
     +    omega_ac_so4b
        fconc_so4b(2, 2) = fconc_so4b(2, 2) + fconcm1_so4*omega_ac_so4b
        fconc_so4b(1, 2) = fconc_so4b(1, 2) + fconcm1_so4*omega_at_so4b
        tmpb = -(fconcm1_so4b/tmp**2)
        DO i=n_mode,1,-1
          fconc_so4b(i, 2) = fconc_so4b(i, 2) + tmpb
        END DO
        CALL POPREAL8(tmp)
        CALL POPINTEGER4(branch)
        IF (branch .LT. 2) THEN
          IF (branch .LT. 1) THEN
            so4rateb = 0.0
            GOTO 140
          ELSE
            so4rateb = scondrateb
            dmdt_so4b = dmdt_so4b - scondrateb
          END IF
        ELSE
          so4rateb = 0.0
        END IF
!        CALL NEWPART3_B(airrh, airtemp, xh2so4, xh2so4b, so4rate, so4rateb,
!     +            dndt, dndtb, dmdt_so4, dmdt_so4b, dm2dt)
        CALL NEWPART3_ADJ(airrh, airtemp, xh2so4, xh2so4b, so4rate, so4rateb,
     +            dndt, dndtb, dmdt_so4, dmdt_so4b, dm2dt, dm2dtb )
        xh2so4b = xh2so4b + precursor_concb(sulf_idx)
        precursor_concb(sulf_idx) = 0.0
        CALL POPINTEGER4(branch)
        IF (.NOT.branch .LT. 1) xh2so4b = 0.0
        so4rateb = so4rateb + xh2so4b/tmp
        tmpb = -(so4rate*xh2so4b/tmp**2)
        DO i=n_mode,1,-1
          fconc_so4b(i, 2) = fconc_so4b(i, 2) + tmpb
        END DO
140      CONTINUE
        DO i=n_mode,1,-1
          fconc_so4b(i, 2) = fconc_so4b(i, 2) + grfac2b(i)
          grfac2b(i) = 0.0_8
          fconc_so4b(i, 1) = fconc_so4b(i, 1) + grfac1b(i)
          grfac1b(i) = 0.0_8
        END DO
        CALL POPINTEGER4(branch)
        IF (.NOT.branch .LT. 1) THEN
          fconc_so4b(n_mode, 2) = 0.0_8
          fconc_so4b(n_mode, 1) = 0.0_8
        END IF
        DO i=n_mode,1,-1
          CALL HCOND3_B(am0(i), am0b(i), am1(i), am1b(i), am2(i), am2b(i),
     +            dv_so4, alphsulf, cbar_so4, fconc_so4(i, :), fconc_so4b(i, :
     +            ))
        END DO
        DO i=n_mode,1,-1
          moment2_concb(i) = moment2_concb(i) + am2b(i)
          am2b(i) = 0.0_8
          temp = 0.5*aeromode_sdev(i)**2
          tempb = EXP(temp)*am1b(i)
          moment0_concb(i) = moment0_concb(i) + am0b(i) + aeromode_diam(i)*
     +      tempb
          aeromode_diamb(i) = aeromode_diamb(i) + moment0_conc(i)*tempb
          aeromode_sdevb(i) = aeromode_sdevb(i) + moment0_conc(i)*
     +      aeromode_diam(i)*EXP(temp)*0.5*2*aeromode_sdev(i)*am1b(i)
          am1b(i) = 0.0_8
          am0b(i) = 0.0_8
        END DO
        DO i=n_mode,1,-1
          DO n=n_aerospc,1,-1
            aerospc_concb(n, i) = aerospc_concb(n, i) + aerospc(n)%charge*
     +        hplusb(i)/aerospc_mw(n)
          END DO
        END DO

        hclratb = 0.0_8
        hno3ratb = 0.0_8
        nh3ratb = 0.0_8
        anthfacb = 0.0_8
        soilfacb = 0.0_8
        dfh2or8b = 0.0_8
        dfb = 0.0_8
        h2so4ratm1b = 0.0_8
        cofcbar_so4b = 0.0
!
!199  FORMAT('Step      Mode    NH3      HNO3       HCL   ',
!    &           '    NH4       NO3        CL       H2O   ')
!200  FORMAT (1x, I3, 1x,' Mode ', 1x, I2,1x, 7F10.6)
2023      FORMAT(1x,
     +         'VOLINORG returning negative gas concentrations from ISOROPIA:'
     +         /10x,'GAS(1) = NH3, GAS(2) = HNO3, GAS(3) = HCl')
2029      FORMAT(1x,'[see VOLINORG msg]'1x,'at (C,R,L): ',3i4,1x,'GAS Conc:'
     +         ,3(1pe11.3))
      END SUBROUTINE VOLINORG_B

!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.4 (r3376) - 10 Feb 2010 17:51
!
!  Differentiation of hcond3 in reverse (adjoint) mode:
!   gradient     of useful results: f am0 am1 am2
!   with respect to varying inputs: f am0 am1 am2
!
! /////////////////////////////////////////////////////////////////////
!  SUBROUTINE HCOND3 calculates the size-dependent term in the
!   condensational-growth rate expression for the 2nd and 3rd moments of
!   a lognormal aerosol mode using the harmonic mean method.  This code
!   follows Section A2 of Binkowski & Shankar (1995).
!
!  KEY SUBROUTINES/FUNCTIONS CALLED:  none
!
!  REVISION HISTORY:
!     coded November 7, 2003 by Dr. Francis S. Binkowski
!
!     Revised November 20, 2003 by F. Binkowski to have am1 and
!     am2 as inputs
!
!  REFERENCE:
!   1. Binkowski, F.S. and U. Shankar, The regional particulate matter
!      model 1. Model description and preliminary results, J. Geophys.
!      Res., Vol 100, No D12, 26101-26209, 1995.
!
      SUBROUTINE HCOND3_B(am0, am0b, am1, am1b, am2, am2b, dv, alpha, cbar, f
     +  , fb)
        IMPLICIT NONE
!
! *** Arguments:
!
! zeroth moment of mode  [ #/m**3 ]
        REAL*8, INTENT(IN) :: am0
        REAL*8 :: am0b
! first moment of mode   [ m/m**3 ]
        REAL*8, INTENT(IN) :: am1
        REAL*8 :: am1b
! second moment of mode  [ m**2/m**3 ]
        REAL*8, INTENT(IN) :: am2
        REAL*8 :: am2b
! molecular diffusivity of the
! condensing vapor  [ m**2/s ]
        REAL, INTENT(IN) :: dv
! accommodation coefficient
        REAL, INTENT(IN) :: alpha
! kinetic velocity of condensing vapor [ m/s ]
        REAL, INTENT(IN) :: cbar
!
! size-dependent term in condensational-growth
! rate: F(1) = 2nd moment [ m**2/m**3 s ]
!       F(2) = 3rd moment [ m**3/m**3 s ]
        REAL*8 :: f(2)
        REAL*8 :: fb(2)
!
! *** Local Variables:
!
! integrals used to calculate F(1) [m^2 / m^3 s]
        REAL*8 :: gnc2
        REAL*8 :: gnc2b
!
        REAL*8 :: gfm2
        REAL*8 :: gfm2b
!
! integrals used to calculate F(2) [m^3 / m^3 s]
        REAL*8 :: gnc3
        REAL*8 :: gnc3b
!
        REAL*8 :: gfm3
        REAL*8 :: gfm3b
!
        REAL*8, PARAMETER :: pi=3.14159265358979324d0
        REAL*8, PARAMETER :: twopi=2.0d0*pi
        REAL*8, PARAMETER :: pi4=0.25d0*pi
        REAL*8 :: tempb2
        REAL*8 :: tempb1
        REAL*8 :: tempb0
        REAL*8 :: tempb
!
! *** start execution
!
! *** Implement equation A15 of Binkowski & Shankar (1995) for the
!     2nd and 3rd moments of a lognormal mode of arbitrary size.
!
! 2nd moment, near-continuum
        gnc2 = twopi*dv*am0
! 3rd moment, near-continuum
        gnc3 = twopi*dv*am1
! 2nd moment, free-molecular
        gfm2 = pi4*alpha*cbar*am1
! 3rd moment, free-molecular
        gfm3 = pi4*alpha*cbar*am2
!
! *** Implement equation A13 of Binkowski & Shankar (1995) for a
!     lognormal mode of arbitrary size.  These are the size-dependent
!     terms in the condensational-growth rate expression, given in
!     equation 7a of B&S (1995).
!
! 2nd moment
! 3rd moment
!
        tempb = fb(2)/(gnc3+gfm3)
        tempb0 = -(gnc3*gfm3*tempb/(gnc3+gfm3))
        gnc3b = tempb0 + gfm3*tempb
        gfm3b = tempb0 + gnc3*tempb
        fb(2) = 0.0_8
        tempb1 = fb(1)/(gnc2+gfm2)
        tempb2 = -(gnc2*gfm2*tempb1/(gnc2+gfm2))
        gnc2b = tempb2 + gfm2*tempb1
        gfm2b = tempb2 + gnc2*tempb1
        fb(1) = 0.0_8
        am2b = am2b + pi4*alpha*cbar*gfm3b
        am1b = am1b + twopi*dv*gnc3b + pi4*alpha*cbar*gfm2b
        am0b = am0b + twopi*dv*gnc2b
      END SUBROUTINE HCOND3_B

!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.4 (r3376) - 10 Feb 2010 17:51
!
!  Differentiation of newpart3 in reverse (adjoint) mode:
!   gradient     of useful results: dndt so4rate dmdt_so4
!   with respect to varying inputs: so4rate xh2so4
!
! /////////////////////////////////////////////////////////////////////
!  SUBROUTINE NEWPART3 calculates the new particle production rate
!    due to binary nucleation of H2SO4 and H2O vapor.  The nucleation
!    rate is a parameterized function of temperature, relative humidity,
!    and the vapor-phase H2SO4 concentration, following the work of
!    Kulmala et al (1998).  This rate is then used to determine the
!    production rates of aerosol number, 2nd moment, and aerosol
!    sulfate, following the description in Section 1.2 of Binkowski
!    Roselle (2003), except the new particles are assumed to be of 2.0
!    nm diameter instead of 3.5 nm.
!
!  KEY SUBROUTINES/FUNCTIONS CALLED: none
!
!  REVISION HISTORY:
!
! FSB 11/29/99 Extracted code from PARTPROD_VA subroutine of RPM
!
! SJR ??/??/?? New call vector and limited the mass production rate
!
! FSB 04/11/02 Decreased the diameter of new particles from 3.5 nm to
!     2 nm.  New particles are monodispersed.
!
! PVB 09/21/04 Changed MWH2SO4 from 98.07354 to 98.0 g/mol for
!     consistency with the mechanism files.  Added in-line documentation
!     with input from FSB.
!
!  REFERENCES:
!   1. Kulmala, M., A. Laaksonen, and L. Pirjola, Parameterizations for
!      sulfuric acid/water nucleation rates.  J. Geophys. Res., Vol 103,
!      No D7, 8301-8307, 1998.
!
!   2. Binkowski, F.S. and S.J. Roselle, Models-3 Community
!      Multiscale Air Quality (CMAQ) model aerosol component 1:
!      Model Description.  J. Geophys. Res., Vol 108, No D6, 4183
!      doi:10.1029/2001JD001409, 2003.
!
      SUBROUTINE NEWPART3_B(rh, temp, xh2so4, xh2so4b, so4rate, so4rateb, dndt
     +  , dndtb, dmdt_so4, dmdt_so4b, dm2dt)
        USE AERO_DATA_B
        USE MET_DATA
        IMPLICIT NONE
!
!
!
!
! *** Arguments:
!
! fractional relative humidity
        REAL, INTENT(IN) :: rh
! ambient temperature [ K ]
        REAL, INTENT(IN) :: temp
! sulfuric acid concentration [ ug/m**3 ]
        REAL, INTENT(IN) :: xh2so4
        REAL :: xh2so4b
! gas-phase H2SO4 production rate [ ug/m**3 s ]
        REAL, INTENT(IN) :: so4rate
        REAL :: so4rateb
!
! particle number production rate [ m^-3/s ]
        REAL*8 :: dndt
        REAL*8 :: dndtb
! SO4 mass production rate [ ug/m**3 s ]
        REAL*8 :: dmdt_so4
        REAL*8 :: dmdt_so4b
! second moment production rate [ m**2/m**3 s ]
        REAL*8 :: dm2dt
!
! *** Parameters
!
        CHARACTER(len=16), PARAMETER :: pname='NEWPART_b'
!
! *** Conversion Factors:
!
! molecular weight for H2SO4
        REAL, PARAMETER :: mwh2so4=98.0
!
! micrograms/m**3 to number/cm**3
        REAL, PARAMETER :: ugm3_ncm3=avo/mwh2so4*1.0e-12
!
! *** Particle size parameters:
!
! diameter of a new particle [cm]
        REAL, PARAMETER :: d20=2.0e-07
!
! new-particle diameter squared [cm**2]
        REAL, PARAMETER :: d20sq=d20*d20
!
! new-particle diameter squared [m**2]
        REAL, PARAMETER :: m2_20=1.0e-4*d20sq
!
! volume of a new particle [cm**3]
        REAL, PARAMETER :: v20=pi6*d20*d20sq
!
! mass of a new particle [ug]
        REAL*8 :: sulfmass
! inverse of sulfmass [ug**-1]
        REAL*8 :: sulfmass1
!
! *** Local Variables used to determine nucleation rate
!
! water vapor concentration [ 1/cm**3 ]
        REAL :: nwv
! saturation vapor conc of H2SO4 [ 1/cm**3 ]
        REAL :: nav0
! H2SO4 vapor concentration [ 1/cm**3 ]
        REAL :: nav
        REAL :: navb
! critical H2SO4 vapor concentration [ 1/cm**3 ]
        REAL :: nac
! fractional relative acidity
        REAL :: ra
        REAL :: rab
! temperature-correction term
        REAL :: delta
! H2SO4 mole fraction in the critical nucleus
        REAL :: xal
        REAL :: xalb
! see usage
        REAL :: nsulf
        REAL :: nsulfb
! factor to calculate Jnuc
        REAL*8 :: chi
        REAL*8 :: chib
! nucleation rate [ cm ** -3  s ** -1 ]
! (Kulmala et al.)
        REAL*8 :: jnuck
        REAL*8 :: jnuckb
! dummy variable for statement functions
        REAL :: tt
!
! *** Statement Functions
!
! arithmetic statement functions for saturation
! vapor pressures of h2so4 and h2o [Pa] taken
! from Appendix of Kulmala et al. (1998), p8306
        REAL :: ph2so4, ph2o
        INTRINSIC EXP
        REAL :: temp0b
        INTRINSIC LOG
!
! -------------------------- Begin Execution ---------------------------
!
! *** Initialize variables
!
        sulfmass = 1.0d+3*aerospc(aso4_idx)%density*v20
        sulfmass1 = 1.0d0/sulfmass
!
! *** Nucleation Rate
!     Calculate the sulfuric acid/water nucleation rate.  This code
!     implements Section 3 of Kulmala et al. (1998).  Note that all
!     variables in the Kulmala parameterization are in cgs units.
!
! *** Calculate water vapor concentration [1/cm**3] using ambient RH
!     and the formula in Appendix of Kulmala et al. (1998), p8306.
        nwv = rh*EXP(77.34491296-7235.424651/temp-8.2*LOG(temp)+temp*
     +    5.7113e-03)/(rgasuniv*temp)*avo*1.0e-6
!
! *** Calculate saturation vapor concentration of H2SO4 [1/cm**3]
!       using formula in the Appendix of Kulmala et al. (1998), p8306.
        nav0 = EXP(27.78492066-10156.0/temp)/(rgasuniv*temp)*avo*1.0e-6
!
! *** Convert ambient H2SO4 vapor concentration into [1/cm**3] units
        nav = ugm3_ncm3*xh2so4
!
! *** Calculate critical concentration of H2SO4 vapor needed to produce
!     1 particle/(cm**3 s) using Equation 18 of Kulmala et al (1998)
        nac = EXP(-14.5125 + 0.1335*temp - 10.5462*rh + 1958.4*rh/temp)
!
! *** Calculate relative acidity, defined as the ambient concentration
!     divided by the saturation concentration of H2SO4 vapor
        ra = nav/nav0
!
! *** Calculate temperature correction factor using Equation 22 of
!      Kulmala et al (1998)
        delta = 1.0 + (temp-273.15)/273.15
!
! *** Calculate mole fraction of H2SO4 in the critical nucleus using
!     Equation 17 of Kulmala et al (1998)
        xal = 1.2233 - 0.0154*ra/(ra+rh) + 0.0102*LOG(nav) - 0.0415*LOG(nwv) +
     +    0.0016*temp
!
! *** Calculate Nsulf as defined in Equation 21 of Kulmala et al (1998)
        nsulf = LOG(nav/nac)
!
! *** Calculate natural log of nucleation rate using Equation 20 of
!     Kulmala et al (1998)
        chi = 25.1289*nsulf - 4890.8*nsulf/temp - 1743.3/temp - 2.2479*delta*
     +    nsulf*rh + 7643.4*xal/temp - 1.9712*xal*delta/rh
!
! *** Calculate nucleation rate using Eq 19 of Kulmala et al (1998)
! [ #/cm**3 s ]
        jnuck = EXP(chi)
!
! *** Moment Production Rates
!     Calculate the production rate of number, sulfate mass, and 2nd
!     moment, due to the H2SO4/H2O nucleation assuming that each critical
!     nucleus grows instantaneously to 2.0 nm.  This code follows Section
!     1.2 of Binkowski & Roselle (2003), except the assumed particle
!     diameter has been changed from 3.5 to 2.0 nm.
!
! *** Convert production rate of number to [ #/m**3 s]
        dndt = 1.0e06*jnuck
!
! *** Calculate mass production rate [ ug / (m**3 s) ] analogous to
!     Equation 6a of Binkowski & Roselle (2003).  Set the upper limit
!     of the mass production rate as the gas-phase production rate of
!     H2SO4, and adjust the number production rate accordingly.
        dmdt_so4 = sulfmass*dndt
        IF (dmdt_so4 .GT. so4rate) THEN
          dmdt_so4b = dmdt_so4b + sulfmass1*dndtb
          so4rateb = so4rateb + dmdt_so4b
          dndtb = 0.0_8
          dmdt_so4b = 0.0_8
        END IF
        dndtb = dndtb + sulfmass*dmdt_so4b
        jnuckb = 1.0e06*dndtb
        chib = EXP(chi)*jnuckb
        nsulfb = (25.1289-4890.8/temp-delta*2.2479*rh)*chib
        xalb = (7643.4/temp-delta*1.9712/rh)*chib
        temp0b = -(0.0154*xalb/(rh+ra))
        rab = (1.0-ra/(rh+ra))*temp0b
        navb = 0.0102*xalb/nav + rab/nav0 + nsulfb/nav
        xh2so4b = ugm3_ncm3*navb
      END SUBROUTINE NEWPART3_B

C        Generated by TAPENADE     (INRIA, Tropics team)
C  Tapenade 3.4 (r3376) - 10 Feb 2010 17:51
C
C  Differentiation of compute_flux in reverse (adjoint) mode:
C   gradient     of useful results: j hplus condrate gnh3r8 gclr8
C                gno3r8 ceq
C   with respect to varying inputs: j hplus condrate gnh3r8 gclr8
C                gno3r8 ceq rate
C
C-----------------------------------------------------------------------
C ROUTINE
C   Compute_Flux
C DESCRIPTION
C   Determines the evaporative/condensational flux of volatile
C   inorganic species to aerosol modes. In cases where the resulting H+
C   flux is greater than a specified limit, the Pilinis et al. (2000)
C   AS&T approach is used to modify species vapor pressures such that
C   cond./evap. produces an H+ flux equal to the limit (which is
C   proportional to the current mode concentration of H+).
C   Routine called by VOLINORG.
C ARGUMENTS
C   INPUTS
C     nvolinorg: Number of Volatile inorganic species
C     GNH3R8   : NH3(g) concentration (ug/m3)
C     GNO3R8   : HNO3(g) concentration (ug/m3)
C     GCLR8    : HCl(g) concentration (ug/m3)
C     KNH4     : Index to NH4 species
C     KNO3     : Index to NO3 species
C     KCL      : Index to NO3 species
C     Ceq      : vapor concentration (mol/m3)
C     CondRate : effective condensation rate (I) of 3rd moment to mode
C              : [treat units as (1/s)]
C     Hplus    : aerosol hydrogen ion concentration (mol/m3) for mode
C     rate     : H2SO4(g) condensation rate (ug/m3/s) for mode
C   OUTPUT
C     Ceq      : modified vapor concentration (mol/m3)
C     J        : molar cond./evap. flux of volatile inorganics (mol/m3-s)
C-----------------------------------------------------------------------
C      SUBROUTINE Compute_Flux ( nvolinorg, GNH3R8, GNO3R8, GCLR8, KNH4,
C     &                          KNO3, KCL, Ceq, CondRate, Hplus, rate, J )
C
C
C      IMPLICIT NONE
C
CC   INPUTS
CC     GNH3R8   : NH3(g) concentration (ug/m3)
CC     GNO3R8   : HNO3(g) concentration (ug/m3)
CC     GCLR8    : HCl(g) concentration (ug/m3)
CC     KNH4     : Index to NH4 species
CC     KNO3     : Index to NO3 species
CC     KCL      : Index to NO3 species
CC     Ceq      : vapor concentration (mol/m3)
CC     CondRate : effective condensation rate (I) of 3rd moment to mode
CC              : [treat units as (1/s)]
CC     Hplus    : aerosol hydrogen ion concentration (mol/m3) for mode
CC     rate     : H2SO4(g) condensation rate (ug/m3/s) for mode
C
CC   OUTPUT
CC     Ceq      : modified vapor concentration (mol/m3)
CC     J        : molar cond./evap. flux of volatile inorganics (mol/m3-s)
C
CC     Arguments:
C      INTEGER      nvolinorg
C      REAL( 8 ) :: GNH3R8, GNO3R8, GCLR8 ! gas concentrations [ug/m3]
C      INTEGER      KNH4, KNO3, KCL       ! Indices to species
C      REAL( 8 ) :: Ceq( nvolinorg )      ! vapor concentrations [mol/m3]
C      REAL( 8 ) :: CondRate              ! effective condensation rate (I) for 3rd moment
C      REAL( 8 ) :: Hplus                 ! hydrogen ion concentration for mode [mol/m3]
C      REAL( 8 ) :: rate
C      REAL( 8 ) :: J( nvolinorg )        ! molar cond./evap. flux [mol/m3-s]
C
C      J( : ) = GNH3R8 + GNO3R8 + GCLR8 + CondRate + Hplus + rate
C
C
C      END SUBROUTINE Compute_Flux
      SUBROUTINE COMPUTE_FLUX_B(nvolinorg, gnh3r8, gnh3r8b, gno3r8,
     +                           gno3r8b, gclr8, gclr8b, knh4, kno3, kcl
     +                           , ceq, ceqb, condrate, condrateb, hplus
     +                           , hplusb, rate, rateb, j, jb)
      USE AERO_DATA_B
      USE MET_DATA
      USE PRECURSOR_DATA_B
      IMPLICIT NONE
C
C
C
C     Arguments:
      INTEGER nvolinorg
C gas concentrations [ug/m3]
      REAL*8 gnh3r8, gno3r8, gclr8
      REAL*8 gnh3r8b, gno3r8b, gclr8b
C Indices to species
      INTEGER knh4, kno3, kcl
C vapor concentrations [mol/m3]
      REAL*8 ceq(nvolinorg)
      REAL*8 ceqb(nvolinorg)
C effective condensation rate (I) for 3rd moment
      REAL*8 condrate
      REAL*8 condrateb
C hydrogen ion concentration for mode [mol/m3]
      REAL*8 hplus
      REAL*8 hplusb
      REAL*8 rate
      REAL*8 rateb
C molar cond./evap. flux [mol/m3-s]
      REAL*8 j(nvolinorg)
      REAL*8 jb(nvolinorg)
C
C     Local Variables:
C factor for H+ limiter
      REAL*8, PARAMETER :: afact=1.0d-01
      REAL*8, PARAMETER :: small=1.0d-25
C gas concentration in mol/m3
      REAL*8 cinf(nvolinorg)
      REAL*8 cinfb(nvolinorg)
C factor for modifying vapor press. based on H+ limit
      REAL*8 qk
      REAL*8 qkb
C flux of H+ to mode from cond/evap
      REAL*8 hflux
C maximum allowable H+ flux to mode
      REAL*8 hlim
      REAL*8 hlimb
C terms in quadratic equation
      REAL*8 aa, bb, cc
      REAL*8 aab, bbb, ccb
C molar flux of H2SO4(g) [mol/m3/s]
      REAL*8 jh2so4
      REAL*8 jh2so4b
C effective H2SO4(g) concentration [mol/m3]
      REAL*8 ch2so4
      REAL*8 ch2so4b
C inorganic species index
      INTEGER isp
      INTEGER branch
      REAL*8 temp0
      INTRINSIC SIGN
      INTRINSIC ABS
      REAL*8 tempb
      REAL*8 abs1
      REAL*8 temp1b
      INTRINSIC SQRT
      REAL*8 temp
C
C     ---------------
C     Begin Execution
C     ---------------
C
C     Convert gas concentration from ug/m3 to mol/m3
      cinf(knh4) = gnh3r8*1.0d-6/precursor_mw(nh3_idx)
      cinf(kno3) = gno3r8*1.0d-6/precursor_mw(hno3_idx)
      cinf(kcl) = gclr8*1.0d-6/precursor_mw(hcl_idx)
C
C     Calculate cond/evap fluxes (no H+ limiting)
      DO isp=1,nvolinorg
        j(isp) = condrate*(cinf(isp)-ceq(isp))
      ENDDO
C
C     Convert rate to mol/m3/s and get effective Cinf for H2SO4(g)
      jh2so4 = rate*1.0d-6/precursor_mw(sulprd_idx)
      ch2so4 = jh2so4/condrate
C
C     Limit H+ flux (Pilinis et al., 2000, AS&T). Note: J is flux
C     to entire mode, not one particle
      hlim = afact*hplus
      hflux = 2.0d0*jh2so4 + j(kno3) + j(kcl) - j(knh4)
      IF (hflux .GE. 0.) THEN
        abs1 = hflux
      ELSE
        abs1 = -hflux
      END IF
C |Hflux| > Hlim
C
C     If Hflux is too large, limit the flux by modifying species
C     vapor pressures with Qk factor (Pilinis et al., 2000, AS&T).
      IF (abs1 .GT. hlim) THEN
        CALL PUSHREAL8(hlim)
        hlim = SIGN(hlim, hflux)
C
C        Solve quadratic for Qk: aa*Qk^2 + bb*Qk + cc = 0
        aa = ceq(kcl) + ceq(kno3)
C
        bb = hlim/condrate + cinf(knh4) - cinf(kno3) - cinf(kcl) - 2.0d0
     +    *ch2so4
        cc = -ceq(knh4)
C
C initialize Qk
C
        IF (aa .LT. small .AND. 0.0d0 .LT. bb) THEN
C bb*Qk + cc = 0
          qk = -(cc/bb)
          CALL PUSHINTEGER4(0)
        ELSE IF (aa .LT. small .AND. bb .LE. 0.0d0) THEN
          qk = 0.0d0
          CALL PUSHINTEGER4(1)
        ELSE IF (-cc .LT. small .AND. bb .LT. 0.0d0) THEN
C aa*Qk^2 + bb*Qk = 0
          qk = -(bb/aa)
          CALL PUSHINTEGER4(2)
        ELSE IF (-cc .LT. small .AND. 0.0d0 .LE. bb) THEN
          qk = 0.0d0
          CALL PUSHINTEGER4(3)
        ELSE
          qk = (-bb+SQRT(bb**2-4.0d0*aa*cc))/(2.0d0*aa)
          IF (bb**2 - 4.0d0*aa*cc .LT. 0.0d0) THEN
            qk = 0.0d0
            CALL PUSHINTEGER4(5)
          ELSE
            CALL PUSHINTEGER4(4)
          END IF
        END IF
C
C     Modify vapor pressures and get new fluxes
        IF (qk .GT. small) THEN
          CALL PUSHREAL8(ceq(knh4))
          ceq(knh4) = ceq(knh4)/qk
          CALL PUSHREAL8(ceq(kno3))
          ceq(kno3) = ceq(kno3)*qk
          CALL PUSHREAL8(ceq(kcl))
          ceq(kcl) = ceq(kcl)*qk
          cinfb = 0.0
          DO isp=nvolinorg,1,-1
            condrateb = condrateb + (cinf(isp)-ceq(isp))*jb(isp)
            cinfb(isp) = cinfb(isp) + condrate*jb(isp)
            ceqb(isp) = ceqb(isp) - condrate*jb(isp)
            jb(isp) = 0.0
          ENDDO
          CALL POPREAL8(ceq(kcl))
          qkb = ceq(kcl)*ceqb(kcl)
          ceqb(kcl) = qk*ceqb(kcl)
          CALL POPREAL8(ceq(kno3))
          qkb = qkb + ceq(kno3)*ceqb(kno3)
          ceqb(kno3) = qk*ceqb(kno3)
          CALL POPREAL8(ceq(knh4))
          qkb = qkb - ceq(knh4)*ceqb(knh4)/qk**2
          ceqb(knh4) = ceqb(knh4)/qk
        ELSE
          qkb = 0.0
          cinfb = 0.0
        END IF
        CALL POPINTEGER4(branch)
        IF (branch .LT. 3) THEN
          IF (branch .LT. 2) THEN
            IF (branch .LT. 1) THEN
              ccb = -(qkb/bb)
              bbb = cc*qkb/bb**2
              aab = 0.0
            ELSE
              aab = 0.0
              bbb = 0.0
              ccb = 0.0
            END IF
          ELSE
            bbb = -(qkb/aa)
            aab = bb*qkb/aa**2
            ccb = 0.0
          END IF
        ELSE
          IF (branch .LT. 5) THEN
            IF (branch .LT. 4) THEN
              aab = 0.0
              bbb = 0.0
              ccb = 0.0
              GOTO 100
            END IF
          ELSE
            qkb = 0.0
          END IF
          temp1b = qkb/(2.0d0*aa)
          temp = bb**2 - 4.0d0*aa*cc
          temp0 = SQRT(temp)
          IF (temp .EQ. 0.0) THEN
            tempb = 0.0
          ELSE
            tempb = temp1b/(2.0*temp0)
          END IF
          bbb = 2*bb*tempb - temp1b
          aab = -((temp0-bb)*temp1b/aa) - 4.0d0*cc*tempb
          ccb = -(4.0d0*aa*tempb)
        END IF
 100    ceqb(knh4) = ceqb(knh4) - ccb
        hlimb = bbb/condrate
        condrateb = condrateb - hlim*bbb/condrate**2
        cinfb(knh4) = cinfb(knh4) + bbb
        cinfb(kno3) = cinfb(kno3) - bbb
        cinfb(kcl) = cinfb(kcl) - bbb
        ch2so4b = -(2.0d0*bbb)
        ceqb(kcl) = ceqb(kcl) + aab
        ceqb(kno3) = ceqb(kno3) + aab
        CALL POPREAL8(hlim)
        hlimb = SIGN(1.d0, hlim*hflux)*hlimb
      ELSE
        hlimb = 0.0
        cinfb = 0.0
        ch2so4b = 0.0
      END IF
      hplusb = hplusb + afact*hlimb
      jh2so4b = ch2so4b/condrate
      condrateb = condrateb - jh2so4*ch2so4b/condrate**2
      rateb = 1.0d-6*jh2so4b/precursor_mw(sulprd_idx)
      DO isp=nvolinorg,1,-1
        condrateb = condrateb + (cinf(isp)-ceq(isp))*jb(isp)
        cinfb(isp) = cinfb(isp) + condrate*jb(isp)
        ceqb(isp) = ceqb(isp) - condrate*jb(isp)
        jb(isp) = 0.0
      ENDDO
      gclr8b = gclr8b + 1.0d-6*cinfb(kcl)/precursor_mw(hcl_idx)
      cinfb(kcl) = 0.0
      gno3r8b = gno3r8b + 1.0d-6*cinfb(kno3)/precursor_mw(hno3_idx)
      cinfb(kno3) = 0.0
      gnh3r8b = gnh3r8b + 1.0d-6*cinfb(knh4)/precursor_mw(nh3_idx)
	
      END SUBROUTINE

!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.4 (r3376) - 10 Feb 2010 17:51
!
!  Differentiation of calc_h2o in reverse (adjoint) mode:
!   gradient     of useful results: wi h2o_new
!   with respect to varying inputs: wi
!
!-----------------------------------------------------------------------
! Routine CALC_H2O
! Description
!   Calculate the water content of aerosol at the new time step.  Water
!   calculations use the ZSR mixing rule with salts determined by the
!   ISORROPIA approach.
!   Routine called by VOLINORG.
! Arguments
!   Input
!     WI      : Concentration of components [mol/m^3] at new step
!     RH      : Relative humidity [0-1]
!     T       : Temperature [K]
!   Output
!     H2O_NEW : Water [mol/m^3] content at new time step
!-----------------------------------------------------------------------
!
      SUBROUTINE CALC_H2O_B(wi, wib, rh, t, h2o_new, h2o_newb)
        IMPLICIT NONE
!
!
        INTEGER, PARAMETER :: ncmp=5
!     Arguments:
        REAL*8, INTENT(IN) :: wi(ncmp)
        REAL*8 :: wib(ncmp)
        REAL*8, INTENT(IN) :: rh, t
        REAL*8 :: h2o_new
        REAL*8 :: h2o_newb
!
!     Parameters:
        INTEGER, PARAMETER :: npair=13
        REAL*8, PARAMETER :: small=1.0d-20
! molar mass H2O (kg/mol)
        REAL*8, PARAMETER :: mw=0.018d0
!
!     Local Variables:
! "free" ion amounts
        REAL*8 :: fso4, fnh4, fna, fno3, fcl
        REAL*8 :: fso4b, fnh4b, fnab, fno3b, fclb
! kg of water for new time step
        REAL*8 :: water
        REAL*8 :: waterb
        REAL*8 :: x, y
        REAL*8 :: xb, yb
! concentration (mol/m^3)
        REAL*8 :: conc(ncmp)
        REAL*8 :: concb(ncmp)
! concentration (mol/m^3) ion "pairs"
        REAL*8 :: concr(npair)
        REAL*8 :: concrb(npair)
! single-solute molalities
        REAL*8 :: m0i(npair)
        INTEGER :: j
! sub-case for composition
        CHARACTER(len=2) :: sc
        INTEGER :: branch
        REAL*8 :: min1
        INTRINSIC MAX
        REAL*8 :: min1b
        REAL*8 :: x2
        REAL*8 :: x1
        REAL*8 :: x2b
        REAL*8 :: x1b
        INTRINSIC MIN
        INTEGER :: ii1
!
!     ---------------
!     Begin Execution
!     ---------------
!
!     Return if small concentration
        IF (.NOT.wi(1) + wi(2) + wi(3) + wi(4) + wi(5) .LE. small) THEN
!
!     Set component array (mol/m^3) for determining salts
! array assignment
          conc = wi
          CALL PUSHREAL8ARRAY(conc, 5)
!
!     Get the sub-case to use in determining salts
          CALL GETSC(conc, rh, t, sc)
!
!     Initialize ion "pairs" (i.e., salts) used in ZSR
! array assignment
          concr = 0.0d0
!
!     Depending on case, determine moles of salts in solution (i.e., CONCR)
!     for ZSR calculation below
!
          IF (sc .EQ. 'K2') THEN
            IF (conc(2) .GT. 0.5d0*conc(3)) THEN
              concr(4) = 0.5d0*conc(3)
              CALL PUSHINTEGER4(1)
            ELSE
              concr(4) = conc(2)
              CALL PUSHINTEGER4(0)
            END IF
          ELSE IF (sc .EQ. 'L4' .OR. sc .EQ. 'O4') THEN
! sulfate rich (no acid)
! 2SO4 - NH4
            x = 2.0d0*conc(2) - conc(3)
! NH4 - SO4
            y = conc(3) - conc(2)
            IF (x .LE. y) THEN
! (NH4)3H(SO4)2 is MIN (X,Y)
              concr(13) = x
! (NH4)2SO4
              concr(4) = y - x
              CALL PUSHINTEGER4(2)
            ELSE
! (NH4)3H(SO4)2 is MIN (X,Y)
              concr(13) = y
! NH4HSO4
              concr(9) = x - y
              CALL PUSHINTEGER4(3)
            END IF
          ELSE IF (sc .EQ. 'M2' .OR. sc .EQ. 'P2') THEN
!
! sulfate rich (free acid)
! NH4HSO4
            concr(9) = conc(3)
            IF (conc(2) - conc(3) .LT. 0.0d0) THEN
              concr(7) = 0.0d0
              CALL PUSHINTEGER4(5)
            ELSE
              concr(7) = conc(2) - conc(3)
              CALL PUSHINTEGER4(4)
            END IF
          ELSE IF (sc .EQ. 'N3') THEN
            IF (conc(2) .GT. 0.5d0*conc(3)) THEN
              concr(4) = 0.5d0*conc(3)
              CALL PUSHINTEGER4(1)
            ELSE
              concr(4) = conc(2)
              CALL PUSHINTEGER4(0)
            END IF
            IF (conc(3) - 2.0d0*concr(4) .LT. 0.0d0) THEN
              CALL PUSHINTEGER4(0)
              fnh4 = 0.0d0
            ELSE
              fnh4 = conc(3) - 2.0d0*concr(4)
              CALL PUSHINTEGER4(1)
            END IF
            IF (fnh4 .GT. conc(4)) THEN
              x1 = conc(4)
              CALL PUSHINTEGER4(1)
            ELSE
              x1 = fnh4
              CALL PUSHINTEGER4(0)
            END IF
            IF (x1 .LT. 0.0d0) THEN
              concr(5) = 0.0d0
              CALL PUSHINTEGER4(6)
            ELSE
              concr(5) = x1
              CALL PUSHINTEGER4(7)
            END IF
          ELSE IF (sc .EQ. 'Q5') THEN
! sulfate poor, sodium poor (NH4-SO4-NO3-Cl-Na)
! Na2SO4
            concr(2) = 0.5d0*conc(1)
            IF (conc(2) - concr(2) .LT. 0.0d0) THEN
              CALL PUSHINTEGER4(0)
              fso4 = 0.0d0
            ELSE
              fso4 = conc(2) - concr(2)
              CALL PUSHINTEGER4(1)
            END IF
            IF (fso4 .GT. 0.5d0*conc(3)) THEN
              x2 = 0.5d0*conc(3)
              CALL PUSHINTEGER4(1)
            ELSE
              x2 = fso4
              CALL PUSHINTEGER4(0)
            END IF
            IF (x2 .LT. small) THEN
              concr(4) = small
              CALL PUSHINTEGER4(0)
            ELSE
              concr(4) = x2
              CALL PUSHINTEGER4(1)
            END IF
            IF (conc(3) - 2.0d0*concr(4) .LT. 0.0d0) THEN
              CALL PUSHINTEGER4(0)
              fnh4 = 0.0d0
            ELSE
              fnh4 = conc(3) - 2.0d0*concr(4)
              CALL PUSHINTEGER4(1)
            END IF
            IF (fnh4 .GT. conc(4)) THEN
              concr(5) = conc(4)
              CALL PUSHINTEGER4(1)
            ELSE
              concr(5) = fnh4
              CALL PUSHINTEGER4(0)
            END IF
            IF (fnh4 - concr(5) .LT. 0.0d0) THEN
              fnh4 = 0.0d0
              CALL PUSHINTEGER4(1)
            ELSE
              fnh4 = fnh4 - concr(5)
              CALL PUSHINTEGER4(0)
            END IF
            IF (fnh4 .GT. conc(5)) THEN
              concr(6) = conc(5)
              CALL PUSHINTEGER4(9)
            ELSE
              concr(6) = fnh4
              CALL PUSHINTEGER4(8)
            END IF
          ELSE IF (sc .EQ. 'R6') THEN
! sulfate poor, sodium rich (NH4-SO4-NO3-Cl-Na)
! Na2SO4
            concr(2) = conc(2)
            IF (conc(1) - 2.0d0*concr(2) .LT. 0.0d0) THEN
              CALL PUSHINTEGER4(0)
              fna = 0.0d0
            ELSE
              fna = conc(1) - 2.0d0*concr(2)
              CALL PUSHINTEGER4(1)
            END IF
            IF (fna .GT. conc(4)) THEN
              concr(3) = conc(4)
              CALL PUSHINTEGER4(1)
            ELSE
              concr(3) = fna
              CALL PUSHINTEGER4(0)
            END IF
            IF (conc(4) - concr(3) .LT. 0.0d0) THEN
              CALL PUSHINTEGER4(0)
              fno3 = 0.0d0
            ELSE
              fno3 = conc(4) - concr(3)
              CALL PUSHINTEGER4(1)
            END IF
            IF (fna - concr(3) .LT. 0.0d0) THEN
              fna = 0.0d0
              CALL PUSHINTEGER4(1)
            ELSE
              fna = fna - concr(3)
              CALL PUSHINTEGER4(0)
            END IF
            IF (fna .GT. conc(5)) THEN
              concr(1) = conc(5)
              CALL PUSHINTEGER4(1)
            ELSE
              concr(1) = fna
              CALL PUSHINTEGER4(0)
            END IF
            IF (conc(5) - concr(1) .LT. 0.0d0) THEN
              CALL PUSHINTEGER4(0)
              fcl = 0.0d0
            ELSE
              fcl = conc(5) - concr(1)
              CALL PUSHINTEGER4(1)
            END IF
            IF (fno3 .GT. conc(3)) THEN
              concr(5) = conc(3)
              CALL PUSHINTEGER4(1)
            ELSE
              concr(5) = fno3
              CALL PUSHINTEGER4(0)
            END IF
            IF (conc(3) - concr(5) .LT. 0.0d0) THEN
              fnh4 = 0.0d0
              CALL PUSHINTEGER4(1)
            ELSE
              fnh4 = conc(3) - concr(5)
              CALL PUSHINTEGER4(0)
            END IF
            IF (fcl .GT. fnh4) THEN
              concr(6) = fnh4
              CALL PUSHINTEGER4(11)
            ELSE
              concr(6) = fcl
              CALL PUSHINTEGER4(10)
            END IF
          ELSE IF (sc .EQ. 'S6') THEN
! sulfate rich (no acid) (NH4-SO4-NO3-Cl-Na)
! Na2SO4
            concr(2) = 0.5d0*conc(1)
            IF (conc(2) - concr(2) .LT. 0.0d0) THEN
              CALL PUSHINTEGER4(0)
              fso4 = 0.0d0
            ELSE
              fso4 = conc(2) - concr(2)
              CALL PUSHINTEGER4(1)
            END IF
            IF (conc(3)/3.0d0 .GT. fso4/2.0d0) THEN
              concr(13) = fso4/2.0d0
              CALL PUSHINTEGER4(1)
            ELSE
              concr(13) = conc(3)/3.0d0
              CALL PUSHINTEGER4(0)
            END IF
            IF (fso4 - 2.0d0*concr(13) .LT. 0.0d0) THEN
              fso4 = 0.0d0
              CALL PUSHINTEGER4(1)
            ELSE
              fso4 = fso4 - 2.0d0*concr(13)
              CALL PUSHINTEGER4(0)
            END IF
            IF (conc(3) - 3.0d0*concr(13) .LT. 0.0d0) THEN
              fnh4 = 0.0d0
              CALL PUSHINTEGER4(1)
            ELSE
              fnh4 = conc(3) - 3.0d0*concr(13)
              CALL PUSHINTEGER4(0)
            END IF
!
            IF (fso4 .LE. small) THEN
              IF (concr(13) - fnh4 .LT. 0.0d0) THEN
                concr(13) = 0.0d0
                CALL PUSHINTEGER4(1)
              ELSE
                concr(13) = concr(13) - fnh4
                CALL PUSHINTEGER4(0)
              END IF
! (NH4)2SO4
              concr(4) = 2.0d0*fnh4
              CALL PUSHINTEGER4(16)
            ELSE IF (fnh4 .LE. small) THEN
              IF (fso4 .GT. concr(13)) THEN
                min1 = concr(13)
                CALL PUSHINTEGER4(1)
              ELSE
                min1 = fso4
                CALL PUSHINTEGER4(0)
              END IF
! reduce (NH4)3H(SO4)2, add NH4HSO4
! NH4HSO4
              concr(9) = 3.0d0*min1
              IF (concr(13) - fso4 .LT. 0.0d0) THEN
                concr(13) = 0.0d0
                CALL PUSHINTEGER4(1)
              ELSE
                concr(13) = concr(13) - fso4
                CALL PUSHINTEGER4(0)
              END IF
              IF (concr(2) .GT. small) THEN
                IF (fso4 - concr(9)/3.0d0 .LT. 0.0d0) THEN
                  fso4 = 0.0d0
                  CALL PUSHINTEGER4(1)
                ELSE
                  fso4 = fso4 - concr(9)/3.0d0
                  CALL PUSHINTEGER4(0)
                END IF
! NaHSO4
                concr(12) = 2.0d0*fso4
                IF (concr(2) - fso4 .LT. 0.0d0) THEN
                  concr(2) = 0.0d0
                  CALL PUSHINTEGER4(15)
                ELSE
                  concr(2) = concr(2) - fso4
                  CALL PUSHINTEGER4(14)
                END IF
              ELSE
                CALL PUSHINTEGER4(13)
              END IF
            ELSE
              CALL PUSHINTEGER4(12)
            END IF
          ELSE IF (sc .EQ. 'T3') THEN
!
! sulfate rich (free acid) (NH4-SO4-NO3-Cl-Na)
! NH4HSO4
            concr(9) = conc(3)
! NAHSO4
            concr(12) = conc(1)
            IF (conc(2) - conc(3) - conc(1) .LT. 0.0d0) THEN
              concr(7) = 0.0d0
              CALL PUSHINTEGER4(18)
            ELSE
              concr(7) = conc(2) - conc(3) - conc(1)
              CALL PUSHINTEGER4(17)
            END IF
          ELSE
            CALL PUSHINTEGER4(19)
          END IF
!
!     Get single-solute molalities for ZSR calculation
!slz          CALL GETM0I (M0I)
           CALL GETM0I (RH, M0I)
C          CALL GETM0I_M0I ( RH,T,M0I )
!
!     Calculate H2O with ZSR and determine delta water
          water = 0.0d0
          DO j=1,npair
            water = water + concr(j)/m0i(j)
          END DO
          IF (water .LT. small) THEN
            CALL PUSHINTEGER4(1)
          ELSE
            CALL PUSHINTEGER4(0)
          END IF
          waterb = h2o_newb/mw
          CALL POPINTEGER4(branch)
          IF (.NOT.branch .LT. 1) waterb = 0.0_8
          DO ii1=1,npair
            concrb(ii1) = 0.0_8
          END DO
          DO j=npair,1,-1
            concrb(j) = concrb(j) + waterb/m0i(j)
          END DO
          CALL POPINTEGER4(branch)
          IF (branch .LT. 10) THEN
            IF (branch .LT. 5) THEN
              IF (branch .LT. 3) THEN
                IF (branch .LT. 2) THEN
                  IF (branch .LT. 1) THEN
                    DO ii1=1,ncmp
                      concb(ii1) = 0.0_8
                    END DO
                    concb(2) = concrb(4)
                  ELSE
                    DO ii1=1,ncmp
                      concb(ii1) = 0.0_8
                    END DO
                    concb(3) = 0.5d0*concrb(4)
                  END IF
                  GOTO 150
                ELSE
                  yb = concrb(4)
                  xb = -concrb(4)
                  concrb(4) = 0.0_8
                  xb = xb + concrb(13)
                END IF
              ELSE IF (branch .LT. 4) THEN
                xb = concrb(9)
                yb = -concrb(9)
                concrb(9) = 0.0_8
                yb = yb + concrb(13)
              ELSE
                DO ii1=1,ncmp
                  concb(ii1) = 0.0_8
                END DO
                concb(2) = concrb(7)
                concb(3) = -concrb(7)
                concrb(7) = 0.0_8
                GOTO 100
              END IF
              DO ii1=1,ncmp
                concb(ii1) = 0.0_8
              END DO
              concb(3) = yb
              concb(2) = 2.0d0*xb - yb
              concb(3) = concb(3) - xb
            ELSE IF (branch .LT. 8) THEN
              IF (branch .LT. 7) THEN
                IF (branch .LT. 6) THEN
                  concrb(7) = 0.0_8
                  DO ii1=1,ncmp
                    concb(ii1) = 0.0_8
                  END DO
                  GOTO 100
                ELSE
                  concrb(5) = 0.0_8
                  x1b = 0.0_8
                END IF
              ELSE
                x1b = concrb(5)
                concrb(5) = 0.0_8
              END IF
              CALL POPINTEGER4(branch)
              IF (branch .LT. 1) THEN
                fnh4b = x1b
                DO ii1=1,ncmp
                  concb(ii1) = 0.0_8
                END DO
              ELSE
                DO ii1=1,ncmp
                  concb(ii1) = 0.0_8
                END DO
                concb(4) = x1b
                fnh4b = 0.0_8
              END IF
              CALL POPINTEGER4(branch)
              IF (.NOT.branch .LT. 1) THEN
                concb(3) = concb(3) + fnh4b
                concrb(4) = concrb(4) - 2.0d0*fnh4b
              END IF
              CALL POPINTEGER4(branch)
              IF (branch .LT. 1) THEN
                concb(2) = concb(2) + concrb(4)
              ELSE
                concb(3) = concb(3) + 0.5d0*concrb(4)
              END IF
            ELSE
              IF (branch .LT. 9) THEN
                fnh4b = concrb(6)
                concrb(6) = 0.0_8
                DO ii1=1,ncmp
                  concb(ii1) = 0.0_8
                END DO
              ELSE
                DO ii1=1,ncmp
                  concb(ii1) = 0.0_8
                END DO
                concb(5) = concrb(6)
                concrb(6) = 0.0_8
                fnh4b = 0.0_8
              END IF
              CALL POPINTEGER4(branch)
              IF (branch .LT. 1) THEN
                concrb(5) = concrb(5) - fnh4b
              ELSE
                fnh4b = 0.0_8
              END IF
              CALL POPINTEGER4(branch)
              IF (branch .LT. 1) THEN
                fnh4b = fnh4b + concrb(5)
                concrb(5) = 0.0_8
              ELSE
                concb(4) = concb(4) + concrb(5)
                concrb(5) = 0.0_8
              END IF
              CALL POPINTEGER4(branch)
              IF (.NOT.branch .LT. 1) THEN
                concb(3) = concb(3) + fnh4b
                concrb(4) = concrb(4) - 2.0d0*fnh4b
              END IF
              CALL POPINTEGER4(branch)
              IF (branch .LT. 1) THEN
                concrb(4) = 0.0_8
                x2b = 0.0_8
              ELSE
                x2b = concrb(4)
                concrb(4) = 0.0_8
              END IF
              CALL POPINTEGER4(branch)
              IF (branch .LT. 1) THEN
                fso4b = x2b
              ELSE
                concb(3) = concb(3) + 0.5d0*x2b
                fso4b = 0.0_8
              END IF
              CALL POPINTEGER4(branch)
              IF (.NOT.branch .LT. 1) THEN
                concb(2) = concb(2) + fso4b
                concrb(2) = concrb(2) - fso4b
              END IF
              concb(1) = concb(1) + 0.5d0*concrb(2)
            END IF
            GOTO 150
100       concb(3) = concb(3) + concrb(9)
          ELSE
            IF (branch .LT. 15) THEN
              IF (branch .LT. 13) THEN
                IF (branch .LT. 12) THEN
                  IF (branch .LT. 11) THEN
                    fclb = concrb(6)
                    concrb(6) = 0.0_8
                    fnh4b = 0.0_8
                  ELSE
                    fnh4b = concrb(6)
                    concrb(6) = 0.0_8
                    fclb = 0.0_8
                  END IF
                  CALL POPINTEGER4(branch)
                  IF (branch .LT. 1) THEN
                    DO ii1=1,ncmp
                      concb(ii1) = 0.0_8
                    END DO
                    concb(3) = fnh4b
                    concrb(5) = concrb(5) - fnh4b
                  ELSE
                    DO ii1=1,ncmp
                      concb(ii1) = 0.0_8
                    END DO
                  END IF
                  CALL POPINTEGER4(branch)
                  IF (branch .LT. 1) THEN
                    fno3b = concrb(5)
                    concrb(5) = 0.0_8
                  ELSE
                    concb(3) = concb(3) + concrb(5)
                    concrb(5) = 0.0_8
                    fno3b = 0.0_8
                  END IF
                  CALL POPINTEGER4(branch)
                  IF (.NOT.branch .LT. 1) THEN
                    concb(5) = concb(5) + fclb
                    concrb(1) = concrb(1) - fclb
                  END IF
                  CALL POPINTEGER4(branch)
                  IF (branch .LT. 1) THEN
                    fnab = concrb(1)
                    concrb(1) = 0.0_8
                  ELSE
                    concb(5) = concb(5) + concrb(1)
                    concrb(1) = 0.0_8
                    fnab = 0.0_8
                  END IF
                  CALL POPINTEGER4(branch)
                  IF (branch .LT. 1) THEN
                    concrb(3) = concrb(3) - fnab
                  ELSE
                    fnab = 0.0_8
                  END IF
                  CALL POPINTEGER4(branch)
                  IF (.NOT.branch .LT. 1) THEN
                    concb(4) = concb(4) + fno3b
                    concrb(3) = concrb(3) - fno3b
                  END IF
                  CALL POPINTEGER4(branch)
                  IF (branch .LT. 1) THEN
                    fnab = fnab + concrb(3)
                    concrb(3) = 0.0_8
                  ELSE
                    concb(4) = concb(4) + concrb(3)
                    concrb(3) = 0.0_8
                  END IF
                  CALL POPINTEGER4(branch)
                  IF (.NOT.branch .LT. 1) THEN
                    concb(1) = concb(1) + fnab
                    concrb(2) = concrb(2) - 2.0d0*fnab
                  END IF
                  concb(2) = concb(2) + concrb(2)
                  GOTO 150
                ELSE
                  fso4b = 0.0_8
                  GOTO 130
                END IF
              ELSE IF (branch .LT. 14) THEN
                fso4b = 0.0_8
                GOTO 120
              ELSE
                fso4b = -concrb(2)
              END IF
            ELSE
              IF (branch .LT. 18) THEN
                IF (branch .LT. 17) THEN
                  IF (branch .LT. 16) THEN
                    concrb(2) = 0.0_8
                    fso4b = 0.0_8
                    GOTO 110
                  ELSE
                    fnh4b = 2.0d0*concrb(4)
                    concrb(4) = 0.0_8
                    CALL POPINTEGER4(branch)
                    IF (branch .LT. 1) THEN
                      fnh4b = fnh4b - concrb(13)
                    ELSE
                      concrb(13) = 0.0_8
                    END IF
                    fso4b = 0.0_8
                    GOTO 140
                  END IF
                ELSE
                  DO ii1=1,ncmp
                    concb(ii1) = 0.0_8
                  END DO
                  concb(2) = concrb(7)
                  concb(3) = -concrb(7)
                  concb(1) = -concrb(7)
                  concrb(7) = 0.0_8
                END IF
              ELSE IF (branch .LT. 19) THEN
                concrb(7) = 0.0_8
                DO ii1=1,ncmp
                  concb(ii1) = 0.0_8
                END DO
              ELSE
                DO ii1=1,ncmp
                  concb(ii1) = 0.0_8
                END DO
                GOTO 150
              END IF
              concb(1) = concb(1) + concrb(12)
              concrb(12) = 0.0_8
              concb(3) = concb(3) + concrb(9)
              GOTO 150
            END IF
110       fso4b = fso4b + 2.0d0*concrb(12)
            concrb(12) = 0.0_8
            CALL POPINTEGER4(branch)
            IF (branch .LT. 1) THEN
              concrb(9) = concrb(9) - fso4b/3.0d0
            ELSE
              fso4b = 0.0_8
            END IF
120       CALL POPINTEGER4(branch)
            IF (branch .LT. 1) THEN
              fso4b = fso4b - concrb(13)
            ELSE
              concrb(13) = 0.0_8
            END IF
            min1b = 3.0d0*concrb(9)
            concrb(9) = 0.0_8
            CALL POPINTEGER4(branch)
            IF (branch .LT. 1) THEN
              fso4b = fso4b + min1b
            ELSE
              concrb(13) = concrb(13) + min1b
            END IF
130       fnh4b = 0.0_8
140       CALL POPINTEGER4(branch)
            IF (branch .LT. 1) THEN
              DO ii1=1,ncmp
                concb(ii1) = 0.0_8
              END DO
              concb(3) = fnh4b
              concrb(13) = concrb(13) - 3.0d0*fnh4b
            ELSE
              DO ii1=1,ncmp
                concb(ii1) = 0.0_8
              END DO
            END IF
            CALL POPINTEGER4(branch)
            IF (branch .LT. 1) THEN
              concrb(13) = concrb(13) - 2.0d0*fso4b
            ELSE
              fso4b = 0.0_8
            END IF
            CALL POPINTEGER4(branch)
            IF (branch .LT. 1) THEN
              concb(3) = concb(3) + concrb(13)/3.0d0
              concrb(13) = 0.0_8
            ELSE
              fso4b = fso4b + concrb(13)/2.0d0
              concrb(13) = 0.0_8
            END IF
            CALL POPINTEGER4(branch)
            IF (.NOT.branch .LT. 1) THEN
              concb(2) = concb(2) + fso4b
              concrb(2) = concrb(2) - fso4b
            END IF
            concb(1) = concb(1) + 0.5d0*concrb(2)
          END IF
150      CALL POPREAL8ARRAY(conc, 5)
          CALL GETSC_B(conc, concb, rh, t, sc)
          wib = wib + concb
        END IF
      END SUBROUTINE CALC_H2O_B

!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.4 (r3376) - 10 Feb 2010 17:51
!
!  Differentiation of getsc in reverse (adjoint) mode:
!   gradient     of useful results: conc
!   with respect to varying inputs: conc
!
!-----------------------------------------------------------------------
! ROUTINE GETSC
! Description
!   Determines the sub-case to use for water uptake calculations.
!   Follows the procedure of ISORROPIA.
!   Routine called by CALC_H2O.
! ArgumentS
!   Inputs
!     CONC : Concentration [mol/m^3] of aerosol components. This routine
!            sets minimum CONC to 1.0D-20
!     RH   : Relative humidity
!     T    : Temperature (K)
!   Output
!     SC   : Sub-case for aerosol composition
!-----------------------------------------------------------------------
!
      SUBROUTINE GETSC_B(conc, concb, rh, t, sc)
        IMPLICIT NONE
!
!
!
!     Parameters:
! number of aerosol components
        INTEGER, PARAMETER :: ncmp=5
        REAL*8, PARAMETER :: small=1.0d-20
!
!     Arguments:
        REAL*8, INTENT(INOUT) :: conc(ncmp)
        REAL*8 :: concb(ncmp)
        REAL*8, INTENT(IN) :: rh, t
        CHARACTER(len=2) :: sc
!
!     Local Variables:
! DRH(T) factor
        REAL*8 :: t0, tcf
! sulfate & sodium ratios
        REAL*8 :: s4rat, s4ratw, narat, sri
! "free" sulfate
        REAL*8 :: fso4
! DRH values
        REAL*8 :: dnacl, dnh4cl, dnano3, dnh4no3, dnh42s4
!
! ISORROPIA function for sulfate ratio
        REAL*8 :: GETASR
!
! concentration regime
        LOGICAL :: nh4s4, nh4s4n3, allsp
!
!     ---------------
!     Begin Execution
!     ---------------
!
! NH4-SO4
! NH4-SO4-NO3
! all species
!
!     See if any components are negligible
        INTRINSIC EXP
        INTRINSIC MAX
        REAL*8 :: x1
        INTRINSIC INT
        INTRINSIC MIN
        INTEGER :: ii1
        LOGICAL :: mask(5)
        mask(:) = conc(:) .LT. small
        WHERE (mask(:))
            concb = 0.0_8
        END WHERE
      END SUBROUTINE GETSC_B

!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.4 (r3376) - 10 Feb 2010 17:51
!
!  Differentiation of getaf in reverse (adjoint) mode:
!   gradient     of useful results: ni nj getaf xlsgi xlsgj dgni
!                dgnj
!   with respect to varying inputs: ni nj xlsgi xlsgj dgni dgnj
!
! //////////////////////////////////////////////////////////////////
!  FUNCTION GETAF returns the value of "Xnum" in Equations 10a and 10c
!   of Binkowski and Roselle (2003), given the number concentrations,
!   median diameters, and natural logs of the geometric standard
!   deviations, in two lognormal modes.  The value returned by GETAF
!   is used subsequently in the mode merging calculations:
!         GETAF = ln( Dij / Dgi ) / ( SQRT2 * ln(Sgi) )
!   where Dij is the diameter of intersection,
!         Dgi is the median diameter of the smaller size mode, and
!         Sgi is the geometric standard deviation of smaller mode.
!   A quadratic equation is solved to obtain GETAF, following the
!   method of Press et al.
!
!  REFERENCES:
!   1. Binkowski, F.S. and S.J. Roselle, Models-3 Community
!      Multiscale Air Quality (CMAQ) model aerosol component 1:
!      Model Description.  J. Geophys. Res., Vol 108, No D6, 4183
!      doi:10.1029/2001JD001409, 2003.
!   2. Press, W.H., S.A. Teukolsky, W.T. Vetterling, and B.P.
!      Flannery, Numerical Recipes in Fortran 77 - 2nd Edition.
!      Cambridge University Press, 1992.
!
      SUBROUTINE GETAF_B(ni, nib, nj, njb, dgni, dgnib, dgnj, dgnjb, xlsgi,
     +  xlsgib, xlsgj, xlsgjb, sqrt2, getafb)
        IMPLICIT NONE
!
        REAL :: ni, nj, dgni, dgnj, xlsgi, xlsgj, sqrt2
        REAL :: nib, njb, dgnib, dgnjb, xlsgib, xlsgjb
        REAL :: aa, bb, cc, disc, qq, alfa, l, yji
        REAL :: aab, bbb, ccb, discb, qqb, alfab, lb, yjib
        REAL :: getafb
        REAL :: getaf
        REAL :: temp1
        REAL :: temp0
        REAL :: temp0b
        INTRINSIC SIGN
        REAL :: tempb
        REAL :: temp0b0
        INTRINSIC LOG
        REAL :: temp1b
        INTRINSIC SQRT
        REAL :: temp
!
! *** Store intermediate values used for the quadratic solution
!     to reduce computational burden
        alfa = xlsgi/xlsgj
        yji = LOG(dgnj/dgni)/(sqrt2*xlsgi)
        l = LOG(alfa*nj/ni)
!
! *** Calculate quadratic equation coefficients & discriminant
        aa = 1.0 - alfa*alfa
        bb = 2.0*yji*alfa*alfa
        cc = l - yji*yji*alfa*alfa
        disc = bb*bb - 4.0*aa*cc
!
! *** If roots are imaginary, return a negative GETAF value so that no
!     mode merging takes place.
        IF (disc .LT. 0.0) THEN
          bbb = 0.0
          ccb = 0.0
          discb = 0.0
        ELSE
!
! *** Equation 5.6.4 of Press et al.
          qq = -(0.5*(bb+SIGN(1.0, bb)*SQRT(disc)))
!
! *** Return solution of the quadratic equation that corresponds to a
!     diameter of intersection lying between the median diameters of
!     the 2 modes.
! See Equation 5.6.5 of Press et al.
!
          ccb = getafb/qq
          qqb = -(cc*getafb/qq**2)
          temp1 = SQRT(disc)
          temp1b = -(0.5*qqb)
          bbb = temp1b
          IF (disc .EQ. 0.0) THEN
            discb = 0.0
          ELSE
            discb = SIGN(1.0, bb)*temp1b/(2.0*temp1)
          END IF
        END IF
        bbb = bbb + 2*bb*discb
        aab = -(4.0*cc*discb)
        ccb = ccb - 4.0*aa*discb
        lb = ccb
        yjib = 2.0*alfa**2*bbb - alfa**2*2*yji*ccb
        temp0 = alfa*nj/ni
        temp0b = lb/(temp0*ni)
        alfab = 2.0*yji*2*alfa*bbb + nj*temp0b - 2*alfa*aab - yji**2*2*alfa*
     +    ccb
        njb = njb + alfa*temp0b
        nib = nib - temp0*temp0b
        temp0b0 = yjib/(sqrt2*xlsgi)
        temp = dgnj/dgni
        tempb = temp0b0/(temp*dgni)
        dgnjb = dgnjb + tempb
        dgnib = dgnib - temp*tempb
        xlsgib = xlsgib + alfab/xlsgj - LOG(temp)*temp0b0/xlsgi
        xlsgjb = xlsgjb - xlsgi*alfab/xlsgj**2
      END SUBROUTINE GETAF_B

CCCCCC*CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.4 (r3376) - 10 Feb 2010 17:51
!
!  Differentiation of erf in reverse (adjoint) mode:
!   gradient     of useful results: xx erf
!   with respect to varying inputs: xx
      SUBROUTINE ERF_B(xx, xxb, erfb)
        IMPLICIT NONE
        REAL :: xx
        REAL :: xxb
        REAL*8,parameter :: PI = 3.14159265358979324    
        REAL :: erfb
        REAL :: erf
        REAL*8 :: temp1
        REAL*8 :: temp0
        INTRINSIC EXP
        INTRINSIC SIGN
        INTRINSIC SQRT
        REAL*8 :: temp
        temp1 = -(4.0*xx**2/pi)
        temp0 = -EXP(temp1) + 1.0
        temp = SQRT(temp0)
        IF (.NOT.temp0 .EQ. 0.0) xxb = xxb + SIGN(1.0, xx)*EXP(temp1)*4.0*2*xx
     +      *erfb/(2.0*temp*pi)
      END SUBROUTINE ERF_B

CCCCCC*CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.4 (r3376) - 10 Feb 2010 17:51
!
!  Differentiation of erfc in reverse (adjoint) mode:
!   gradient     of useful results: erfc xx
!   with respect to varying inputs: xx
      SUBROUTINE ERFC_B(xx, xxb, erfcb)
        IMPLICIT NONE
        REAL :: xx
        REAL :: xxb
        REAL :: result1
        REAL :: result1b
        REAL :: erfc
        REAL :: erfcb
        REAL :: ERF
        result1b = -erfcb
        CALL ERF_B(xx, xxb, result1b)
      END SUBROUTINE ERFC_B

