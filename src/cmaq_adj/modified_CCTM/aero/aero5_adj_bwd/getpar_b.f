!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.4 (r3376) - 10 Feb 2010 17:51
!
!  Differentiation of getpar in reverse (adjoint) mode:
!   gradient     of useful results: aeromode_diam moment0_conc
!                moment2_conc moment3_conc aeromode_dens aerospc_conc
!                aeromode_sdev aeromode_mass
!   with respect to varying inputs: aeromode_diam moment0_conc
!                moment2_conc moment3_conc aeromode_dens aerospc_conc
!                aeromode_sdev aeromode_mass
! //////////////////////////////////////////////////////////////////
!  Subroutine GETPAR calculates the 3rd moments (M3), masses, aerosol
!  densities, and geometric mean diameters (Dg) of all 3 modes, and the
!  natural logs of geometric standard deviations (Sg) of the
!  Aitken and accumulation modes.
!  The input logical variable, M3_WET_FLAG, dictates whether the
!  calculations in GETPAR are to assume that the aerosol is "wet" or
!  "dry."  In the present context, a "wet" aerosol consists of all
!  chemical components of the aerosol.  A "dry" aerosol excludes
!  particle-bound water and also excludes secondary organic aerosol.
!  NOTE! 2nd moment concentrations (M2) are passed into GETPAR in the
!  CBLK array and are modified within GETPAR only in the event that
!  the Sg value of a given mode has gone outside of the acceptable
!  range (1.05 to 2.50).  The GETPAR calculations implicitly assume
!  that the input value of M2 is consistent with the input value of
!  M3_WET_FLAG.  If, for example, the input M2 value was calculated
!  for a "dry" aerosol and the M3_WET_FLAG is .TRUE., GETPAR would
!  incorrectly adjust the M2 concentrations!
!-----------------------------------------------------------------------
      SUBROUTINE GETPAR_B(m3_wet_flag, limit_sg)
        USE AERO_DATA_B
        USE MET_DATA
        IMPLICIT NONE
!
!
! Arguments:
! true = include H2O and SOA in 3rd moment
! false = exclude H2O and SOA from 3rd moment
        LOGICAL, INTENT(IN) :: m3_wet_flag
!
! fix coarse and accum Sg's to the input value?
        LOGICAL, INTENT(IN) :: limit_sg
!
! Output variables:
!  updates arrays in aero_data module
!  moment3_conc   3rd moment concentration [ ug /m**3 ]
!  aeromode_mass  mass concentration: [ ug / m**3 ]
!  aeromode_dens  avg particle density [ kg / m**3 ]
!  aeromode_diam  geometric mean diameter [ m ]
!  aeromode_sdev  log of geometric standard deviation
!
! Local Variables:
! temporary storage of moment 0 conc's
        REAL*8 :: xxm0
        REAL*8 :: xxm0b
! temporary storage of moment 2 conc's
        REAL*8 :: xxm2
        REAL*8 :: xxm2b
! temporary storage of moment 3 conc's
        REAL*8 :: xxm3
        REAL*8 :: xxm3b
! (ln(M0)+2ln(M3))/3; used in Sg calcs
        REAL*8 :: xfsum
        REAL*8 :: xfsumb
! ln(M2); used in Sg calcs
        REAL*8 :: lxfm2
        REAL*8 :: lxfm2b
! square of ln(Sg); used in diameter calcs
        REAL*8 :: l2sg
        REAL*8 :: l2sgb
! exp(4.5*l2sg); used in diameter calcs
        REAL :: es36
        REAL :: es36b
! temp variable for wet 3rd moment calcs
        REAL :: m3augm
!
        REAL*8, PARAMETER :: one3d=1.0d0/3.0d0
        REAL*8, PARAMETER :: two3d=2.0d0/3.0d0
!
        REAL, PARAMETER :: one3=1.0/3.0
! minimum particle diameter [ m ]
        REAL, PARAMETER :: dgmin=1.0e-09
! minimum particle density [ kg/m**3 ]
        REAL, PARAMETER :: densmin=1.0e03
!
! min value of ln(sg)**2 for each mode
        REAL*8 :: minl2sg(n_mode)
        REAL*8 :: minl2sgb(n_mode)
! max value of ln(sg)**2 for each mode
        REAL*8 :: maxl2sg(n_mode)
        REAL*8 :: maxl2sgb(n_mode)
!
        REAL :: factor
! loop counters
        INTEGER :: n, spc
        real :: arg0
        INTEGER :: branch
        REAL*8 :: y1b
        REAL :: temp0
        INTRINSIC EXP
        REAL :: temp0b
        REAL :: tempb0
        INTRINSIC MAX
        REAL*8 :: x1
        INTRINSIC REAL
        REAL*8 :: tempb
        INTRINSIC LOG
        INTRINSIC MIN
        INTRINSIC SQRT
        REAL :: temp
        REAL*8 :: y1
!
!-----------------------------------------------------------------------
!
! *** Set bounds for ln(Sg)**2
!
        DO n=1,n_mode
          IF (limit_sg .EQV. .true.) THEN
            minl2sg(n) = aeromode_sdev(n)**2
            maxl2sg(n) = aeromode_sdev(n)**2
            CALL PUSHINTEGER4(1)
          ELSE
            minl2sg(n) = LOG(min_sigma_g)**2
            maxl2sg(n) = LOG(max_sigma_g)**2
            CALL PUSHINTEGER4(2)
          END IF
        END DO
!
! *** Calculate aerosol 3rd moment concentrations [ m**3 / m**3 ]
!
        DO n=1,n_mode
          CALL PUSHREAL4(moment3_conc(n))
          moment3_conc(n) = 0.0
          aeromode_mass(n) = 0.0
!
          DO spc=1,n_aerospc
            IF (aerospc(spc)%name(n) .NE. ' ' .AND. ((.NOT.aerospc(spc)%iswet)
     +          .OR. m3_wet_flag)) THEN
              factor = 1.0e-9*f6dpi/aerospc(spc)%density
              moment3_conc(n) = moment3_conc(n) + factor*aerospc_conc(spc, n)
              aeromode_mass(n) = aeromode_mass(n) + aerospc_conc(spc, n)
              CALL PUSHINTEGER4(2)
            ELSE
              CALL PUSHINTEGER4(1)
            END IF
          END DO
        END DO
!
!
! *** Calculate modal average particle densities [ kg m**-3 ]
!
        DO n=1,n_mode
          arg0 = densmin
          x1 = REAL(arg0, 8)
          y1 = 1.0e-9*f6dpi*aeromode_mass(n)/moment3_conc(n)
          IF (x1 .LT. y1) THEN
            CALL PUSHINTEGER4(2)
          ELSE
            CALL PUSHINTEGER4(1)
          END IF
        END DO
!
! *** Calculate geometric standard deviations as follows:
!        ln^2(Sg) = 1/3*ln(M0) + 2/3*ln(M3) - ln(M2)
!     NOTES:
!      1. Equation 10-5a of [Binkowski:1999] and Equation 5a of
!         Binkowski&Roselle(2003) contain typographical errors.
!      2. If the square of the logarithm of the geometric standard
!         deviation is out of an acceptable range, reset this value and
!         adjust the second moments to be consistent with this value.
!         In this manner, M2 is artificially increased when Sg exceeds
!         the maximum limit.  M2 is artificially decreased when Sg falls
!         below the minimum limit.
!
! *** Aitken Mode:
!
        DO n=1,n_mode
          xxm0 = moment0_conc(n)
          xxm2 = moment2_conc(n)
          xxm3 = moment3_conc(n)
!
          xfsum = one3d*LOG(xxm0) + two3d*LOG(xxm3)
          CALL PUSHREAL8(lxfm2)
!
          lxfm2 = LOG(xxm2)
          CALL PUSHREAL8(l2sg)
          l2sg = xfsum - lxfm2
          IF (l2sg .LT. minl2sg(n)) THEN
            l2sg = minl2sg(n)
            CALL PUSHINTEGER4(1)
          ELSE
            CALL PUSHINTEGER4(0)
            l2sg = l2sg
          END IF
          IF (l2sg .GT. maxl2sg(n)) THEN
            l2sg = maxl2sg(n)
            CALL PUSHINTEGER4(1)
          ELSE
            CALL PUSHINTEGER4(0)
            l2sg = l2sg
          END IF
!
          lxfm2 = xfsum - l2sg
          CALL PUSHREAL4(es36)
!
          es36 = EXP(4.5*l2sg)
          IF (dgmin .LT. (moment3_conc(n)/(moment0_conc(n)*es36))**one3) THEN
            CALL PUSHINTEGER4(2)
          ELSE
            CALL PUSHINTEGER4(1)
          END IF
        END DO
        minl2sgb = 0.0_8
        maxl2sgb = 0.0_8
        DO n=n_mode,1,-1
          CALL POPINTEGER4(branch)
          IF (branch .LT. 2) THEN
            aeromode_diamb(n) = 0.0
            es36b = 0.0
          ELSE
            temp = moment0_conc(n)*es36
            temp0 = moment3_conc(n)/temp
            IF (temp0 .LE. 0.0 .AND. (one3 .EQ. 0.0 .OR. one3 .NE. INT(one3))
     +      ) THEN
              temp0b = 0.0
            ELSE
              temp0b = one3*temp0**(one3-1)*aeromode_diamb(n)/temp
            END IF
            tempb0 = -(temp0*temp0b)
            moment3_concb(n) = moment3_concb(n) + temp0b
            moment0_concb(n) = moment0_concb(n) + es36*tempb0
            es36b = moment0_conc(n)*tempb0
            aeromode_diamb(n) = 0.0
          END IF
          CALL POPREAL4(es36)
          lxfm2b = EXP(lxfm2)*moment2_concb(n)
          IF (l2sg .EQ. 0.0) THEN
            l2sgb = EXP(4.5*l2sg)*4.5*es36b - lxfm2b
          ELSE
            l2sgb = aeromode_sdevb(n)/(2.0*SQRT(l2sg)) - lxfm2b + EXP(4.5*l2sg
     +        )*4.5*es36b
          END IF
          aeromode_sdevb(n) = 0.0
          moment2_concb(n) = 0.0
          xfsumb = lxfm2b
          CALL POPINTEGER4(branch)
          IF (.NOT.branch .LT. 1) THEN
            maxl2sgb(n) = maxl2sgb(n) + l2sgb
            l2sgb = 0.0_8
          END IF
          CALL POPINTEGER4(branch)
          IF (.NOT.branch .LT. 1) THEN
            minl2sgb(n) = minl2sgb(n) + l2sgb
            l2sgb = 0.0_8
          END IF
          CALL POPREAL8(l2sg)
          xfsumb = xfsumb + l2sgb
          lxfm2b = -l2sgb
          xxm2 = moment2_conc(n)
          CALL POPREAL8(lxfm2)
          xxm2b = lxfm2b/xxm2
          xxm0 = moment0_conc(n)
          xxm3 = moment3_conc(n)
          xxm0b = one3d*xfsumb/xxm0
          xxm3b = two3d*xfsumb/xxm3
          moment3_concb(n) = moment3_concb(n) + xxm3b
          moment2_concb(n) = moment2_concb(n) + xxm2b
          moment0_concb(n) = moment0_concb(n) + xxm0b
        END DO
        DO n=n_mode,1,-1
          CALL POPINTEGER4(branch)
          IF (branch .LT. 2) THEN
            aeromode_densb(n) = 0.0
            y1b = 0.0_8
          ELSE
            y1b = aeromode_densb(n)
            aeromode_densb(n) = 0.0
          END IF
          tempb = f6dpi*1.0e-9*y1b/moment3_conc(n)
          aeromode_massb(n) = aeromode_massb(n) + tempb
          moment3_concb(n) = moment3_concb(n) - aeromode_mass(n)*tempb/
     +      moment3_conc(n)
        END DO
        DO n=n_mode,1,-1
          DO spc=n_aerospc,1,-1
            CALL POPINTEGER4(branch)
            IF (.NOT.branch .LT. 2) THEN
              factor = 1.0e-9*f6dpi/aerospc(spc)%density
              aerospc_concb(spc, n) = aerospc_concb(spc, n) + factor*
     +          moment3_concb(n) + aeromode_massb(n)
            END IF
          END DO
          aeromode_massb(n) = 0.0
          CALL POPREAL4(moment3_conc(n))
          moment3_concb(n) = 0.0
        END DO
        DO n=n_mode,1,-1
          CALL POPINTEGER4(branch)
          IF (branch .LT. 2) THEN
            aeromode_sdevb(n) = aeromode_sdevb(n) + 2*aeromode_sdev(n)*
     +        minl2sgb(n) + 2*aeromode_sdev(n)*maxl2sgb(n)
            maxl2sgb(n) = 0.0_8
            minl2sgb(n) = 0.0_8
          ELSE
            maxl2sgb(n) = 0.0_8
            minl2sgb(n) = 0.0_8
          END IF
        END DO
      END SUBROUTINE GETPAR_B
