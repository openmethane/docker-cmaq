C        Generated by TAPENADE     (INRIA, Tropics team)
C  Tapenade 3.9 (r5096) - 24 Feb 2014 16:54
C
C  Differentiation of hppm in reverse (adjoint) mode:
C   gradient     of useful results: con
C   with respect to varying inputs: con
C   RW status of diff variables: con:in-out
C
C***********************************************************************
C   Portions of Models-3/CMAQ software were developed or based on      *
C   information from various groups: Federal Government employees,     *
C   contractors working on a United States Government contract, and    *
C   non-Federal sources (including research institutions).  These      *
C   research institutions have given the Government permission to      *
C   use, prepare derivative works, and distribute copies of their      *
C   work in Models-3/CMAQ to the public and to permit others to do     *
C   so.  EPA therefore grants similar permissions for use of the       *
C   Models-3/CMAQ software, but users are requested to provide copies  *
C   of derivative works to the Government without restrictions as to   *
C   use by others.  Users are responsible for acquiring their own      *
C   copies of commercial software associated with Models-3/CMAQ and    *
C   for complying with vendor requirements.  Software copyrights by    *
C   the MCNC Environmental Modeling Center are used with their         *
C   permissions subject to the above restrictions.                     *
C***********************************************************************
C
C RCS file, release, date & time of last delta, author, state, [and locker]
C $Header: /Volumes/Data/CVS/CMAQ_CVSrepos/CCTM/src/hadv/yamo_cadj_fwd/hppm.F,v 1.1 2013/05/14 15:53:42 ppercell Exp $
C
C what(1) key, module and SID; SCCS file; date and time of last delta:
C %W% %P% %G% %U%
C
C:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      SUBROUTINE HPPM_BWD(ni, n_spc_adv, con, conb, vel, dt, ds, ori)
C
      USE HGRD_DEFN
C
      IMPLICIT NONE
c$$$      INCLUDE 'DIFFSIZES.inc'
c$$$C  Hint: ISIZE1OFfmbINhppm should be the value of ni+1
c$$$C  Hint: ISIZE2OFfmbINhppm should be the value of n_spc_adv
c$$$C  Hint: ISIZE1OFfpbINhppm should be the value of ni--1
c$$$C  Hint: ISIZE2OFfpbINhppm should be the value of n_spc_adv
c$$$C  Hint: ISIZE1OFcmbINhppm should be the value of ni+off_1+1-(-off_1)
c$$$C  Hint: ISIZE2OFcmbINhppm should be the value of n_spc_adv
c$$$C  Hint: ISIZE1OFclbINhppm should be the value of ni+off_1-(-off_1)
c$$$C  Hint: ISIZE1OFcrbINhppm should be the value of ni+off_1-(-off_1)
c$$$C  Hint: ISIZE1OFdcbINhppm should be the value of ni+off_1+1-(-1-off_1)
c$$$C  Hint: ISIZE2OFdcbINhppm should be the value of n_spc_adv
c$$$C  Hint: ISIZE1OFc6bINhppm should be the value of ni+off_1-(-off_1)
C
C Parameters:
#ifdef parallel
      INTEGER, PARAMETER :: SWP = 3
      INTEGER, PARAMETER :: OFF_1 = 1
      INTEGER, PARAMETER :: OFF_3 = 3
#else
      INTEGER, PARAMETER :: SWP = 1
      INTEGER, PARAMETER :: OFF_1 = 0
      INTEGER, PARAMETER :: OFF_3 = 0
#endif
C
      REAL, PARAMETER :: two3rds=2.0/3.0
      REAL, PARAMETER :: sixth=1.0/6.0
C
C Arguments:
C number of zones (cells)
      INTEGER, INTENT(IN) :: ni
C number of species advected
      INTEGER, INTENT(IN) :: n_spc_adv
C conc's in the zones (cells)
      REAL, INTENT(INOUT) :: con(1-swp:ni+swp, n_spc_adv)
      REAL, INTENT(INOUT) :: conb(1-swp:ni+swp, n_spc_adv)
C velocities at zone (cell) boundaries
      REAL, INTENT(IN) :: vel(ni+1)
C time step
      REAL, INTENT(IN) :: dt
C distance between zone (cell) boundaries
      REAL, INTENT(IN) :: ds
C orientation of advection ('C'-x or 'R'-y)
      CHARACTER, INTENT(IN) :: ori
C
C Local Variables:
C for test if Col or Row orientation change
      CHARACTER, SAVE :: firstori=' '
C
      LOGICAL, SAVE :: bndy_lo_pe, bndy_hi_pe
C
C outflux from left or bottom of cell
      REAL fm(ni+1, n_spc_adv)
C outflux from right or top of cell
      REAL fp(0:ni, n_spc_adv)
C
C zone R.H. trial intercept
      REAL cm(1-off_1:ni+off_1+1, n_spc_adv)
C zone L.H. intercept
      REAL cl(1-off_1:ni+off_1)
C zone R.H. intercept
      REAL cr(1-off_1:ni+off_1)
C CR - CL
      REAL dc(0-off_1:ni+off_1+1, n_spc_adv)
C coefficient of second-order term
      REAL c6(1-off_1:ni+off_1)
C
      REAL c0, c1
      REAL c0b, c1b
C
      REAL x, frc
C
C loop indices
      INTEGER i, s
      INTRINSIC SIGN
      INTRINSIC ABS
      INTRINSIC MIN
      INTEGER branch
      REAL fmb(ni+1, n_spc_adv)
      REAL y1b
      REAL fpb(0:ni, n_spc_adv)
      REAL abs1b
      REAL clb(1-off_1:ni+off_1)
      REAL min1
      REAL tempb4
      REAL tempb3
      REAL tempb2
      REAL tempb1
      REAL tempb0
      REAL crb(1-off_1:ni+off_1)
      REAL min1b
      REAL x1
      REAL dcb(0-off_1:ni+off_1+1, n_spc_adv)
      REAL z1b
      REAL abs0b
      REAL tempb
      REAL x1b
      REAL z1
      REAL abs1
      REAL abs0
      REAL cmb(1-off_1:ni+off_1+1, n_spc_adv)
      REAL c6b(1-off_1:ni+off_1)
      REAL y1
C
C----------------------------------------------------------------------
C
      x = dt/ds
C
      IF ( ORI .NE. FIRSTORI ) THEN
         FIRSTORI = ORI
         IF ( ORI .EQ. 'C' ) THEN
            BNDY_LO_PE = ( COLSX_PE( 1,MYPE+1 ) .EQ. 1 )
            BNDY_HI_PE = ( COLSX_PE( 2,MYPE+1 ) .EQ. GL_NCOLS )
         ELSE
            BNDY_LO_PE = ( ROWSX_PE( 1,MYPE+1 ) .EQ. 1 )
            BNDY_HI_PE = ( ROWSX_PE( 2,MYPE+1 ) .EQ. GL_NROWS )
         END IF
      END IF   ! FIRSTORI
C
C Second order polynomial inside the domain
      DO s=1,n_spc_adv
        DO i=2-off_3,ni+off_3-1
C
C Compute average slope in the i'th zone
C
C Equation (1.7)
          c0 = con(i, s) - con(i-1, s)
          c1 = con(i+1, s) - con(i, s)
          dc(i, s) = 0.5*(c0+c1)
C
C Guarantee that CM lies between CON(I) and CON(I+1) - monotonicity constraint
C
C Equation (1.8)
          IF (c0*c1 .GT. 0.0) THEN
            IF (dc(i, s) .GE. 0.) THEN
              x1 = dc(i, s)
              CALL PUSHCONTROL1B(0)
            ELSE
              x1 = -dc(i, s)
              CALL PUSHCONTROL1B(1)
            END IF
            IF (c0 .GE. 0.) THEN
              abs0 = c0
              CALL PUSHCONTROL1B(0)
            ELSE
              abs0 = -c0
              CALL PUSHCONTROL1B(1)
            END IF
            y1 = 2.0*abs0
            IF (c1 .GE. 0.) THEN
              abs1 = c1
              CALL PUSHCONTROL1B(0)
            ELSE
              abs1 = -c1
              CALL PUSHCONTROL1B(1)
            END IF
            z1 = 2.0*abs1
            IF (x1 .GT. y1) THEN
              IF (y1 .GT. z1) THEN
                min1 = z1
                CALL PUSHCONTROL2B(0)
              ELSE
                min1 = y1
                CALL PUSHCONTROL2B(1)
              END IF
            ELSE IF (x1 .GT. z1) THEN
              min1 = z1
              CALL PUSHCONTROL2B(2)
            ELSE
              min1 = x1
              CALL PUSHCONTROL2B(3)
            END IF
            CALL PUSHREAL4(dc(i, s))
            dc(i, s) = SIGN(1.0, dc(i, s))*min1
            CALL PUSHCONTROL1B(1)
          ELSE
            dc(i, s) = 0.0
            CALL PUSHCONTROL1B(0)
          END IF
        ENDDO
C
C I
C
C Equation (1.6)
        DO i=3-off_3,ni+off_3-1
          cm(i, s) = 0.5*(con(i, s)+con(i-1, s)) - sixth*(dc(i, s)-dc(i-
     +      1, s))
        ENDDO
      ENDDO
C S
C
C If PE near bottom or left domain boundary...
C Zeroth order polynomial at the boundary cells
C First order polynomial at the next cells, no monotonicity constraint needed
      IF (bndy_lo_pe) THEN
        DO s=1,n_spc_adv
          cm(1, s) = con(1, s)
          cm(2, s) = 0.5*(con(1, s)+con(2, s))
        ENDDO
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
C
C If PE near top or right domain boundary...
C Zeroth order polynomial at the boundary cells
C First order polynomial at the next cells, no monotonicity constraint needed
      IF (bndy_hi_pe) THEN
        DO s=1,n_spc_adv
          cm(ni+1, s) = con(ni, s)
          cm(ni, s) = 0.5*(con(ni, s)+con(ni-1, s))
        ENDDO
        CALL PUSHCONTROL1B(1)
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
C
C Generate piecewise parabolic distributions
      DO s=1,n_spc_adv
        CALL PUSHINTEGER4(i)
C
        DO i=1-off_1,ni+off_1
C
C Equation (1.15)
          cr(i) = cm(i+1, s)
          cl(i) = cm(i, s)
C
C Monotonicity
          IF ((cr(i)-con(i, s))*(con(i, s)-cl(i)) .GT. 0.0) THEN
C
C Temporary computation of DC and C6
            dc(i, s) = cr(i) - cl(i)
            c6(i) = 6.0*(con(i, s)-0.5*(cl(i)+cr(i)))
C
C Overshoot cases - Equation (1.10)
            IF (dc(i, s)*c6(i) .GT. dc(i, s)*dc(i, s)) THEN
              CALL PUSHCONTROL2B(0)
            ELSE IF (-(dc(i, s)*dc(i, s)) .GT. dc(i, s)*c6(i)) THEN
              CALL PUSHCONTROL2B(1)
            ELSE
              CALL PUSHCONTROL2B(2)
            END IF
          ELSE
            CALL PUSHCONTROL2B(3)
          END IF
        ENDDO
C
C I
C
C Compute fluxes from the parabolic distribution as in Equation (1.12)
        IF (.NOT.bndy_lo_pe) THEN
          i = 0
          IF (vel(i+1) .GT. 0.0) THEN
            CALL PUSHCONTROL2B(2)
          ELSE
            CALL PUSHCONTROL2B(1)
          END IF
        ELSE
          CALL PUSHCONTROL2B(0)
        END IF
        CALL PUSHINTEGER4(i)
C
        DO i=1,ni
C
C function for mass leaving interval I at lower face (I-1/2)
C = length of segment leaving * integral average concentration in that segment
          IF (vel(i) .LT. 0.0) THEN
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHCONTROL1B(1)
          END IF
C
C function for mass leaving interval I at upper face (I+1/2)
          IF (vel(i+1) .GT. 0.0) THEN
            CALL PUSHCONTROL1B(1)
          ELSE
            CALL PUSHCONTROL1B(0)
          END IF
        ENDDO
C
C I
C
        IF (.NOT.bndy_hi_pe) THEN
          i = ni + 1
          IF (vel(i) .LT. 0.0) THEN
            CALL PUSHCONTROL2B(2)
          ELSE
            CALL PUSHCONTROL2B(1)
          END IF
        ELSE
          CALL PUSHCONTROL2B(0)
        END IF
      ENDDO
C
C S
C
C Compute fluxes from boundary cells
C
C If PE near top or left boundary...
      IF (bndy_lo_pe) THEN
        IF (vel(1) .GT. 0.0) THEN
          frc = vel(1)*x
          CALL PUSHCONTROL2B(0)
        ELSE
          CALL PUSHCONTROL2B(1)
        END IF
      ELSE
        CALL PUSHCONTROL2B(2)
      END IF
C
C If PE near bottom or right boundary...
      IF (bndy_hi_pe) THEN
        IF (vel(ni+1) .LT. 0.0) THEN
          CALL PUSHREAL4(frc)
          frc = -(vel(ni+1)*x)
          CALL PUSHCONTROL2B(2)
        ELSE
          CALL PUSHCONTROL2B(1)
        END IF
      ELSE
        CALL PUSHCONTROL2B(0)
      END IF
C
C Update concentrations as in Equation (1.13)
      DO s=1,n_spc_adv
        CALL PUSHINTEGER4(i)
      ENDDO
      fmb = 0.0
      fpb = 0.0
      DO s=n_spc_adv,1,-1
        DO i=ni,1,-1
          fpb(i-1, s) = fpb(i-1, s) + conb(i, s)
          fpb(i, s) = fpb(i, s) - conb(i, s)
          fmb(i+1, s) = fmb(i+1, s) + conb(i, s)
          fmb(i, s) = fmb(i, s) - conb(i, s)
        ENDDO
        CALL POPINTEGER4(i)
      ENDDO
      CALL POPCONTROL2B(branch)
      IF (branch .NE. 0) THEN
        IF (branch .NE. 1) THEN
          DO s=n_spc_adv,1,-1
            conb(ni+1, s) = conb(ni+1, s) + frc*fmb(ni+1, s)
            fmb(ni+1, s) = 0.0
          ENDDO
          CALL POPREAL4(frc)
        END IF
      END IF
      CALL POPCONTROL2B(branch)
      IF (branch .EQ. 0) THEN
        DO s=n_spc_adv,1,-1
          conb(0, s) = conb(0, s) + frc*fpb(0, s)
          fpb(0, s) = 0.0
        ENDDO
      END IF
      c6b = 0.0
      clb = 0.0
      cmb = 0.0
      crb = 0.0
      dcb = 0.0
      DO s=n_spc_adv,1,-1
        CALL POPCONTROL2B(branch)
        IF (branch .NE. 0) THEN
          IF (branch .NE. 1) THEN
            i = ni + 1
            frc = -(vel(i)*x)
            tempb4 = frc**2*0.5*fmb(i, s)
            clb(i) = clb(i) + frc*fmb(i, s)
            dcb(i, s) = dcb(i, s) + tempb4
            c6b(i) = c6b(i) + (1.0-two3rds*frc)*tempb4
            fmb(i, s) = 0.0
          END IF
        END IF
        DO i=ni,1,-1
          CALL POPCONTROL1B(branch)
          IF (branch .NE. 0) THEN
            frc = vel(i+1)*x
            tempb3 = -(frc**2*0.5*fpb(i, s))
            crb(i) = crb(i) + frc*fpb(i, s)
            dcb(i, s) = dcb(i, s) + tempb3
            c6b(i) = c6b(i) - (1.0-two3rds*frc)*tempb3
            fpb(i, s) = 0.0
          END IF
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            frc = -(vel(i)*x)
            tempb2 = frc**2*0.5*fmb(i, s)
            clb(i) = clb(i) + frc*fmb(i, s)
            dcb(i, s) = dcb(i, s) + tempb2
            c6b(i) = c6b(i) + (1.0-two3rds*frc)*tempb2
            fmb(i, s) = 0.0
          END IF
        ENDDO
        CALL POPINTEGER4(i)
        CALL POPCONTROL2B(branch)
        IF (branch .NE. 0) THEN
          IF (branch .NE. 1) THEN
            i = 0
            frc = vel(i+1)*x
            tempb1 = -(frc**2*0.5*fpb(i, s))
            crb(i) = crb(i) + frc*fpb(i, s)
            dcb(i, s) = dcb(i, s) + tempb1
            c6b(i) = c6b(i) - (1.0-two3rds*frc)*tempb1
            fpb(i, s) = 0.0
          END IF
        END IF
        DO i=ni+off_1,1-off_1,-1
          tempb0 = 6.0*c6b(i)
          conb(i, s) = conb(i, s) + tempb0
          clb(i) = clb(i) - dcb(i, s) - 0.5*tempb0
          crb(i) = crb(i) + dcb(i, s) - 0.5*tempb0
          c6b(i) = 0.0
          dcb(i, s) = 0.0
          CALL POPCONTROL2B(branch)
          IF (branch .LT. 2) THEN
            IF (branch .EQ. 0) THEN
              conb(i, s) = conb(i, s) + 3.0*clb(i)
              crb(i) = crb(i) - 2.0*clb(i)
              clb(i) = 0.0
            ELSE
              conb(i, s) = conb(i, s) + 3.0*crb(i)
              clb(i) = clb(i) - 2.0*crb(i)
              crb(i) = 0.0
            END IF
          ELSE IF (branch .NE. 2) THEN
            clb(i) = clb(i) + crb(i)
            crb(i) = 0.0
            conb(i, s) = conb(i, s) + clb(i)
            clb(i) = 0.0
            GOTO 100
          END IF
          tempb = 6.0*c6b(i)
          conb(i, s) = conb(i, s) + tempb
          clb(i) = clb(i) - dcb(i, s) - 0.5*tempb
          crb(i) = crb(i) + dcb(i, s) - 0.5*tempb
          c6b(i) = 0.0
          dcb(i, s) = 0.0
 100      cmb(i, s) = cmb(i, s) + clb(i)
          clb(i) = 0.0
          cmb(i+1, s) = cmb(i+1, s) + crb(i)
          crb(i) = 0.0
        ENDDO
        CALL POPINTEGER4(i)
      ENDDO
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) THEN
        DO s=n_spc_adv,1,-1
          conb(ni, s) = conb(ni, s) + 0.5*cmb(ni, s)
          conb(ni-1, s) = conb(ni-1, s) + 0.5*cmb(ni, s)
          cmb(ni, s) = 0.0
          conb(ni, s) = conb(ni, s) + cmb(ni+1, s)
          cmb(ni+1, s) = 0.0
        ENDDO
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        DO s=n_spc_adv,1,-1
          conb(1, s) = conb(1, s) + 0.5*cmb(2, s)
          conb(2, s) = conb(2, s) + 0.5*cmb(2, s)
          cmb(2, s) = 0.0
          conb(1, s) = conb(1, s) + cmb(1, s)
          cmb(1, s) = 0.0
        ENDDO
      END IF
      DO s=n_spc_adv,1,-1
        DO i=ni+off_3-1,3-off_3,-1
          conb(i, s) = conb(i, s) + 0.5*cmb(i, s)
          conb(i-1, s) = conb(i-1, s) + 0.5*cmb(i, s)
          dcb(i, s) = dcb(i, s) - sixth*cmb(i, s)
          dcb(i-1, s) = dcb(i-1, s) + sixth*cmb(i, s)
          cmb(i, s) = 0.0
        ENDDO
        DO i=ni+off_3-1,2-off_3,-1
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            dcb(i, s) = 0.0
            c0b = 0.0
            c1b = 0.0
          ELSE
            CALL POPREAL4(dc(i, s))
            min1b = SIGN(1.0, dc(i, s))*dcb(i, s)
            dcb(i, s) = 0.0
            CALL POPCONTROL2B(branch)
            IF (branch .LT. 2) THEN
              IF (branch .EQ. 0) THEN
                z1b = min1b
                y1b = 0.0
              ELSE
                y1b = min1b
                z1b = 0.0
              END IF
              x1b = 0.0
            ELSE
              IF (branch .EQ. 2) THEN
                z1b = min1b
                x1b = 0.0
              ELSE
                x1b = min1b
                z1b = 0.0
              END IF
              y1b = 0.0
            END IF
            abs1b = 2.0*z1b
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              c1b = abs1b
            ELSE
              c1b = -abs1b
            END IF
            abs0b = 2.0*y1b
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              c0b = abs0b
            ELSE
              c0b = -abs0b
            END IF
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              dcb(i, s) = dcb(i, s) + x1b
            ELSE
              dcb(i, s) = dcb(i, s) - x1b
            END IF
          END IF
          c0b = c0b + 0.5*dcb(i, s)
          c1b = c1b + 0.5*dcb(i, s)
          dcb(i, s) = 0.0
          conb(i+1, s) = conb(i+1, s) + c1b
          conb(i, s) = conb(i, s) + c0b - c1b
          conb(i-1, s) = conb(i-1, s) - c0b
        ENDDO
      ENDDO
      END
