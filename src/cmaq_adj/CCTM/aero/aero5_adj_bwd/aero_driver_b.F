!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.4 (r3376) - 10 Feb 2010 17:51
! revised by shunliu zhao
!  Differentiation of aero in reverse (adjoint) mode:
!   gradient     of useful results: aeromode_diam moment0_conc
!                moment2_conc moment3_conc aeromode_dens aerospc_conc
!                aeromode_sdev aeromode_mass so4rate precursor_conc
!                vapor_conc orgprod_conc cgrid
!   with respect to varying inputs: aeromode_diam aerospc_mw moment3_conc
!                aeromode_dens h2ofac aeromode_sdev aeromode_mass
!                precursor_mw orgprod_mw vapor_mw cgrid
!
!***********************************************************************
!   Portions of Models-3/CMAQ software were developed or based on      *
!   information from various groups: Federal Government employees,     *
!   contractors working on a United States Government contract, and    *
!   non-Federal sources (including research institutions).  These      *
!   research institutions have given the Government permission to      *
!   use, prepare derivative works, and distribute copies of their      *
!   work in Models-3/CMAQ to the public and to permit others to do     *
!   so.  EPA therefore grants similar permissions for use of the       *
!   Models-3/CMAQ software, but users are requested to provide copies  *
!   of derivative works to the Government without restrictions as to   *
!   use by others.  Users are responsible for acquiring their own      *
!   copies of commercial software associated with Models-3/CMAQ and    *
!   for complying with vendor requirements.  Software copyrights by    *
!   the MCNC Environmental Modeling Center are used with their         *
!   permissions subject to the above restrictions.                     *
!***********************************************************************
!
! RCS file, release, date & time of last delta, author, state, [and locker]
! $Header: /Volumes/Data/CVS/CMAQ_CVSrepos/CCTM/src/aero/aero5_adj_bwd/aero_driver_b.F,v 1.6 2011/06/14 18:32:31 shunliu Exp $
!
! what(1) key, module and SID; SCCS file; date and time of last delta:
! %W% %P% %G% %U%
!
! >>> 08/04/2000 Changes necessary to be able to read and process
! two different types of emissions files.
! the first type is the existing opperational PM2.5 & PM10 unspeciated
! file. The new file format has speciated emissions.
! >>> This version uses the FORTRAN 90 feature for runtime memory
! allocation.
!
! 1/12/99 David Wong at LM:
!   -- introduce new variable MY_NUMBLKS (eliminate NUMBLKS)
!   -- re-calculate NOXYZ accordingly
! FSB Updated for inclusion of surface area / second moment
! 25 Sep 00 (yoj) various bug fixes, cleanup to coding standards
!   Jeff - Dec 00 - move CGRID_MAP into f90 module
! FSB/Jeff - May 01 - optional emissions processing
!   Jerry Gipson - Jun 01 - added SOA linkages for saprc99
!   Bill Hutzell - Jun 01 - simplified CBLK mapping
!   Jerry Gipson - Jun 03 - modified for new soa treatment
!   Jerry Gipson - Aug 03 - removed SOA prod form alkenes & added
!       emission adjustment factors for ALK & TOL ( RADM2 & SAPRC99 only)
!   Shawn Roselle - Jan 04
!   - removed SOA from transported aerosol surface area
!   - fixed bug in calculation of wet parameters.  Previously, DRY aerosol
!      parameters were being written to the AERDIAG files and mislabeled
!      as WET.
!   Prakash Bhave - May 04
!   - changed AERODIAG species (added RH; removed M0 & M2dry)
!   Jeff Young - Jan 05 - dyn alloc
!   - establish both horizontal & vertical domain specifications in one module
!   Uma Shankar and Prakash Bhave - Jun 05
!   - added code to handle the following species: ANAI, ANAJ, ANAK, ACLI,
!     ACLJ, ACLK, ASO4K, AH2OK, ANO3K, and HCL; removed code for ASEAS
!   - removed obsolete MW variables
!   Prakash Bhave - Jul 05 - added PM25 mass-fraction calculations
!   Jeff Young - Feb 06 - trap fractional humidity above 0.005
!   Prakash Bhave - Apr 06 - added GAMMA_N2O5 to the AEROPROC call vector
!       and the aerosol diagnostic file
!   Prakash Bhave - May 06 - changed units of DG variables from m to um in
!       the aerosol diagnostic file as suggested by Dr. Bill Hutzell
!   Sergey Napelenok - Sep 07 - SOA updates
!   - added code to handle the following species: AALKJ, ATOL1J, ATOL2J,
!     ATOL3J, AXYL1J, AXYL2J, AXYL3J, ABNZ1J, ABNZ2J, ABNZ3J, AISO1J, AISO2J,
!     AISO3J, ATRP1J, ATRP2J, ASQTJ, AORGCJ, TOLNRXN, TOLHRXN, XYLNRXN,
!     XYLHRXN, BNZNRXN, BNZHRXN, ISOPRXN, and SESQRXN
!   - removed following species: AORGAI, AORGAJ, AORGBI, AORGBJ, OLIRXN,
!     CSLRXN, TOLRXN, XYLRXN
!   Prakash Bhave - Oct 07 - SOA updates
!   - added semi-volatile vapors to the CBLK array; moved ppm -> ug/m3 unit
!     conversion from the ORGAER subroutine to this program
!   - updated definition of DRY aerosol to include nonvolatile SOA species
!   - removed adjustment factors for TOLAER (SPTOL, RDTOL) because benzene is
!     now an explicit species so all of the reacted TOL can produce SOA
!   - removed code to handle TERPSP (obsolete); renamed TERPRXN as TRPRXN
!   David Wong - Jan 08 - rearranged calculation of dry 3rd moments to avoid
!      NaN on some compilers (using the M3SUBT variable)
!   Prakash Bhave - Jan 08 - updated MECHNAME check from AE4 to AE5
!   Golam Sarwar -  Mar 08 - added a heterogeneous reaction producing HONO
!   J.Kelly - Apr 08 - added code to account for new species (ANH4K
!                      SRFCOR) and variable coarse std. deviation
!                    - removed MW coding now located in AERO_INFO.f
!                    - added LIMIT_Sg flag for call to GETPAR
!:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      SUBROUTINE AERO_BWD( cgridb, jdate, jtime, tstep)
        USE SOA_DEFN_B
        USE AERO_DATA_B
        USE GRID_CONF
        USE PRECURSOR_DATA_B
        USE MET_DATA
        USE CGRID_SPCS
        USE CHK_FILES_DEFS        ! adjoint checkpoint files definition
        USE CHK_FILES             ! adjoint checkpoint files routines
!  Hint: nspcsd should be the size of dimension 2 of array cgrid
        IMPLICIT NONE

        INCLUDE SUBST_RXCMMN
        INCLUDE SUBST_IOPARMS
        INCLUDE SUBST_IOFDESC
        INCLUDE SUBST_PACTL_ID
        INCLUDE SUBST_GC_SPC
        INCLUDE SUBST_GC_EMIS
        INCLUDE SUBST_AE_SPC
        INCLUDE SUBST_NR_SPC
        INCLUDE SUBST_GC_G2AE
        INCLUDE SUBST_NR_N2AE
        INCLUDE SUBST_FILES_ID
!
! *** values of AL, BL, and CL are from:
!     Alduchov and Eskridge, "Improved Magnus Form Approximations of
!                            Saturation Vapor Pressure,"
!                            Jour. of Applied Meteorology, vol. 35,
!                            pp 601-609, April, 1996.
!
!     INCLUDE SUBST_IODECL    ! I/O definitions and declarations
!
!.........................................................................
! Version "@(#)$Header: /Volumes/Data/CVS/CMAQ_CVSrepos/CCTM/src/aero/aero5_adj_bwd/aero_driver_b.F,v 1.6 2011/06/14 18:32:31 shunliu Exp $"
!    EDSS/Models-3 I/O API.  Copyright (C) 1992-2002 MCNC
!    Distributed under the GNU LESSER GENERAL PUBLIC LICENSE version 2.1
!    See file "LGPL.txt" for conditions of use.
!....................................................................
!  INCLUDE FILE  IODECL3.EXT'
!
!
!  DO NOT EDIT !!
!
!       The EDSS/Models-3 I/O API depends in an essential manner
!       upon the contents of this INCLUDE file.  ANY CHANGES are
!       likely to result in very obscure, difficult-to-diagnose
!       bugs caused by an inconsistency between standard "libioapi.a"
!       object-libraries and whatever code is compiled with the
!       resulting modified INCLUDE-file.
!
!       By making any changes to this INCLUDE file, the user
!       explicitly agrees that in the case any assistance is
!       required of MCNC or of the I/O API author, Carlie J. Coats, Jr.
!       as a result of such changes, THE USER AND/OR HIS PROJECT OR
!       CONTRACT AGREES TO REIMBURSE MCNC AND/OR THE I/O API AUTHOR,
!       CARLIE J. COATS, JR., AT A RATE TRIPLE THE NORMAL CONTRACT
!       RATE FOR THE SERVICES REQUIRED.
!
!  CONTAINS:  declarations and usage comments for the Models-3 (M3)
!             Interprocess Communication Applications Programming
!             Interface (API)
!
!  DEPENDENT UPON:  consistency with the API itself.
!
!  RELATED FILES:  PARM3.EXT, FDESC3.EXT'
!
!  REVISION HISTORY:
!       prototype 3/1992 by Carlie J. Coats, Jr., MCNC Environmental
!       Programs
!
!       Modified  2/2002 by CJC:  updated dates, license, compatibility
!       with both free and fixed Fortran 9x source forms
!
!....................................................................
!
!  is JDATE:JTIME available for FNAME?
        LOGICAL :: CHECK3
!  close FNAME
        LOGICAL :: CLOSE3
!  Puts M3 file descriptions into FDESC3.EXT'
        LOGICAL :: DESC3
! check file type and dimensions
        LOGICAL :: FILCHK3
!  Initializes M3 API and returns unit for log
        INTEGER :: INIT3
!  Shuts down API
        LOGICAL :: SHUT3
!  opens an M3 file
        LOGICAL :: OPEN3
!  read M3 file for variable,layer,timestep
        LOGICAL :: READ3
!  write timestep to M3 file
        LOGICAL :: WRITE3
!  extract window from timestep in a M3 file
        LOGICAL :: XTRACT3
!  do time interpolation from a M3 file
        LOGICAL :: INTERP3
!  do time derivative from M3 file
        LOGICAL :: DDTVAR3
!
!  time interpolation from a window
!  extraction from an M3 gridded file
!  M3 boundary file
        LOGICAL :: INTERPX
!!        LOGICAL      PINTERPB !  parallel time interpolation from an
!
!  inquire attributes in M3 file
        LOGICAL :: INQATT3
!  read numeric attributes by name from M3 file
        LOGICAL :: RDATT3
!  add new numeric attributes "
        LOGICAL :: WRATT3
!  read CHAR attributes       "
        LOGICAL :: RDATTC
!  add new CHAR attributes    "
        LOGICAL :: WRATTC
!
!  flushes file to disk, etc.
        LOGICAL :: SYNC3
!
! , PINTERPB
        EXTERNAL CHECK3, CLOSE3, DESC3, FILCHK3, INIT3, SHUT3, OPEN3, READ3,
     +      WRITE3, XTRACT3, INTERP3, DDTVAR3, INQATT3, RDATT3, WRATT3, RDATTC
     +      , WRATTC, SYNC3, INTERPX
!
! *** arguments:
!
! *** CGRID is conc field (including gas and aerosol variables)
      REAL, POINTER :: CGRID( :,:,:,: )              !  concentrations
!        REAL :: cgrid(:, :, :, :)
        REAL :: cgridb(:, :, :, :)
        INTEGER :: N_SPC_CGRID
! Current model date , coded YYYYDDD
        INTEGER :: jdate
! Current model time , coded HHMMSS
        INTEGER :: jtime
! time step vector (HHMMSS)
! TSTEP(1) = local output step
! TSTEP(2) = sciproc sync. step (chem)
        INTEGER :: tstep(2)
!
! unit number for the log file
        INTEGER, SAVE :: logdev
!
! *** local variables:
        CHARACTER(len=16), SAVE :: pname='AERO_DRIVER_b'
! variable name
        CHARACTER(len=16) :: vname
        CHARACTER(len=96) :: xmsg=' '
!
! julian date, time and
! timestep in sec
        INTEGER :: mdate, mtime, mstep
! loop counters
        INTEGER :: c, r, l, v, n
! species loop counter
        INTEGER :: spc, size1
! loop induction variables
        INTEGER :: strt, fini
! memory allocation status
        INTEGER :: allocstat
!
! Error flag
        LOGICAL :: lerror
!
! *** External Functions not previously declared in IODECL3.EXT:
        INTEGER, EXTERNAL :: secsdiff, SEC2TIME, TIME2SEC, index1
! get environment variable as boolean
        LOGICAL, EXTERNAL :: ENVYN
!
! *** Grid description
! Cell x-dimension
        REAL :: dx1
! Cell y-dimension
        REAL :: dx2
! global origin offset from file
        INTEGER :: gxoff, gyoff
! for INTERPX
        INTEGER, SAVE :: strtcolmc3, endcolmc3, strtrowmc3, endrowmc3
!
! *** Variable to set time step for writing visibility file
! local write counter
        INTEGER, SAVE :: wstep=0
! local write flag
        LOGICAL, SAVE :: writetime=.false.
!
! *** meteorological variables
! Atmospheric pressure [ Pa ]
        REAL :: pres(ncols, nrows, nlays)
! Air temperature [ K ]
        REAL :: ta(ncols, nrows, nlays)
! Air density [ kg/m**-3 ]
        REAL :: dens(ncols, nrows, nlays)
! Water vapor mixing ratio [ kg/kg ]
        REAL :: qv(ncols, nrows, nlays)
!
! *** variables computed and output but not carried in CGRID
!
! *** visibility variables
        INTEGER, PARAMETER :: n_ae_vis_spc=4
! visual range in deciview (Mie)
        INTEGER, PARAMETER :: idcvw1=1
! extinction [ 1/km ] (Mie)
        INTEGER, PARAMETER :: ibext1=2
! visual range in deciview (Reconst)
        INTEGER, PARAMETER :: idcvw2=3
! extinction [ 1/km ] (Reconst)
        INTEGER, PARAMETER :: ibext2=4
! Visual range information
        REAL :: vis_spc(ncols, nrows, n_ae_vis_spc)
!
! *** aerosol size distribution variables
        REAL :: diam_spc(ncols, nrows, nlays, 23)
!
! *** atmospheric properties
! atmospheric mean free path [ m ]
        REAL :: xlm
! atmospheric dynamic viscosity [ kg/m s ]
        REAL :: amu
!
! *** N2O5 heterogeneous reaction probability [ ]
! computed in SUBROUTINE EQL3
        REAL :: gamma_n2o5
!
! *** mass fraction of each mode less than 2.5um aerodynamic diameter
! fine fractions
        REAL :: pm25(n_mode)
!
! *** visual range information
! block deciview (Mie)
        REAL :: blkdcv1
! block extinction [ km**-1 ] (Mie)
        REAL :: blkext1
!
! block deciview (Reconstructed)
        REAL :: blkdcv2
! block extinction [ km**-1 ] (Reconstructed)
        REAL :: blkext2
!
! *** other internal aerosol variables
! index to be used with INDEX1
        INTEGER :: ind
!
! *** synchronization time step [ s ]
        REAL :: dt
!
! *** variables to set up for "dry transport "
! third moment with and without water
        REAL :: m3_wet, m3_dry
        REAL :: m3_wetb, m3_dryb
! second moment with and without water
        REAL :: m2_wet, m2_dry
        REAL :: m2_wetb, m2_dryb
! temp variable for dry 3rd moment calcs
        REAL :: m3subt
        REAL :: m3subtb
!
! *** flag to include water in the 3rd moment calculation
        LOGICAL, PARAMETER :: m3_wet_flag=.false.
!
! *** if LIMIT_Sg = T, atkn & accum std. dev. are not changed by GETPAR
        LOGICAL, PARAMETER :: limit_sg=.false.
!
! *** variables aerosol diagnostic file flag
! ENV... status
        INTEGER :: status
! environment variable description
        CHARACTER(len=80) :: vardesc
!
! *** environment variable for AERDIAG file
        CHARACTER(len=16), SAVE :: ctm_aerdiag='CTM_AERDIAG'
!
! *** flag for AERDIAG file [F], default
        LOGICAL, SAVE :: aerdiag
!
! *** first pass flag
        LOGICAL, SAVE :: firstime=.true.
!
! *** ratio of molecular weights of water vapor to dry air = 0.622015
        REAL, PARAMETER :: epswater=mwwat/mwair
!
! *** dry moment factor
        REAL, PARAMETER :: twothirds=2.0/3.0
!
! *** Statement Function **************
! arithmetic statement function for vapor pressure [Pa]
        REAL :: esatl
        REAL :: tt
! *** Coefficients for the equation, ESATL defining saturation vapor pressure
        REAL, PARAMETER :: al=610.94
        REAL, PARAMETER :: bl=17.625
        REAL, PARAMETER :: cl=243.04
!
! *** End Statement Function  ********
!
        LOGICAL, SAVE :: now=.true.
        INTEGER :: result1
        LOGICAL :: result10
        LOGICAL :: res
        LOGICAL :: res0
        INTEGER :: res1
        INTEGER :: res2
        LOGICAL :: res3
        LOGICAL :: res4
        LOGICAL :: res5
        LOGICAL :: res6
        INTEGER :: branch
        REAL :: temp1
        REAL :: temp0
        INTRINSIC EXP
        REAL :: temp0b
        INTRINSIC MAX
        INTRINSIC INDEX
        INTRINSIC FLOAT
        REAL :: tempb
        INTRINSIC MIN
        REAL :: temp1b
        REAL :: temp
        REAL :: y1
	  
	  integer nr,nl,nc,ns
! FIRSTIME
!
! ------------------ begin body of AERO_DRIVER -------------------------
!
        IF (firstime) THEN
          logdev = INIT3()
          firstime = .false.

          N_SPC_CGRID = SIZE( CGRIDB, 4 )

          ! Allocate cgrid
          ALLOCATE( 
     &        CGRID( MY_NCOLS,MY_NROWS,NLAYS,N_SPC_CGRID ),
     &        STAT = ALLOCSTAT )

!*** Make sure an ae5 version of the mechanism is being used
!
! *** Get aerosol diagnostic file flag.
!
! default
C          vardesc = 'Flag for writing the aerosol diagnostic file'
C          IF (status .NE. 0) WRITE(logdev, '(5X, A)') vardesc
C          IF (.NOT.status .EQ. 1) THEN
C            IF (status .EQ. -1) THEN
C              xmsg = 'Environment variable set, but empty ... Using default:'
C              WRITE(logdev, '(5X, A, I9)') xmsg, jtime
C            ELSE IF (status .EQ. -2) THEN
C              xmsg = 'Environment variable not set ... Using default:'
C              WRITE(logdev, '(5X, A, I9)') xmsg, jtime
C            END IF
C          END IF
!
! *** Set up file structure for visibility file. It has two variables,
!     visual range in deciview units (dimensionless) and extinction in
!     units of (1/km) and is for layer 1 only.
!
!         IF ( MYPE .EQ. 0 ) CALL OPVIS ( JDATE, JTIME, TSTEP( 1 ) )
!
! *** Open the aerosol parameters file (diameters and standard deviations).
!
!         IF ( AERDIAG .AND.
!     &        MYPE .EQ. 0 ) CALL OPDIAM ( JDATE, JTIME, TSTEP( 1 ) )
!
! Get domain decomp info from the MET_CRO_3D file
!
         CALL SUBHFILE ( MET_CRO_3D, GXOFF, GYOFF,
     &                   STRTCOLMC3, ENDCOLMC3, STRTROWMC3, ENDROWMC3 )

C Open checkpoint file as read-only
         CALL CHK_FILE_OPEN ( ADJ_AERO_CHK, JDATE, JTIME, .FALSE. )

        end if ! first time
        mstep = TIME2SEC(tstep(2))
	    mdate = jdate
	    mtime = jtime

        CALL NEXTIME ( MDATE, MTIME, SEC2TIME( MSTEP / 2 ) )
!
!
! *** Set floating point synchronization time step:
! set time step in seconds
        dt = FLOAT(mstep)
!
! *** Get Meteorological Variables
!
! *** pressure [Pa]
        vname='PRES'
        res3 = INTERPX(met_cro_3d, vname, pname, strtcolmc3, endcolmc3,
     +    strtrowmc3, endrowmc3, 1, nlays, mdate, mtime, pres)
!
! *** temperature [K]
        vname='TA'
        res4 = INTERPX(met_cro_3d, vname, pname, strtcolmc3, endcolmc3,
     +    strtrowmc3, endrowmc3, 1, nlays, mdate, mtime, ta)
!
! *** specific humidity [g H2O/g air]
        vname='QV'
        res5 = INTERPX(met_cro_3d, vname, pname, strtcolmc3, endcolmc3,
     +    strtrowmc3, endrowmc3, 1, nlays, mdate, mtime, qv)
!
! *** air density [kg/m3]
!Write(*,'('' before aeroproc '')')
!Write(*,'(i5,g16.6)') (spc, cgrid(18, 8, 1, spc), spc=1,137)
        vname='DENS'
        res6 = INTERPX(met_cro_3d, vname, pname, strtcolmc3, endcolmc3,
     +    strtrowmc3, endrowmc3, 1, nlays, mdate, mtime, dens)

! Read concentration checkpoint at sync step
        CALL CHK_FILE_READ ( ADJ_AERO_CHK, JDATE, JTIME, CGRID )

!
! --------------------- Begin loops over grid cells --------------------------
!
! *** initialize conc arrays
!
        DO l=1,nlays
          DO r=1,my_nrows
            DO c=1,my_ncols
!
! *** Grid cell meteorological data.
              airtemp = ta(c, r, l)
              CALL PUSHREAL4(airprs)
! Note pascals
              airprs = pres(c, r, l)
              airqv = qv(c, r, l)
              airdens = dens(c, r, l)
              h2osatvp = al*EXP(bl*(airtemp-273.15)/(airtemp-273.15+cl))
              h2ovp = airprs*airqv/(epswater+airqv)
              IF (0.99 .GT. h2ovp/h2osatvp) THEN
                y1 = h2ovp/h2osatvp
              ELSE
                y1 = 0.99
              END IF
              IF (0.005 .LT. y1) THEN
                CALL PUSHREAL4(airrh)
                airrh = y1
                CALL PUSHINTEGER4(0)
              ELSE
                CALL PUSHREAL4(airrh)
                airrh = 0.005
                CALL PUSHINTEGER4(1)
              END IF
C              CALL PUSHINTEGER4ARRAY(aerospc_map, n_aerospc*n_mode)
C              CALL PUSHINTEGER4(aso4_idx)
C              CALL PUSHREAL8(h2ofac)
              CALL PUSHREAL4ARRAY(aerospc_conc, n_aerospc*n_mode)
C              CALL PUSHINTEGER4ARRAY(aerosrf_map, n_mode)
C              CALL PUSHINTEGER4(ano3_idx)
C              CALL PUSHINTEGER4(ana_idx)
C              CALL PUSHINTEGER4ARRAY(aeronum_map, n_mode)
C              CALL PUSHREAL4ARRAY(aerospc_mw, n_aerospc)
C              CALL PUSHINTEGER4(aorgpa_idx)
C              CALL PUSHINTEGER4(acors_idx)
C              CALL PUSHINTEGER4(acl_idx)
C              CALL PUSHINTEGER4(anh4_idx)
C              CALL PUSHINTEGER4(asoil_idx)
C              CALL PUSHINTEGER4(ah2o_idx)
              CALL PUSHREAL4ARRAY(moment0_conc, n_mode)
C              CALL PUSHINTEGER4(ae_strt)
              CALL EXTRACT_AERO(cgrid(c, r, l, :))
!
! *** extract grid cell concentrations of aero species from CGRID
!     into aerospc_conc in aero_data module
C              CALL PUSHINTEGER4(hcl_idx)
C              CALL PUSHINTEGER4(no2_idx)
C              CALL PUSHREAL4ARRAY(precursor_mw, n_precursor)
C              CALL PUSHINTEGER4(n2o5_idx)
              CALL PUSHREAL4ARRAY(precursor_conc, n_precursor)
C              CALL PUSHINTEGER4(nh3_idx)
C              CALL PUSHINTEGER4(sulprd_idx)
C              CALL PUSHINTEGER4(hno3_idx)
C              CALL PUSHINTEGER4ARRAY(precursor_map, n_precursor)
C              CALL PUSHINTEGER4(sulf_idx)
C              CALL PUSHINTEGER4(hono_idx)
C              CALL PUSHINTEGER4(gc_strt)
C              CALL PUSHINTEGER4(nr_strt)
              CALL EXTRACT_PRECURSOR(cgrid(c, r, l, :))
!
! *** extract grid cell concentrations of gas precursors from CGRID (ppm)
!     into precursr_conc in precursor_data
              CALL PUSHREAL4(so4rate)
!
!**   Calculate SO4RATE stored in module
              so4rate = precursor_conc(sulprd_idx)/dt
C              CALL PUSHINTEGER4(aolga_idx)
C              CALL PUSHINTEGER4(aiso3_idx)
C              CALL PUSHREAL4ARRAY(vapor_mw, n_vapor)
              CALL PUSHREAL4ARRAY(orgprod_conc, n_orgprod)
C              CALL PUSHINTEGER4(aiso2_idx)
C              CALL PUSHINTEGER4ARRAY(vapor_map, n_vapor)
C              CALL PUSHINTEGER4(aiso1_idx)
C              CALL PUSHINTEGER4(iso2_idx)
C              CALL PUSHINTEGER4ARRAY(drog_map, n_vapor)
C              CALL PUSHREAL4ARRAY(orgprod_mw, n_orgprod)
C              CALL PUSHINTEGER4(aorgc_idx)
C              CALL PUSHINTEGER4ARRAY(orgprod_map, n_orgprod)
C              CALL PUSHINTEGER4(iso1_idx)
C              CALL PUSHINTEGER4ARRAY(orgprod_aeromap, n_orgprod)
C              CALL PUSHINTEGER4(aolgb_idx)
C              CALL PUSHINTEGER4ARRAY(soa_aeromap, n_vapor)
C              CALL PUSHINTEGER4(gc_strt)
C              CALL PUSHINTEGER4(nr_strt)
              CALL EXTRACT_SOA(cgrid(c, r, l, :))
!
! *** extract soa concentrations from CGRID
              CALL PUSHREAL4ARRAY(vapor_conc, n_vapor)
              CALL PUSHREAL4ARRAY(precursor_conc, n_precursor)
              CALL PUSHREAL4ARRAY(aeromode_mass, n_mode)
              CALL PUSHREAL4ARRAY(aeromode_sdev, n_mode)
              CALL PUSHREAL4ARRAY(aerospc_conc, n_aerospc*n_mode)
              CALL PUSHREAL4ARRAY(moment3_conc, n_mode)
              CALL PUSHREAL4ARRAY(moment2_conc, n_mode)
              CALL PUSHREAL4ARRAY(moment0_conc, n_mode)
              CALL PUSHREAL4ARRAY(aeromode_diam, n_mode)
              CALL AEROPROC(dt, c, r, l, gamma_n2o5)
!
! *** aerosol process routines
              CALL PUSHREAL4ARRAY(cgrid(c, r, l, :), nspcsd)
!
! *** update aerosol variables conc back into CGRID
              CALL UPDATE_AERO(cgrid(c, r, l, :))
              CALL PUSHREAL4ARRAY(cgrid(c, r, l, :), nspcsd)
!
! *** update precursor variables conc back into CGRID
              CALL UPDATE_PRECURSOR(cgrid(c, r, l, :))
              CALL PUSHREAL4ARRAY(cgrid(c, r, l, :), nspcsd)
!
! *** update gas soa concentrations back to CGRID
              CALL UPDATE_SOA(cgrid(c, r, l, :))
              CALL PUSHREAL4(m3_wet)
!
! *** Calculate 2nd and 3rd moments of the "dry" aerosol distribution
!     NOTE! "dry" aerosol excludes both H2O and SOA  (Jan 2004 --SJR)
!     EXCEPT!  nonvolatile SOA is part of dry aerosol (Oct 2007 --PVB)
!
!     Aitken mode.
              m3_wet = moment3_conc(1)
              m3subt = 1.0e-9*f6dpi/aerospc(ah2o_idx)%density*aerospc_conc(
     +          ah2o_idx, 1)
              CALL PUSHREAL4(m3_dry)
              m3_dry = m3_wet - m3subt
              CALL PUSHREAL4(m2_wet)
              m2_wet = moment2_conc(1)
              m2_dry = m2_wet*(m3_dry/m3_wet)**twothirds
              IF (conmin .LT. m3_dry) THEN
                moment3_conc(1) = m3_dry
                CALL PUSHINTEGER4(1)
              ELSE
                moment3_conc(1) = conmin
                CALL PUSHINTEGER4(0)
              END IF
              IF (conmin .LT. m2_dry) THEN
                moment2_conc(1) = m2_dry
                CALL PUSHINTEGER4(1)
              ELSE
                moment2_conc(1) = conmin
                CALL PUSHINTEGER4(0)
              END IF
              CALL PUSHREAL4(m3_wet)
!
!     accumulation mode.
              m3_wet = moment3_conc(2)
!
              m3subt = 1.0e-9*f6dpi/aerospc(ah2o_idx)%density*aerospc_conc(
     +          ah2o_idx, 2)
              DO spc=1,n_vapor
                m3subt = m3subt + 1.0e-9*f6dpi/aerospc(aorgpa_idx)%density*
     +            aerospc_conc(soa_aeromap(spc), 2)
              END DO
              CALL PUSHREAL4(m3_dry)
!
              m3_dry = m3_wet - m3subt
              CALL PUSHREAL4(m2_wet)
              m2_wet = moment2_conc(2)
              m2_dry = m2_wet*(m3_dry/m3_wet)**twothirds
              IF (conmin .LT. m3_dry) THEN
                moment3_conc(2) = m3_dry
                CALL PUSHINTEGER4(1)
              ELSE
                moment3_conc(2) = conmin
                CALL PUSHINTEGER4(0)
              END IF
              IF (conmin .LT. m2_dry) THEN
                moment2_conc(2) = m2_dry
                CALL PUSHINTEGER4(1)
              ELSE
                moment2_conc(2) = conmin
                CALL PUSHINTEGER4(0)
              END IF
              CALL PUSHREAL4(m3_wet)
!
!     coarse mode
              m3_wet = moment3_conc(3)
              m3subt = 1.0e-9*f6dpi/aerospc(ah2o_idx)%density*aerospc_conc(
     +          ah2o_idx, 3)
              CALL PUSHREAL4(m3_dry)
              m3_dry = m3_wet - m3subt
              CALL PUSHREAL4(m2_wet)
              m2_wet = moment2_conc(3)
              m2_dry = m2_wet*(m3_dry/m3_wet)**twothirds
              IF (conmin .LT. m3_dry) THEN
                moment3_conc(3) = m3_dry
                CALL PUSHINTEGER4(1)
              ELSE
                moment3_conc(3) = conmin
                CALL PUSHINTEGER4(0)
              END IF
              IF (conmin .LT. m2_dry) THEN
                moment2_conc(3) = m2_dry
                CALL PUSHINTEGER4(1)
              ELSE
                moment2_conc(3) = conmin
                CALL PUSHINTEGER4(0)
              END IF
              CALL PUSHREAL4ARRAY(aeromode_mass, n_mode)
              CALL PUSHREAL4ARRAY(aeromode_sdev, n_mode)
              CALL PUSHREAL4ARRAY(moment3_conc, n_mode)
              CALL PUSHREAL4ARRAY(moment2_conc, n_mode)
!
! *** Calculate geometric mean diameters and standard deviations of the
!     "dry" size distribution
!
              CALL GETPAR(m3_wet_flag, limit_sg)
! WRITETIME .AND. AERDIAG
!
! *** Write dry aerosol distribution parameters to aerosol diagnostic array
!
!
! *** Calculate aerosol surface area from the dry 2nd moment.  Dry value is
!     used in transport routines.  Put aeroSrf values back to CGRID
!
              DO size1=1,n_mode
                n = aerosrf_map(size1)
                CALL PUSHREAL4(cgrid(c, r, l, n))
                cgrid(c, r, l, n) = pi*moment2_conc(size1)
              END DO
		  
C backward

		  moment2_concb = 0.0
              DO size1=n_mode,1,-1
                n = aerosrf_map(size1)
                CALL POPREAL4(cgrid(c, r, l, n))
                moment2_concb(size1) = moment2_concb(size1) + pi*cgridb(c, r, l
     +            , n)
                cgridb(c, r, l, n) = 0.0
              END DO
              CALL POPREAL4ARRAY(moment2_conc, n_mode)
              CALL POPREAL4ARRAY(moment3_conc, n_mode)
              CALL POPREAL4ARRAY(aeromode_sdev, n_mode)
              CALL POPREAL4ARRAY(aeromode_mass, n_mode)
              aerospc_concb = 0.0
              moment0_concb = 0.0
              CALL GETPAR_B(m3_wet_flag, limit_sg)
              CALL POPINTEGER4(branch)
              IF (branch .LT. 1) THEN
                moment2_concb(3) = 0.0
                m2_dryb = 0.0
              ELSE
                m2_dryb = moment2_concb(3)
                moment2_concb(3) = 0.0
              END IF
              CALL POPINTEGER4(branch)
              IF (branch .LT. 1) THEN
                moment3_concb(3) = 0.0
                m3_dryb = 0.0
              ELSE
                m3_dryb = moment3_concb(3)
                moment3_concb(3) = 0.0
              END IF
              temp1 = m3_dry/m3_wet
              IF (temp1 .LE. 0.0 .AND. (twothirds .EQ. 0.0 .OR. twothirds .NE.
     +            INT(twothirds))) THEN
                temp1b = 0.0
              ELSE
                temp1b = m2_wet*twothirds*temp1**(twothirds-1)*m2_dryb/m3_wet
              END IF
              m2_wetb = temp1**twothirds*m2_dryb
              m3_dryb = m3_dryb + temp1b
              m3_wetb = m3_dryb - temp1*temp1b
              CALL POPREAL4(m2_wet)
              moment2_concb(3) = moment2_concb(3) + m2_wetb
              CALL POPREAL4(m3_dry)
              m3subtb = -m3_dryb
              aerospc_concb(ah2o_idx, 3) = aerospc_concb(ah2o_idx, 3) + f6dpi*
     +          1.0e-9*m3subtb/aerospc(ah2o_idx)%density
              CALL POPREAL4(m3_wet)
              moment3_concb(3) = moment3_concb(3) + m3_wetb
              CALL POPINTEGER4(branch)
              IF (branch .LT. 1) THEN
                moment2_concb(2) = 0.0
                m2_dryb = 0.0
              ELSE
                m2_dryb = moment2_concb(2)
                moment2_concb(2) = 0.0
              END IF
              CALL POPINTEGER4(branch)
              IF (branch .LT. 1) THEN
                moment3_concb(2) = 0.0
                m3_dryb = 0.0
              ELSE
                m3_dryb = moment3_concb(2)
                moment3_concb(2) = 0.0
              END IF
              temp0 = m3_dry/m3_wet
              IF (temp0 .LE. 0.0 .AND. (twothirds .EQ. 0.0 .OR. twothirds .NE.
     +            INT(twothirds))) THEN
                temp0b = 0.0
              ELSE
                temp0b = m2_wet*twothirds*temp0**(twothirds-1)*m2_dryb/m3_wet
              END IF
              m2_wetb = temp0**twothirds*m2_dryb
              m3_dryb = m3_dryb + temp0b
              m3_wetb = m3_dryb - temp0*temp0b
              CALL POPREAL4(m2_wet)
              moment2_concb(2) = moment2_concb(2) + m2_wetb
              CALL POPREAL4(m3_dry)
              m3subtb = -m3_dryb
              DO spc=n_vapor,1,-1
                aerospc_concb(soa_aeromap(spc), 2) = aerospc_concb(soa_aeromap
     +            (spc), 2) + f6dpi*1.0e-9*m3subtb/aerospc(aorgpa_idx)%density
              END DO
              aerospc_concb(ah2o_idx, 2) = aerospc_concb(ah2o_idx, 2) + f6dpi*
     +          1.0e-9*m3subtb/aerospc(ah2o_idx)%density
              CALL POPREAL4(m3_wet)
              moment3_concb(2) = moment3_concb(2) + m3_wetb
              CALL POPINTEGER4(branch)
              IF (branch .LT. 1) THEN
                moment2_concb(1) = 0.0
                m2_dryb = 0.0
              ELSE
                m2_dryb = moment2_concb(1)
                moment2_concb(1) = 0.0
              END IF
              CALL POPINTEGER4(branch)
              IF (branch .LT. 1) THEN
                moment3_concb(1) = 0.0
                m3_dryb = 0.0
              ELSE
                m3_dryb = moment3_concb(1)
                moment3_concb(1) = 0.0
              END IF
              temp = m3_dry/m3_wet
              IF (temp .LE. 0.0 .AND. (twothirds .EQ. 0.0 .OR. twothirds .NE.
     +            INT(twothirds))) THEN
                tempb = 0.0
              ELSE
                tempb = m2_wet*twothirds*temp**(twothirds-1)*m2_dryb/m3_wet
              END IF
              m2_wetb = temp**twothirds*m2_dryb
              m3_dryb = m3_dryb + tempb
              m3_wetb = m3_dryb - temp*tempb
              CALL POPREAL4(m2_wet)
              moment2_concb(1) = moment2_concb(1) + m2_wetb
              CALL POPREAL4(m3_dry)
              m3subtb = -m3_dryb
              aerospc_concb(ah2o_idx, 1) = aerospc_concb(ah2o_idx, 1) + f6dpi*
     +          1.0e-9*m3subtb/aerospc(ah2o_idx)%density
              CALL POPREAL4(m3_wet)
              moment3_concb(1) = moment3_concb(1) + m3_wetb
              airdens = dens(c, r, l)
              CALL POPREAL4ARRAY(cgrid(c, r, l, :), nspcsd)
              CALL UPDATE_SOA_B(cgrid(c, r, l, :), cgridb(c, r, l, :))
              CALL POPREAL4ARRAY(cgrid(c, r, l, :), nspcsd)
              CALL UPDATE_PRECURSOR_B(cgrid(c, r, l, :), cgridb(c, r, l, :))
              CALL POPREAL4ARRAY(cgrid(c, r, l, :), nspcsd)
              CALL UPDATE_AERO_B(cgrid(c, r, l, :), cgridb(c, r, l, :))
              airtemp = ta(c, r, l)
              CALL POPREAL4ARRAY(aeromode_diam, n_mode)
              CALL POPREAL4ARRAY(moment0_conc, n_mode)
              CALL POPREAL4ARRAY(moment2_conc, n_mode)
              CALL POPREAL4ARRAY(moment3_conc, n_mode)
              CALL POPREAL4ARRAY(aerospc_conc, n_aerospc*n_mode)
              CALL POPREAL4ARRAY(aeromode_sdev, n_mode)
              CALL POPREAL4ARRAY(aeromode_mass, n_mode)
              CALL POPREAL4ARRAY(precursor_conc, n_precursor)
              CALL POPREAL4ARRAY(vapor_conc, n_vapor)
              CALL AEROPROC_B(dt, c, r, l, gamma_n2o5)
C              CALL POPINTEGER4(nr_strt)
C              CALL POPINTEGER4(gc_strt)
C              CALL POPINTEGER4ARRAY(soa_aeromap, n_vapor)
C              CALL POPINTEGER4(aolgb_idx)
C              CALL POPINTEGER4ARRAY(orgprod_aeromap, n_orgprod)
C              CALL POPINTEGER4(iso1_idx)
C              CALL POPINTEGER4ARRAY(orgprod_map, n_orgprod)
C              CALL POPINTEGER4(aorgc_idx)
C              CALL POPREAL4ARRAY(orgprod_mw, n_orgprod)
C              CALL POPINTEGER4ARRAY(drog_map, n_vapor)
C              CALL POPINTEGER4(iso2_idx)
C              CALL POPINTEGER4(aiso1_idx)
C              CALL POPINTEGER4ARRAY(vapor_map, n_vapor)
C              CALL POPINTEGER4(aiso2_idx)
              CALL POPREAL4ARRAY(orgprod_conc, n_orgprod)
C              CALL POPREAL4ARRAY(vapor_mw, n_vapor)
C              CALL POPINTEGER4(aiso3_idx)
C              CALL POPINTEGER4(aolga_idx)
              CALL EXTRACT_SOA_B(cgrid(c, r, l, :), cgridb(c, r, l, :))		  
              CALL POPREAL4(so4rate)
              precursor_concb(sulprd_idx) = precursor_concb(sulprd_idx) +
     +          so4rateb/dt
C              CALL POPINTEGER4(nr_strt)
C              CALL POPINTEGER4(gc_strt)
C              CALL POPINTEGER4(hono_idx)
C              CALL POPINTEGER4(sulf_idx)
C              CALL POPINTEGER4ARRAY(precursor_map, n_precursor)
C              CALL POPINTEGER4(hno3_idx)
C              CALL POPINTEGER4(sulprd_idx)
C              CALL POPINTEGER4(nh3_idx)
              CALL POPREAL4ARRAY(precursor_conc, n_precursor)
C              CALL POPINTEGER4(n2o5_idx)
C              CALL POPREAL4ARRAY(precursor_mw, n_precursor)
C              CALL POPINTEGER4(no2_idx)
C              CALL POPINTEGER4(hcl_idx)
              CALL EXTRACT_PRECURSOR_B(cgrid(c, r, l, :), cgridb(c, r, l, :))		  
C              CALL POPINTEGER4(ae_strt)
              CALL POPREAL4ARRAY(moment0_conc, n_mode)
C              CALL POPINTEGER4(ah2o_idx)
C              CALL POPINTEGER4(asoil_idx)
C              CALL POPINTEGER4(anh4_idx)
C              CALL POPINTEGER4(acl_idx)
C              CALL POPINTEGER4(acors_idx)
C              CALL POPINTEGER4(aorgpa_idx)
C              CALL POPREAL4ARRAY(aerospc_mw, n_aerospc)
C              CALL POPINTEGER4ARRAY(aeronum_map, n_mode)
C              CALL POPINTEGER4(ana_idx)
C              CALL POPINTEGER4(ano3_idx)
C              CALL POPINTEGER4ARRAY(aerosrf_map, n_mode)
              CALL POPREAL4ARRAY(aerospc_conc, n_aerospc*n_mode)
C              CALL POPREAL8(h2ofac)
C              CALL POPINTEGER4(aso4_idx)
C              CALL POPINTEGER4ARRAY(aerospc_map, n_aerospc*n_mode)
              CALL EXTRACT_AERO_B(cgrid(c, r, l, :), cgridb(c, r, l, :))
              CALL POPINTEGER4(branch)
              IF (branch .LT. 1) THEN
                CALL POPREAL4(airrh)
              ELSE
                CALL POPREAL4(airrh)
              END IF
              CALL POPREAL4(airprs)		  
            END DO
          END DO
        END DO
C        DO l=nlays,1,-1
C          DO r=my_nrows,1,-1
C            DO c=my_ncols,1,-1
C            END DO
C          END DO
C        END DO
      END SUBROUTINE AERO_BWD
