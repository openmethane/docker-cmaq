!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.4 (r3376) - 10 Feb 2010 17:51
!
! revised by shunliu zhao
      MODULE SOA_DEFN_B
        use SOA_DEFN
        IMPLICIT NONE
        REAL :: vapor_concb(n_vapor)
        REAL :: orgprod_concb(n_orgprod)
!
        CHARACTER(len=16), PRIVATE, SAVE :: pname='Soa_Defn_b'

      CONTAINS
!  Differentiation of extract_soa in reverse (adjoint) mode:
!   gradient     of useful results: vapor_conc orgprod_conc conc
!   with respect to varying inputs: alk_factor conc
!
!
!-----------------------------------------------------------------------
        SUBROUTINE EXTRACT_SOA_B(conc, concb)
          USE AERO_DATA_B
          USE MET_DATA
          USE CGRID_SPCS
          IMPLICIT NONE
          INCLUDE SUBST_IOPARMS
          INCLUDE SUBST_AE_SPC
          INCLUDE SUBST_NR_SPC
          INCLUDE SUBST_GC_SPC
          INCLUDE SUBST_NR_N2AE
          INCLUDE SUBST_GC_G2AE
!
! /////////////////////////////////////////////////////////////////////
!  Subroutine extract_soa extracts the required soa data
!     from the 'conc' array.
!
!  Revision History:
!     First version was coded in April 2010 by Steve Howard with
!     Prakash Bhave, Jeff Young, and Sergey Napelenok.
!
!----------------------------------------------------------------------
!
! aero species
! air and met variables
!
! Arguments:
          REAL :: conc(*)
          REAL :: concb(*)
!
! External Functions:
          INTEGER :: INDEX1
!
! Local Variables:
          CHARACTER(len=80) :: xmsg
          REAL :: gasconv
          REAL :: vtmp
          INTEGER :: n
          INTEGER :: spc
!
! Frac of CB producing SOA
          REAL :: alk_factor=1.00
!     Real :: alk_factor = 0.56      ! Frac of RADM2 HC8 producing SOA
!     Real :: alk_factor = 0.57      ! Frac of SAPRC99 ALK5 producing SOA
!
! Compute gas conversion constant
          gasconv = airdens*1.0e3/mwair
!
	    orgprod_concb(1) = alk_factor*orgprod_concb(1)
	    
          DO spc=1,n_orgprod
		 n = orgprod_map(spc)
		 if ( n .Ne. 0) then
		   if(conc( n ).GE.min_gasconc) then
		     concb(n) = concb(n) + orgprod_concb(spc)
		   end if
		   orgprod_concb(spc) = 0.0
             END IF
          END DO
	    
          DO spc=1,n_vapor
		 n = vapor_map(spc)
		 if ( n .Ne. 0) then
		    vtmp = gasconv*vapor_mw(spc)
                if(conc( n ) * vtmp.GE.min_gasconc) then
			concb(n) = concb(n) + vtmp*vapor_concb(spc)
		    end if
		    vapor_concb(spc) = 0.0
             END IF
          END DO

        END SUBROUTINE EXTRACT_SOA_B
	  
!  Differentiation of update_soa in reverse (adjoint) mode:
!   gradient     of useful results: conc
!   with respect to varying inputs: vapor_conc conc
!
!-----------------------------------------------------------------------
        SUBROUTINE UPDATE_SOA_B(conc, concb)
          USE MET_DATA
          IMPLICIT NONE
          INCLUDE SUBST_IOPARMS
!
! /////////////////////////////////////////////////////////////////////
!  Subroutine update_soa populates the 'conc' array with updated
!     SOA values.
!
!  Revision History:
!     First version was coded in April 2010 by Steve Howard with
!     Prakash Bhave, Jeff Young, and Sergey Napelenok.
!
!----------------------------------------------------------------------
!
! air and met variables
!
! Arguments:
          REAL :: conc(*)
          REAL :: concb(*)
!
! Local Variables:
          CHARACTER(len=80) :: xmsg
          REAL :: gasconv
          REAL :: vtmp
          INTEGER :: n
          INTEGER :: spc
!
! Compute gas conversion constant
          gasconv = airdens*1.0e3/mwair
!
! Copy vapor_conc back to grid cell concentrations
          vapor_concb = 0.0
          DO spc=1,n_vapor
		n = vapor_map(spc)
            IF (n .NE. 0) THEN
		  vtmp = vapor_mw(spc)*gasconv
              vapor_concb(spc) = vapor_concb(spc) + concb(n)/vtmp
              concb(n) = 0.0
            END IF
          END DO
        END SUBROUTINE UPDATE_SOA_B
!  Differentiation of orgaer in reverse (adjoint) mode:
!   gradient     of useful results: aeromode_diam moment2_conc
!                moment3_conc aerospc_conc vapor_conc
!   with respect to varying inputs: aeromode_diam moment2_conc
!                moment3_conc aerospc_conc vapor_conc orgprod_conc
!                drog_ppm2ug mw_vap_m1
!
!-----------------------------------------------------------------------
        SUBROUTINE ORGAER_B(dt, layer)
          USE AERO_DATA_B
          USE MET_DATA
          IMPLICIT NONE
!
! //////////////////////////////////////////////////////////////////
!  SUBROUTINE ORGAER5 implements several pathways for secondary
!   organic aerosol (SOA) formation, as recommended by Edney et al.
!   (2007).  These include SOA formation from isoprene, monoterpenes,
!   sesquiterpenes, long alkanes, and aromatics (incl. benzene).
!
!   Input includes the concentrations of reactive organic gases (ROG)
!   that were oxidized during the time step (ORGPROD), the vapor-phase
!   concentration of each semi-volatile organic compound, the
!   concentration of each SOA species, and the concentration of primary
!   organic aerosol (all concentrations are stored in the CBLK array).
!   Output includes updated concentrations of SOA species, vapor-phase
!   semi-volatile organic compounds, and moments of the accumulation
!   mode.  The geometric mean diameter of the accumulation mode is also
!   updated.  All SOA formation is restricted to the accumulation mode.
!
!   This code relies on 10 counter species to be incorporated in the
!   gas-phase chemical mechanisms to track the amounts of individual
!   ROG that reacted during the current time step (i.e., NPREC=10).
!   The arrays of length = NPREC are ordered as follows:
!         (1) "long" alkanes  (ALKRXN)
!         (2) low-yield aromatics, high-NOx pathway (XYLNRXN)
!         (3) low-yield aromatics, low-NOx pathway (XYLHRXN)
!         (4) high-yield aromatics, high-NOx pathway (TOLNRXN)
!         (5) high-yield aromatics, low-NOx pathway (TOLHRXN)
!         (6) benzene, high-NOx pathway (BNZNRXN)
!         (7) benzene, low-NOx pathway (BNZHRXN)
!         (8) monoterpenes (TRPRXN)
!         (9) isoprene (ISOPRXN)
!        (10) sesquiterpenes (SESQRXN)
!
!   In total, 12 organic species are allowed to partition between the
!   vapor and particulate phases (i.e., NCVAP=12). The arrays of
!   length = NCVAP are ordered as follows:
!         (1) alkane (1 semi-volatile product)
!       (2&3) low-yield aromatics, high-NOx pathway (2 products)
!       (4&5) high-yield aromatics, high-NOx pathway (2 products)
!       (6&7) benzene, high-NOx pathway (2 products)
!       (8&9) monoterpenes (2 products)
!     (10&11) isoprene (2 products)
!        (12) sesquiterpenes (1 product)
!
!   Equilibrium partitioning calculations are based on the absorptive
!   partitioning model of Pankow (1994) that was extended by Odum et
!   al. (1996).  Saturation vapor pressures (cstar) and mass-based
!   stoichiometric yield coefficients (alpha) are obtained from smog-
!   chamber studies.  Saturation vapor pressures are modified as a
!   function of temperature using eqn 6 of Sheehan & Bowman (2001).
!
!   If the pre-existing organic aerosol concentration is zero,
!   gas/particle equilibrium is established only after the organic gas
!   concentration reaches the threshold value defined in eqn 9 of
!   Schell et al. (2001).  Until this threshold value is reached,
!   organic vapors do not partition to the particle phase.  Once the
!   organic gas/particle equilibrium has been established, gas and
!   particle-phase concentrations of each condensible species are
!   calculated iteratively using a globally convergent variation of
!   Newton's method (SUBROUTINE NEWT), as described in eqn 8 of Schell
!   et al. (2001).
!
!   In addition to the various pathways of semi-volatile SOA formation
!   treated in previous versions of the model, four types of non-
!   volatile SOA are considered here:
!     (1) enhancement of isoprene-derived SOA under acidic conditions
!     (2) aromatic-derived SOA under low-NOx conditions
!     (3) oligomerization of all particle-phase semi-volatile material
!     (4) SOA formed by in-cloud oxidation  (SUBROUTINE AQCHEM)
!
!  KEY SUBROUTINES/FUNCTIONS CALLED:  NEWT
!
!  REVISION HISTORY:
!     coded August 1, 2001 by Dr. Francis S. Binkowski
!
!     Revised April 4, 2003 by Gerald Gipson to allow for evaporation
!     of organics from aerosols. Now total vapor + aerosol phase is
!     repartitioned at each time step and totorgsw ( Mo ) does not
!     include oldsoa.
!
!     Revised July 14, 2003 by Dr. Prakash V. Bhave
!     - changed cstar(2,3) from 10.103 & 90.925 to 111.11 & 1000.0
!       because smog chamber data of Kalberer et al. were collected
!       at 298 K (not 310 K, as was previously assumed)
!     - changed mw_vap(9,10) from 184 g/mol to 177 g/mol, to be
!       consistent with mwsoa_b
!     - modified threshold criteria for establishing gas/particle
!       equilibrium by removing the loose criterion involving "mtot"
!     - changed variable names to reflect that the combined vapor +
!       aerosol concentrations are now being repartitioned during
!       each time step (not just the newly formed SVOC's)
!     - added documentation and removed extraneous lines of code
!
!     Revised December 4, 2003 by Dr. Francis S. Binkowski
!     - output variables ORGRATE and ORGBRATE removed and replaced
!       by SOA_A and SOA_B, the newly equilibrated values of
!       Anthropogenic and Biogenic SOA, respectively.  These are non-
!       negative values.
!     - variable jj also removed
!
!     Revised January 8, 2004 by Dr. Prakash V. Bhave
!     - removed the output variable YIELD.  It has no physical meaning
!       after the 12/04/2003 revisions.
!
!     Revised January 12, 2004 by Dr. Chris G. Nolte
!     - for computational efficiency, modified the initial caer guess
!       used as input to NEWT.  If NEWT returns check .eq. true, then
!       NEWT is called again with a guess of caer = 0.5*ctot
!     - removed ITS parameter from NEWT call vector
!     - fixed bug where concentrations less than TOLMIN (i.e., 1.0E-12)
!       were reset to 1.0e-30
!     - removed extraneous code related to "Pandis method" of SVOC
!       partitioning when threshold criterion is not met (i.e.,
!       insufficient organic matter to establish gas/particle
!       equilibrium)  ** results unaffected by this change
!
!     Revised September 7, 2007 by Dr. Sergey L. Napelenok
!     - Replaced old SOA species (SOA_A, SOA_B) with an array of
!       precursor-specific SOA species.  Replaced OLDSOA_A and OLDSOA_B
!       with an array (OLDSOA).  Updated call vector accordingly.
!     - Deleted nole* and nbio* variables (now obsolete)
!     - Increased the dimension of several arrays to accommodate new
!       SOA precursors (benzene, sesquiterpenes) and pathways (low-NOx,
!       acid-catalyzed, oligomers, in-cloud)
!
!     Revised November 29, 2007 by Dr. Prakash V. Bhave
!     - Renamed subroutine from ORGAER3 to ORGAER5
!     - Modified M2 and M3 calculations to account for the updated
!       definition of DRY aerosol (which now includes non-volatile SOA)
!     - Updated Hvap and corresponding cstar values
!     - Added parameters for SOA from isoprene and sesquiterpenes
!     - Updated aromatic SOA scheme to include semi-volatile and non-
!       volatile products that form under high-NOx and low-NOx
!       conditions, respectively
!     - Added oligomerization process
!     - Added enhancement of isoprene SOA under acidic conditions
!
!     Revised June 2, 2008 by Dr. Prakash V. Bhave
!     - Changed h_vap of benzene SOA to match that of toluene SOA, based
!       on consultation with Dr. Ed Edney and Dr. Tad Kleindienst.
!
!     Revised June 5, 2008 by Drs. Prakash Bhave and Sergey Napelenok
!     - Simplified the code for conserving low-volatility isoprene
!       oxidation products and removed a minor bug in the acid-induced
!       isoprene SOA calculation.
!
!     Revised September 9, 2008 by Dr. Prakash V. Bhave
!     - Increased alpha values for SV_TRP1, SV_TRP2, and SV_SQT by a
!       factor of 1.3 to correct for the implicit assumption of unit
!       density in those SOA yield parameters.
!     - Reduced SOA/SOC ratio of AISO1 and AISO2 from 2.5 to 1.6, and
!       increased SOA/SOC ratio of AISO3 from 2.5 to 2.7.  Accordingly,
!       the molar masses of AISO1 and AISO2 were decreased to 96 g/mol
!       and the molar mass of AISO3 was increased to 162.
!
!  REFERENCES:
!   1. Edney, E.O., T.E. Kleindienst, M. Lewandowski, and J.H.
!      Offenberg, Updated SOA chemical mechanism for the Community
!      Multi-Scale Air Quality model, EPA 600/X-07/025, U.S. EPA,
!      Research Triangle Park, NC, 2007.
!
!   2. Pankow, J. F., An absorption model of gas/particle partitioning
!      of organic compounds in the atmosphere, Atmos. Environ., Vol 28,
!      No 2, 185-188, 1994.
!
!   3. Odum, J. R., T. Hoffmann, F. Bowman, D. Collins, R. C. Flagan,
!      and J. H. Seinfeld, Gas/particle partitioning and secondary
!      organic aerosol yields, Environ. Sci. Technol., Vol 30, No 8,
!      2580-2585, 1996.
!
!   4. Sheehan, P. E. and F. M. Bowman, Estimated effects of temperature
!      on secondary organic aerosol concentrations, Environ. Sci.
!      Technol., Vol 35, No 11, 2129-2135, 2001.
!
!   5. Schell, B., I. J. Ackermann, H. Hass, F. S. Binkowski, and
!      A. Abel, Modeling the formation of secondary organic aerosol
!      within a comprehensive air quality modeling system, J. Geophys.
!      Res., Vol 106, No D22, 28275-28293, 2001.
!
!   6. Strader, R., F. Lurmann, and S. N. Pandis, Evaluation of
!      secondary organic aerosol formation in winter, Atmos. Environ.,
!      Vol 33, 4849-4863, 1999.
!
!   7. Ng, N. L., J. H. Kroll, A. W. H. Chan, P. S. Chhabra, R. C.
!      Flagan, and J. H. Seinfeld, Secondary organic aerosol formation
!      from m-xylene, toluene, and benzene, Atmos. Chem. Phys., Vol 7,
!      3909-3922, 2007a.
!
!   8. Griffin, R. J., D. R. Cocker III, R. C. Flagan, and J. H.
!      Seinfeld, Organic aerosol formation from the oxidation of
!      biogenic hydrocarbons, J. Geophys. Res., Vol 104, No D3,
!      3555-3567, 1999.
!
!   9. Bian, F. and F. M. Bowman, Theoretical method for lumping
!      multicomponent secondary organic aerosol mixtures, Environ.
!      Sci. Technol., Vol 36, No 11, 2491-2497, 2002.
!
!  10. Offenberg, J. H., T. E. Kleindienst, M. Jaoui, M. Lewandowski,
!      and E. O. Edney, Thermal properties of secondary organic
!      aerosols, Geophys. Res. Lett., Vol 33, L03816, doi:10.1029/
!      2005GL024623, 2006.
!
!  11. Bahreini, R., M. D. Keywood, N. L. Ng, V. Varutbangkul, S. Gao,
!      R. C. Flagan, J. H. Seinfeld, D. R. Worsnop, and J. L. Jimenez,
!      Measurements of secondary organic aerosol from oxidation of
!      cycloalkenes, terpenes, and m-xylene using an Aerodyne aerosol
!      mass spectrometer, Environ. Sci. Technol., Vol 39, 5674-5688,
!      2005.
!
!  12. Alfarra, M. R., D. Paulsen, M. Gysel, A. A. Gaforth, J. Dommen,
!      A. S. H. Prevot, D. R. Worsnop, U. Baltensperger, and H. Coe,
!      A mass spectrometric study of secondary organic aerosols formed
!      from the photooxidation of anthropogenic and biogenic precursors
!      in a reaction chamber, Atmos. Chem. Phys., Vol 6, 5279-5293,
!      2006.
!
!  13. Ng, N. L., P. S. Chhabra, A. W. H. Chan, J. D. Surratt, J. H.
!      Kroll, A. J. Kwan, D. C. McCabe, P. O. Wennberg, A. Sorooshian,
!      S. M. Murphy, N. F. Dalleska, R. C. Flagan, and J. H. Seinfeld,
!      Effect of NOx level on secondary organic aerosol (SOA) formation
!      from the photooxidation of terpenes, Atmos. Chem. Phys., Vol 7,
!      5159-5174, 2007b.
!
!  14. Kostenidou, E., R. K. Pathak, and S. N. Pandis, An algorithm for
!      the calculation of secondary organic aerosol density combining
!      AMS and SMPS data, Aerosol Sci. Technol., Vol 41, 1002-1010,
!      2007.
!
!  15. Offenberg, J. H., C. W. Lewis, M. Lewandowski, M. Jaoui, T. E.
!      Kleindienst, and E. O. Edney, Contributions of toluene and
!      alpha-pinene to SOA formed in an irradiated toluene/alpha-pinene/
!      NOx/air mixture: comparison of results using 14C content and SOA
!      organic tracer methods, Environ. Sci. Technol., Vol 41, 3972-
!      3976, 2007.
!
!  16. Henze, D. K. and J. H. Seinfeld, Global secondary organic aerosol
!      from isoprene oxidation, Geophys. Res. Lett., Vol 33, L09812,
!      doi:10.1029/2006GL025976, 2006.
!
!  17. Kleindienst, T. E., M. Jaoui, M. Lewandowski, J. H. Offenberg,
!      C. W. Lewis, P. V. Bhave, and E. O. Edney, Estimates of the
!      contributions of biogenic and anthropogenic hydrocarbons to
!      secondary organic aerosol at a southeastern US location, Atmos.
!      Environ., Vol 41, 8288-8300, 2007.
!
!  18. Kalberer, M., D. Paulsen, M. Sax, M. Steinbacher, J. Dommen,
!      A. S. H. Prevot, R. Fisseha, E. Weingartner, V. Frankevich,
!      R. Zenobi, and U. Baltensperger, Identification of polymers as
!      major components of atmospheric organic aerosols, Science, Vol
!      303, 1659-1662, 2004.
!
!  19. Turpin, B. J. and H.-J. Lim, Species contributions to PM2.5 mass
!      concentrations: revisiting common assumptions for estimating
!      organic mass, Aero. Sci. Technol., Vol 35, 602-610, 2001.
!
!  20. Surratt, J. D., M. Lewandowski, J. H. Offenberg, M. Jaoui, T. E.
!      Kleindienst, E. O. Edney, and J. H. Seinfeld, Effect of acidity
!      on secondary organic aerosol formation from isoprene, Environ.
!      Sci. Technol., Vol 41, 5363-5369, 2007.
!
!
! Key Subroutines/Functions called:  newt
!
!----------------------------------------------------------------------
!
!
! Arguments:
! Synchronization time step [ s ]
          REAL :: dt
! model layer number
          INTEGER :: layer
!
! Local variables:
          LOGICAL, SAVE :: first_time=.true.
          INTEGER :: ii
!
! POA molecular weight is set to 220 g/mol, similar to a C15 compound
! Molecular weight of POA [ g/mol ]
          REAL, PARAMETER :: mwpoa=220.0
!
! Inverse MW of SVOCs [ mol/g ]
          REAL, SAVE :: mw_vap_m1(n_vapor)
          REAL, SAVE :: mw_vap_m1b(n_vapor)
!
! [ ppm per ug/m3 ] for ORGPROD at
! reference temperature and pressure
          REAL, SAVE :: drog_ppm2ug(n_orgprod)
          REAL, SAVE :: drog_ppm2ugb(n_orgprod)
!
! Parameters & variables for adjusting cstar to ambient conditions
! reference temperature [ K ]
          REAL, PARAMETER :: tref=298.0
! inverse of reference temperature
          REAL, PARAMETER :: trefm1=1.0/tref
! inverse of reference pressure
          REAL, PARAMETER :: prefm1=1.0/stdatmpa
! reciprocal of universal gas constant
          REAL, PARAMETER :: rgas1=1.0/rgasuniv
! 20h half-life of oligomerization rate [ 1/s ]
          REAL, PARAMETER :: kolig=0.69314718/72000.0
! SOA/SOC ratio for oligomers
          REAL, PARAMETER :: olgrat=2.1
! acid-induced enhancement factor
          REAL, PARAMETER :: kacid=0.00361
          REAL, PARAMETER :: orgfac=1.0e-9*f6dpi/2.0e3
! P/ RT at 1 atm and 298 K [ mole/m**3 ]
          REAL, PARAMETER :: convfac_298=101325.0*rgas1*trefm1
!
          REAL :: convfac
! temperature-related factors
          REAL :: tt1, tt2
! temperature correction factor for cstar
          REAL :: tempcorr
!
! Variables used in oligomerization calculations
! non-dimensional loss coefficient
          REAL :: expdt
! particle-phase anthropogenic SVOC [ umolC/m3 ]
          REAL :: nsvpa
          REAL :: nsvpab
! particle-phase biogenic SVOC [ umolC/m3 ]
          REAL :: nsvpb
          REAL :: nsvpbb
!
! Variables used in acid-enhanced isoprene SOA calculations
! accumulation-mode H+ conc [ nmol/m3 ]
          REAL :: hplus
          REAL :: hplusb
! particle-phase isoprene SVOC [ ug/m3 ]
          REAL :: aiso12
          REAL :: aiso12b
! vapor-phase isoprene SVOC [ ug/m3 ]
          REAL :: vviso
          REAL :: vvisob
! newly produced AISO3J [ ug/m3 ]
          REAL :: xiso3
          REAL :: xiso3b
! ratio for depletion of vapor-phase products
          REAL :: isofrac
          REAL :: isofracb
!
! Variables used in equilibrium partitioning calculations
! change in precursor conc [ ug/m3 ]
          REAL :: drog(n_orgprod)
          REAL :: drogb(n_orgprod)
! drog conc mapped to each SVOC [ ug/m3 ]
          REAL :: totrog(n_vapor)
          REAL :: totrogb(n_vapor)
! cstar at AIRTEMP [ ug/m3 ]
          REAL :: c0(n_vapor)
! SVOC conc before current time step [ ug/m3 ]
          REAL :: ctoti(n_vapor)
          REAL :: ctotib(n_vapor)
! SVOC generated during current step [ ug/m3 ]
          REAL :: prod(n_vapor)
          REAL :: prodb(n_vapor)
! SVOC conc after current time step [ ug/m3 ]
          REAL :: ctotf(n_vapor)
          REAL :: ctotfb(n_vapor)
! SVOC conc in aerosol phase [ ug/m3 ]
          REAL :: caer(n_vapor)
          REAL :: caerb(n_vapor)
! POA + non-volatile SOA [ umole/m3 ]
          REAL :: totorgsw
          REAL :: totorgswb
! SOA + POA before time step [ umole/m3 ]
          REAL :: totorg
          REAL :: totorgb
! criterion for establishing gas/part equil.
          REAL :: threshold
! small positive number
          REAL, PARAMETER :: threshmin=1.0e-19
          REAL, PARAMETER :: ctolmin=1.0e-06
! flag to indicate if NEWT subroutine
! converged to a spurious root
          LOGICAL :: check
!
! Variables for updating 2nd and 3rd moments
! initial 3rd moment minus nonvol SOA [ mom/m3 ]
          REAL :: old_m3
          REAL :: old_m3b
! initial 2nd moment minus nonvol SOA [ mom/m3 ]
          REAL :: old_m2
          REAL :: old_m2b
! final 3rd moment with updated SOA [ mom/m3 ]
          REAL :: new_m3
          REAL :: new_m3b
! final 2nd moment with updated SOA [ mom/m3 ]
          REAL :: new_m2
          REAL :: new_m2b
          INTEGER :: branch
          REAL :: temp3
          REAL :: temp2
          REAL :: y1b
          REAL :: temp1
          REAL :: temp0
          INTRINSIC EXP
          INTRINSIC MAX
          REAL :: temp3b
          REAL :: temp6b
          REAL :: tempb
          INTRINSIC MIN
          REAL :: temp1b
          INTRINSIC SQRT
          REAL :: temp
          REAL :: temp7
          REAL :: temp6
          REAL :: temp4b
          REAL :: temp5
          REAL :: y1
          REAL :: temp4
! first_time
!
!-----------------------------------------------------------------------
!
          IF (first_time) THEN
!
! Set unit conversion and inverse mw constants
!
            DO ii=1,n_orgprod
              drog_ppm2ug(ii) = orgprod_mw(ii)*convfac_298
            END DO
!
            DO ii=1,n_vapor
              mw_vap_m1(ii) = 1.0/vapor_mw(ii)
            END DO
          END IF
!
!
! Compute 3rd moment, 2nd moment, and Dg without nonvolatile SOA. Cloud-produced
! SOA (i.e., orgcj) is not subtracted here because it is unchanged in this subroutine
          old_m3 = moment3_conc(2)
          DO ii=1,n_aerospc
            IF (.NOT.aerospc(ii)%volatile .AND. ii .NE. aorgc_idx) THEN
              old_m3 = old_m3 - orgfac*aerospc_conc(ii, 2)
              CALL PUSHINTEGER4(2)
            ELSE
              CALL PUSHINTEGER4(1)
            END IF
          END DO
!
          old_m2 = moment2_conc(2)*(old_m3/moment3_conc(2))**(2.0/3.0)
          CALL PUSHREAL4(aeromode_diam(2))
          aeromode_diam(2) = aeromode_diam(2)*SQRT(old_m2/moment2_conc(2))
!
! Set temperature factors
          tt1 = tref/airtemp
          tt2 = trefm1 - 1.0/airtemp
          convfac = tt1*airprs*prefm1
!
! Initialize drog from ORGPROD and change units to [ ug / m**3 ]
          DO ii=1,n_orgprod
            drog(ii) = orgprod_conc(ii)*drog_ppm2ug(ii)*convfac
          END DO
!
! Assignment of drog to totrog
          DO ii=1,n_vapor
            totrog(ii) = drog(drog_map(ii))
          END DO
!
! Transfer non-volatile products directly to aerospc_conc array
          DO ii=1,n_orgprod
            IF (orgprod_aeromap(ii) .GT. 0) THEN
              CALL PUSHREAL4(aerospc_conc(orgprod_aeromap(ii), 2))
              aerospc_conc(orgprod_aeromap(ii), 2) = aerospc_conc(
     +          orgprod_aeromap(ii), 2) + orgprod(ii)%alphah*drog(ii)
              CALL PUSHINTEGER4(2)
            ELSE
              CALL PUSHINTEGER4(1)
            END IF
          END DO
!
! Oligomerization
!
! Convert semi-volatile SOA to non-volatile oligomers by an exponential decay
! process that conserves carbon mass.
!
          nsvpa = 0.0
          nsvpb = 0.0
!
          DO ii=1,n_vapor
            IF (vaporspc(ii)%soa_origin .EQ. 'A') THEN
              nsvpa = nsvpa + aerospc_conc(soa_aeromap(ii), 2)*mw_vap_m1(ii)*
     +          vaporspc(ii)%soa_decay
              CALL PUSHINTEGER4(1)
            ELSE
              CALL PUSHINTEGER4(0)
            END IF
            IF (vaporspc(ii)%soa_origin .EQ. 'B') THEN
              nsvpb = nsvpb + aerospc_conc(soa_aeromap(ii), 2)*mw_vap_m1(ii)*
     +          vaporspc(ii)%soa_decay
              CALL PUSHINTEGER4(2)
            ELSE
              CALL PUSHINTEGER4(1)
            END IF
          END DO
!
          expdt = EXP(-(kolig*dt))
!
          DO ii=1,n_vapor
            CALL PUSHREAL4(aerospc_conc(soa_aeromap(ii), 2))
            aerospc_conc(soa_aeromap(ii), 2) = aerospc_conc(soa_aeromap(ii), 2
     +        )*expdt
          END DO
          CALL PUSHREAL4(aerospc_conc(aolga_idx, 2))
!
          aerospc_conc(aolga_idx, 2) = aerospc_conc(aolga_idx, 2) + 12.0*nsvpa
     +      *(1.0-expdt)*olgrat
          CALL PUSHREAL4(aerospc_conc(aolgb_idx, 2))
          aerospc_conc(aolgb_idx, 2) = aerospc_conc(aolgb_idx, 2) + 12.0*nsvpb
     +      *(1.0-expdt)*olgrat
!
! Compute molar concentrations of non-volatile organic material and total organic
! material; in future code updates, molecular weights of non-volatile SOA species
! should be inherited from the include files to avoid hard-coded values.
!
          totorgsw = (aerospc_conc(aorgpa_idx, 1)+aerospc_conc(aorgpa_idx, 2))
     +      /mwpoa
          DO ii=1,n_aerospc
            IF (.NOT.aerospc(ii)%volatile) THEN
              totorgsw = totorgsw + aerospc_conc(ii, 2)/aerospc_mw(ii)
              CALL PUSHINTEGER4(2)
            ELSE
              CALL PUSHINTEGER4(1)
            END IF
          END DO
!
          totorg = totorgsw
          DO ii=1,n_vapor
            totorg = totorg + aerospc_conc(soa_aeromap(ii), 2)*mw_vap_m1(ii)
          END DO
!
! Initialize ctoti as sum of vapor-phase and particle-phase SVOCs
! Note: all of these CBLK species are in [ug/m**3]
          DO ii=1,n_vapor
            ctoti(ii) = vapor_conc(ii) + aerospc_conc(soa_aeromap(ii), 2)
          END DO
!
! Equilibrium Partitioning Calculations
!
! Initial guess of caer is computed as follows:
!    From eqn (8) of Schell et al. (2001)
!    caer = ctotf - c0 * (caer/MW) / totorg
!    Assuming totorg doesn't change during the timestep,
!    caer * (1 + c0/MW / totorg) = ctotf
!    caer = ctotf / ( 1 + c0/MW / totorg)
!
          threshold = 0.0
          DO ii=1,n_vapor
            tempcorr = tt1*EXP(vaporspc(ii)%enth*rgas1*tt2)
            c0(ii) = vaporspc(ii)%cstar*tempcorr
            prod(ii) = vaporspc(ii)%alpha*totrog(ii)
            ctotf(ii) = ctoti(ii) + prod(ii)
            threshold = threshold + ctotf(ii)/c0(ii)
! initial
! guess
            caer(ii) = ctotf(ii)*totorg/(totorg+c0(ii)*mw_vap_m1(ii))
          END DO
! check on equilibrium threshold
!
! Check If gas/particle equilibrium can be established
          IF (threshold .GT. 1.0 .OR. totorgsw .GT. threshmin) THEN
!
! Calculate new SOA by partitioning. This method uses a globally convergent
! Newton-Raphson method coded by Dr Benedikt Schell to solve the nonlinear
! quadratic system shown in eqn 8 of Schell et al:
!    A(i)  * caer(i) ** 2 + B * caer(i) + C(i) = 0.0,
!    where B(i) contains the sum of all caer(j), for j not equal to i.
! 
            CALL NEWT(layer, caer, n_vapor, check, ctotf, c0, mw_vap_m1,
     +          totorgsw)
            CALL PUSHREAL4ARRAY(caer, 12)

            IF (check) THEN
! Try again with initial guess of 50/50 gas/aerosol split.
              DO ii=1,n_vapor
                caer(ii) = 0.5*ctotf(ii)
              END DO
              CALL NEWT(layer, caer, n_vapor, check, ctotf, c0, mw_vap_m1,
     +            totorgsw)
              CALL PUSHREAL4ARRAY(caer, 12)
              CALL PUSHINTEGER4(1)
            ELSE
              CALL PUSHINTEGER4(0)
            END IF
!
! Constrain caer to values between conmin and ctotf
            DO ii=1,n_vapor
!
              IF (caer(ii) .LT. conmin) THEN
                caer(ii) = conmin
                CALL PUSHINTEGER4(1)
              ELSE
                CALL PUSHINTEGER4(0)
              END IF
!
              IF (caer(ii) - ctotf(ii) .GT. ctolmin) THEN
                caer(ii) = ctotf(ii)
                CALL PUSHINTEGER4(3)
              ELSE
                CALL PUSHINTEGER4(2)
              END IF
            END DO
            CALL PUSHINTEGER4(0)
          ELSE
!
!
! threshold not exceeded; no material transferred to aerosol phase
!
            caer = 0.0
!
            CALL PUSHINTEGER4(1)
          END IF
!
! Transfer particle-phase SOA and vapor-phase SVOCs back to CBLK
          DO ii=1,n_vapor
            CALL PUSHREAL4(aerospc_conc(soa_aeromap(ii), 2))
            aerospc_conc(soa_aeromap(ii), 2) = caer(ii)
            vapor_conc(ii) = ctotf(ii) - caer(ii)
          END DO
!
! Acid-induced Isoprene SOA
!
! Particle-phase acidity is parameterized by the air concentration of hydrogen ion
! in the particle phase (hplus).  This is computed by electroneutrality, and is
! bounded so that it cannot fall below zero (acid-neutral) nor above the range of
! experimental conditions (530 nmol/m3) tested by Surratt et al. (2007).  In future
! code updates, molecular weights of inorganic ions should be inherited from include
! files to avoid hard-coded values.
!
          hplus = 0.0
          DO ii=1,n_aerospc
            hplus = hplus - 1000.0*aerospc(ii)%charge*aerospc_conc(ii, 2)/
     +        aerospc_mw(ii)
          END DO
          IF (0.0 .LT. hplus) THEN
            y1 = hplus
            CALL PUSHINTEGER4(1)
          ELSE
            y1 = 0.0
            CALL PUSHINTEGER4(0)
          END IF
          IF (530.0 .GT. y1) THEN
            hplus = y1
            CALL PUSHINTEGER4(0)
          ELSE
            hplus = 530.0
            CALL PUSHINTEGER4(1)
          END IF
!
! Compute amount of acid-enhanced isoprene SOA that is produced during the current
! time step (xiso3) using the normalized expression derived from Surratt et al. (2007)
!
          aiso12 = aerospc_conc(aiso1_idx, 2) + aerospc_conc(aiso2_idx, 2)
          xiso3 = kacid*hplus*aiso12 - aerospc_conc(aiso3_idx, 2)
!
! Update CBLK(VISO3J) while conserving the total concentration of low-volatility
! isoprene-derived products.  Since the acid-enhanced product is assumed to be
! non-volatile, only positive values of xiso3 are considered below.  Also, xiso3
! is not allowed to exceed the vapor-phase concentration of isoprene SVOC.  We assume
! the xiso3 mass is depleted from the 2 vapor-phase isoprene products in quantities
! proportional to their equilibrium concentrations.  The factor of 2.7/1.6 accounts
! for the enhancement in the OM/OC ratio when isoprene SOA is formed in the presence
! of SO2, based on the lab experiments of Kleindienst et al. (2007)
!
          IF (xiso3 .GT. 0.0) THEN
            vviso = vapor_conc(iso1_idx) + vapor_conc(iso2_idx)
            IF (xiso3 .GT. vviso) THEN
              xiso3 = vviso
              CALL PUSHINTEGER4(1)
            ELSE
              CALL PUSHINTEGER4(0)
              xiso3 = xiso3
            END IF
            CALL PUSHREAL4(aerospc_conc(aiso3_idx, 2))
            aerospc_conc(aiso3_idx, 2) = aerospc_conc(aiso3_idx, 2) + xiso3*(
     +        2.7/1.6)
            isofrac = aerospc_conc(soa_aeromap(iso1_idx), 2)/vviso
            CALL PUSHINTEGER4(1)
          ELSE
            CALL PUSHINTEGER4(0)
          END IF
!
! Update 3rd moment, 2nd moment, and Dg in CBLK array by assuming that SOA
! condensation/evaporation does not affect the geometric standard deviation.
!
          new_m3 = old_m3
!
          DO ii=1,n_aerospc
            IF (.NOT.aerospc(ii)%volatile .AND. ii .NE. aorgc_idx) THEN
              new_m3 = new_m3 + orgfac*aerospc_conc(ii, 2)
              CALL PUSHINTEGER4(2)
            ELSE
              CALL PUSHINTEGER4(1)
            END IF
          END DO
!
          DO ii=1,n_vapor
            new_m3 = new_m3 + orgfac*aerospc_conc(soa_aeromap(ii), 2)
          END DO
!
          new_m2 = old_m2*(new_m3/old_m3)**(2.0/3.0)
!
!
          temp6 = new_m2/old_m2
          temp7 = SQRT(temp6)
          IF (temp6 .EQ. 0.0) THEN
            temp6b = 0.0
          ELSE
            temp6b = aeromode_diam(2)*aeromode_diamb(2)/(2.0*temp7*old_m2)
          END IF
          new_m2b = moment2_concb(2) + temp6b
          temp5 = 2.0/3.0
          temp4 = new_m3/old_m3
          old_m2b = temp4**temp5*new_m2b - temp6*temp6b
          aeromode_diamb(2) = temp7*aeromode_diamb(2)
          moment2_concb(2) = 0.0
          IF (temp4 .LE. 0.0 .AND. (temp5 .EQ. 0.0 .OR. temp5 .NE. INT(temp5))
     +    ) THEN
            temp4b = 0.0
          ELSE
            temp4b = old_m2*temp5*temp4**(temp5-1)*new_m2b/old_m3
          END IF
          new_m3b = temp4b + moment3_concb(2)
          moment3_concb(2) = 0.0
          old_m3b = -(temp4*temp4b)
          DO ii=n_vapor,1,-1
            aerospc_concb(soa_aeromap(ii), 2) = aerospc_concb(soa_aeromap(ii)
     +        , 2) + orgfac*new_m3b
          END DO
          DO ii=n_aerospc,1,-1
            CALL POPINTEGER4(branch)
            IF (.NOT.branch .LT. 2) aerospc_concb(ii, 2) = aerospc_concb(ii, 2
     +          ) + orgfac*new_m3b
          END DO
          old_m3b = old_m3b + new_m3b
          CALL POPINTEGER4(branch)
          IF (branch .LT. 1) THEN
            xiso3b = 0.0
          ELSE
            isofracb = xiso3*vapor_concb(iso2_idx) - xiso3*vapor_concb(
     +        iso1_idx)
            aerospc_concb(soa_aeromap(iso1_idx), 2) = aerospc_concb(
     +        soa_aeromap(iso1_idx), 2) + isofracb/vviso
            xiso3b = 2.7*aerospc_concb(aiso3_idx, 2)/1.6 - isofrac*vapor_concb
     +        (iso1_idx) - (1.0-isofrac)*vapor_concb(iso2_idx)
            vvisob = -(aerospc_conc(soa_aeromap(iso1_idx), 2)*isofracb/vviso**
     +        2)
            CALL POPREAL4(aerospc_conc(aiso3_idx, 2))
            CALL POPINTEGER4(branch)
            IF (.NOT.branch .LT. 1) THEN
              vvisob = vvisob + xiso3b
              xiso3b = 0.0
            END IF
            vapor_concb(iso1_idx) = vapor_concb(iso1_idx) + vvisob
            vapor_concb(iso2_idx) = vapor_concb(iso2_idx) + vvisob
          END IF
          hplusb = kacid*aiso12*xiso3b
          aiso12b = kacid*hplus*xiso3b
          aerospc_concb(aiso3_idx, 2) = aerospc_concb(aiso3_idx, 2) - xiso3b
          aerospc_concb(aiso1_idx, 2) = aerospc_concb(aiso1_idx, 2) + aiso12b
          aerospc_concb(aiso2_idx, 2) = aerospc_concb(aiso2_idx, 2) + aiso12b
          CALL POPINTEGER4(branch)
          IF (branch .LT. 1) THEN
            y1b = hplusb
          ELSE
            y1b = 0.0
          END IF
          CALL POPINTEGER4(branch)
          IF (branch .LT. 1) THEN
            hplusb = 0.0
          ELSE
            hplusb = y1b
          END IF
          DO ii=n_aerospc,1,-1
            aerospc_concb(ii, 2) = aerospc_concb(ii, 2) - aerospc(ii)%charge*
     +        1000.0*hplusb/aerospc_mw(ii)
          END DO
          ctotfb = 0.0
          caerb = 0.0
	    
          DO ii=n_vapor,1,-1
            ctotfb(ii) = ctotfb(ii) + vapor_concb(ii)
            caerb(ii) = caerb(ii) + aerospc_concb(soa_aeromap(ii), 2) -
     +        vapor_concb(ii)
            vapor_concb(ii) = 0.0
            CALL POPREAL4(aerospc_conc(soa_aeromap(ii), 2))
            aerospc_concb(soa_aeromap(ii), 2) = 0.0
          END DO
	    
          CALL POPINTEGER4(branch)
          IF (branch .LT. 1) THEN
            DO ii=n_vapor,1,-1
              CALL POPINTEGER4(branch)
              IF (.NOT.branch .LT. 3) THEN
                ctotfb(ii) = ctotfb(ii) + caerb(ii)
                caerb(ii) = 0.0
              END IF
              CALL POPINTEGER4(branch)
              IF (.NOT.branch .LT. 1) caerb(ii) = 0.0
            END DO
            CALL POPINTEGER4(branch)
            IF (branch .LT. 1) THEN
              totorgswb = 0.0
            ELSE
              CALL POPREAL4ARRAY(caer, 12)
              totorgswb = 0.0
	    
              CALL NEWT_B(layer, caer, caerb, n_vapor, check, ctotf, ctotfb,
     +              c0, mw_vap_m1, totorgsw, totorgswb)

              DO ii=n_vapor,1,-1
                ctotfb(ii) = ctotfb(ii) + 0.5*caerb(ii)
                caerb(ii) = 0.0
              END DO
            END IF
            CALL POPREAL4ARRAY(caer, 12)

            CALL NEWT_B(layer, caer, caerb, n_vapor, check, ctotf, ctotfb, c0
     +            , mw_vap_m1, totorgsw, totorgswb)
          ELSE
            totorgswb = 0.0
            caerb = 0.0
          END IF
          totrogb = 0.0
          ctotib = 0.0
          totorgb = 0.0
          prodb = 0.0
	    
          DO ii=n_vapor,1,-1
            temp3 = c0(ii)*mw_vap_m1(ii) + totorg
            temp3b = caerb(ii)/temp3
            ctotfb(ii) = ctotfb(ii) + totorg*temp3b
            totorgb = totorgb + (ctotf(ii)-ctotf(ii)*totorg/temp3)*temp3b
            caerb(ii) = 0.0
            ctotib(ii) = ctotib(ii) + ctotfb(ii)
            prodb(ii) = prodb(ii) + ctotfb(ii)
            ctotfb(ii) = 0.0
            totrogb(ii) = totrogb(ii) + vaporspc(ii)%alpha*prodb(ii)
            prodb(ii) = 0.0
          END DO
          DO ii=n_vapor,1,-1
            vapor_concb(ii) = vapor_concb(ii) + ctotib(ii)
            aerospc_concb(soa_aeromap(ii), 2) = aerospc_concb(soa_aeromap(ii)
     +        , 2) + ctotib(ii)
            ctotib(ii) = 0.0
          END DO
          DO ii=n_vapor,1,-1
            aerospc_concb(soa_aeromap(ii), 2) = aerospc_concb(soa_aeromap(ii)
     +        , 2) + mw_vap_m1(ii)*totorgb
          END DO
          totorgswb = totorgswb + totorgb
          DO ii=n_aerospc,1,-1
            CALL POPINTEGER4(branch)
            IF (.NOT.branch .LT. 2) aerospc_concb(ii, 2) = aerospc_concb(ii, 2
     +          ) + totorgswb/aerospc_mw(ii)
          END DO
          aerospc_concb(aorgpa_idx, 1) = aerospc_concb(aorgpa_idx, 1) +
     +      totorgswb/mwpoa
          aerospc_concb(aorgpa_idx, 2) = aerospc_concb(aorgpa_idx, 2) +
     +      totorgswb/mwpoa
          CALL POPREAL4(aerospc_conc(aolgb_idx, 2))
          nsvpbb = olgrat*12.0*(1.0-expdt)*aerospc_concb(aolgb_idx, 2)
          CALL POPREAL4(aerospc_conc(aolga_idx, 2))
          nsvpab = olgrat*12.0*(1.0-expdt)*aerospc_concb(aolga_idx, 2)
          DO ii=n_vapor,1,-1
            CALL POPREAL4(aerospc_conc(soa_aeromap(ii), 2))
            aerospc_concb(soa_aeromap(ii), 2) = expdt*aerospc_concb(
     +        soa_aeromap(ii), 2)
          END DO
          DO ii=n_vapor,1,-1
            CALL POPINTEGER4(branch)
            IF (.NOT.branch .LT. 2) aerospc_concb(soa_aeromap(ii), 2) =
     +          aerospc_concb(soa_aeromap(ii), 2) + mw_vap_m1(ii)*vaporspc(ii)
     +          %soa_decay*nsvpbb
            CALL POPINTEGER4(branch)
            IF (.NOT.branch .LT. 1) aerospc_concb(soa_aeromap(ii), 2) =
     +          aerospc_concb(soa_aeromap(ii), 2) + mw_vap_m1(ii)*vaporspc(ii)
     +          %soa_decay*nsvpab
          END DO
          drogb = 0.0

          DO ii=n_orgprod,1,-1
            CALL POPINTEGER4(branch)
            IF (.NOT.branch .LT. 2) THEN
              CALL POPREAL4(aerospc_conc(orgprod_aeromap(ii), 2))
              drogb(ii) = drogb(ii) + orgprod(ii)%alphah*aerospc_concb(
     +          orgprod_aeromap(ii), 2)
            END IF
          END DO
          DO ii=n_vapor,1,-1
            drogb(drog_map(ii)) = drogb(drog_map(ii)) + totrogb(ii)
            totrogb(ii) = 0.0
          END DO

          orgprod_concb = 0.0
          DO ii=n_orgprod,1,-1
            orgprod_concb(ii) = orgprod_concb(ii) + drog_ppm2ug(ii)*convfac*
     +        drogb(ii)
            drogb(ii) = 0.0
          END DO	

          CALL POPREAL4(aeromode_diam(2))
          temp1 = old_m2/moment2_conc(2)
          temp2 = SQRT(temp1)
          IF (temp1 .EQ. 0.0) THEN
            temp1b = 0.0
          ELSE
            temp1b = aeromode_diam(2)*aeromode_diamb(2)/(2.0*temp2*
     +        moment2_conc(2))
          END IF
          old_m2b = old_m2b + temp1b
          temp0 = 2.0/3.0
          temp = old_m3/moment3_conc(2)
          moment2_concb(2) = moment2_concb(2) + temp**temp0*old_m2b - temp1*
     +      temp1b
          aeromode_diamb(2) = temp2*aeromode_diamb(2)
          IF (temp .LE. 0.0 .AND. (temp0 .EQ. 0.0 .OR. temp0 .NE. INT(temp0))
     +    ) THEN
            tempb = 0.0
          ELSE
            tempb = moment2_conc(2)*temp0*temp**(temp0-1)*old_m2b/moment3_conc
     +        (2)
          END IF
          old_m3b = old_m3b + tempb
          moment3_concb(2) = moment3_concb(2) - temp*tempb
          DO ii=n_aerospc,1,-1
            CALL POPINTEGER4(branch)
            IF (.NOT.branch .LT. 2) aerospc_concb(ii, 2) = aerospc_concb(ii, 2
     +          ) - orgfac*old_m3b
          END DO
          moment3_concb(2) = moment3_concb(2) + old_m3b
          drog_ppm2ugb = 0.0
          mw_vap_m1b = 0.0
        END SUBROUTINE ORGAER_B
!  Differentiation of newt in reverse (adjoint) mode:
!   gradient     of useful results: m x ctot minitw
!   with respect to varying inputs: x ctot minitw
!
!-----------------------------------------------------------------------
        SUBROUTINE NEWT_B(layer, x, xb, n, check, ctot, ctotb, csat, imwcv,
     +    minitw, minitwb)
          IMPLICIT NONE
          INTEGER :: layer,n
          REAL :: x(n),xb(n)
          LOGICAL :: check
          REAL :: ctot(n),ctotb(n),csat(n),imwcv(n)
          REAL :: minitw,minitwb
          INTEGER :: nn
          REAL :: fvec
          COMMON /newtv/ fvec(n_vapor), nn
	    real:: fvecb(n_vapor)
          SAVE /newtv/
          INTEGER, PARAMETER :: maxits=100
          REAL, PARAMETER :: tolf=1.0e-9
          REAL, PARAMETER :: tolmin=1.0e-12
          REAL, PARAMETER :: tolx=1.0e-10
          REAL, PARAMETER :: stpmx=100.0

          REAL :: ct,cs,imw,m,ctb(n_vapor),mb
          COMMON /newtinp/ ct(n_vapor), cs(n_vapor), imw(n_vapor), m
          SAVE /newtinp/
          INTEGER :: i, its, j, indx(n)
          REAL :: d, den, f, fold, stpmax, sum, temp, test
          REAL :: fb, foldb, stpmaxb, sumb
          REAL :: fjac(n, n)
          REAL :: g(n), p(n), xold(n)
          INTEGER :: branch
          REAL :: gb(n_vapor)
          INTRINSIC MAX
          REAL :: fjacb(n_vapor, n_vapor)
          REAL :: x3
          INTRINSIC ABS
          REAL :: x2,pb(n_vapor)
          REAL*8 :: x1
          INTRINSIC FLOAT
          REAL*8 :: max1b,x1b
          REAL :: abs4,abs3,abs2,abs1
          INTEGER :: ii2,ii1
          INTRINSIC SQRT
          REAL :: max3,xoldb(n_vapor), max2
          REAL*8 :: max1
          REAL*8 :: y1
C-----------------------------------------------------------------------
          m = minitw
	    DO i=1,n
            ct(i) = ctot(i)
            cs(i) = csat(i)
            imw(i) = imwcv(i)
          END DO
	    
          CALL FMINV(x, f)

!Calculate STPMAX for line searches
          sum = 0.
          DO i=1,n
            sum = sum + x(i)**2
          END DO
          x1 = SQRT(sum)
          y1 = FLOAT(n)
          IF (x1 .LT. y1) THEN
            max1 = y1
            CALL PUSHINTEGER4(1)
          ELSE
            max1 = x1
            CALL PUSHINTEGER4(0)
          END IF
          stpmax = stpmx*max1

          CALL FDJAC(n, x, fjac)
	    
!store X
          DO i=1,n
             xold(i) = x(i)
          END DO
!store F
!right-hand side for linear equations
          DO i=1,n
             p(i) = -fvec(i)
          END DO
	    
          CALL PUSHREAL4ARRAY(fjac, n**2)
          CALL LUDCMP(fjac, n, indx, d)
          CALL PUSHREAL4ARRAY(p, n)
!solve linear equations by LU decomposition
          CALL LUBKSB(fjac, n, indx, p)
          CALL LNSRCH_B(ctot, ctotb, n, xold, xoldb, fold, g, p, pb, x, xb, f
     &            , stpmax, stpmaxb, tolx, check)
           CALL POPREAL4ARRAY(p, n)
		CALL LUBKSB_B(fjac, fjacb, n, indx, p, pb)
            CALL POPREAL4ARRAY(fjac, n**2)
            CALL LUDCMP_B(fjac, fjacb, n, indx, d)
		DO ii1=1,n
              fvecb(ii1) = 0.0
            END DO
		
	     DO i=n,1,-1
             fvecb(i) = fvecb(i) - pb(i)
           pb(i) = 0.0
        END DO
	  
	      DO i=n,1,-1
            xb(i) = xb(i) + xoldb(i)
            xoldb(i) = 0.0
         END DO
    
            CALL FDJAC_B(n, x, xb, ct, ctb, cs, imw, m, mb, fjac, fjacb)
            max1b = stpmx*stpmaxb
            CALL POPINTEGER4(branch)
            IF (branch .LT. 1) THEN
              x1b = max1b
            ELSE
              x1b = 0.0_8
            END IF
            IF (sum .EQ. 0.0) THEN
              sumb = 0.0
            ELSE
              sumb = x1b/(2.0*SQRT(sum))
            END IF

            DO i=n,1,-1
              xb(i) = xb(i) + 2*x(i)*sumb
            END DO

          CALL FMINV_B(n, x, xb, ct, ctb, cs, imw, m, mb, fvec, fvecb, f)
	    DO i=n,1,-1
            ctotb(i) = ctotb(i) + ctb(i)
            ctb(i) = 0.0
             END DO
          minitwb = minitwb + mb
        END SUBROUTINE NEWT_B

!  Differentiation of fdjac in reverse (adjoint) mode:
!   gradient     of useful results: x fjac
!   with respect to varying inputs: m x ct
!-----------------------------------------------------------------------
      SUBROUTINE FDJAC_B(n, x, xb, ct, ctb, cs, imw, m, mb, fjac, fjacb)
      IMPLICIT NONE
!
! dimension of problem
      INTEGER :: n
! initial guess of CAER
      REAL :: x(n)
      REAL :: xb(n)
!
      REAL :: ct(n)
      REAL :: ctb(n)
      REAL :: cs(n)
      REAL :: imw(n)
      REAL :: m
      REAL :: mb
!
      REAL :: fjac(n, n)
      REAL :: fjacb(n, n)
!
! loop index
      INTEGER :: i, j
      REAL :: a(n)
      REAL :: b(n)
      REAL :: b1
      REAL :: b1b
      REAL :: b2
      REAL :: b2b
      REAL :: sum_jnei
      REAL :: sum_jneib
      INTEGER :: branch
      REAL :: bb(n_vapor)
      INTEGER :: ii1
!
      DO i=1,n
        a(i) = imw(i)
      END DO
      DO j=1,n
        DO i=1,n
          IF (i .EQ. j) THEN
            CALL PUSHINTEGER4(1)
          ELSE
	      CALL PUSHINTEGER4(2)
          END IF
        END DO
      END DO
      DO ii1=1,n
        ctb(ii1) = 0.0
      END DO
      DO ii1=1,n
        bb(ii1) = 0.0
	END DO
      DO j=n,1,-1
        DO i=n,1,-1
          CALL POPINTEGER4(branch)
          IF (branch .LT. 2) THEN
            xb(i) = xb(i) + a(i)*2.*fjacb(i, j)
            bb(i) = bb(i) + fjacb(i, j)
            fjacb(i, j) = 0.0
          ELSE
            xb(i) = xb(i) + imw(j)*fjacb(i, j)
            ctb(i) = ctb(i) - imw(j)*fjacb(i, j)
            fjacb(i, j) = 0.0
          END IF
        END DO
      END DO
      mb = 0.0
      DO i=n,1,-1
        b1b = bb(i)
        b2b = bb(i)
        bb(i) = 0.0
        ctb(i) = ctb(i) - imw(i)*b2b
        mb = mb + b2b
        sum_jneib = b1b
        xb(i) = xb(i) - imw(i)*b1b
        DO j=n,1,-1
          xb(j) = xb(j) + imw(j)*sum_jneib
        END DO
      END DO
      END SUBROUTINE FDJAC_B
!  Differentiation of lnsrch in reverse (adjoint) mode:
!   gradient     of useful results: f g p x xold ctot stpmax /newtinp/[0,4[
!   with respect to varying inputs: fold g p x xold ctot stpmax
!                /newtinp/[0,4[
!-----------------------------------------------------------------------
      SUBROUTINE LNSRCH_B(ctot, ctotb, n, xold, xoldb, fold, g, p, pb, x, xb
     &     , f, stpmax, stpmaxb, tolx, check)
      IMPLICIT NONE
!
      INTEGER :: n
      REAL :: tolx
      LOGICAL :: check
      REAL :: f, fold, stpmax
      REAL :: stpmaxb
      REAL :: g(n), p(n), x(n), xold(n)
      REAL :: pb(n), xb(n), xoldb(n)
      REAL :: ctot(n)
      REAL :: ctotb(n)
      REAL :: alf
      PARAMETER (alf=1.e-04)
      REAL :: conmin
      PARAMETER (conmin=1.e-30)
!
      INTEGER :: i
      REAL :: a, alam, alam2, alamin, b, disc
      REAL :: f2, fold2, rhs1, rhs2, slope
       REAL :: sum, temp, test, tmplam
      REAL :: sumb
      INTEGER :: branch
      REAL :: temp0b
      INTRINSIC MAX
      INTRINSIC ABS
      REAL :: x1
      REAL :: abs1
      INTEGER :: ii1
      INTRINSIC SQRT
      REAL :: max1
!
      sum = 0.
      DO i=1,n
        sum = sum + p(i)*p(i)
      END DO
      CALL PUSHREAL4(sum)
      sum = SQRT(sum)
      IF (sum .GT. stpmax) THEN
        DO i=1,n
          CALL PUSHREAL4(p(i))
          p(i) = p(i)*stpmax/sum
        END DO
        CALL PUSHINTEGER4(1)
      ELSE
        CALL PUSHINTEGER4(0)
      END IF
      alam = 1.
!
      DO i=1,n
        CALL PUSHREAL4(x(i))
        x(i) = xold(i) + alam*p(i)
        IF (x(i) .LE. 0.) THEN
          x(i) = conmin
          CALL PUSHINTEGER4(1)
        ELSE
	    CALL PUSHINTEGER4(0)
        END IF
        IF (x(i) .GT. ctot(i)) THEN
          CALL PUSHINTEGER4(3)
        ELSE
          CALL PUSHINTEGER4(2)
        END IF
      END DO
      DO ii1=1,n
        pb(ii1) = 0.0
      END DO
      DO ii1=1,n
        xoldb(ii1) = 0.0
      END DO
      DO i=n,1,-1
        CALL POPINTEGER4(branch)
        IF (.NOT.branch .LT. 3) THEN
          ctotb(i) = ctotb(i) + xb(i)
          xb(i) = 0.0
        END IF
        CALL POPINTEGER4(branch)
        IF (.NOT.branch .LT. 1) xb(i) = 0.0
        CALL POPREAL4(x(i))
        xoldb(i) = xoldb(i) + xb(i)
        pb(i) = pb(i) + alam*xb(i)
        xb(i) = 0.0
      END DO
      CALL POPINTEGER4(branch)
      IF (branch .LT. 1) THEN
        stpmaxb = 0.0
        sumb = 0.0
      ELSE
        stpmaxb = 0.0
        sumb = 0.0
        DO i=n,1,-1
          CALL POPREAL4(p(i))
          temp0b = p(i)*pb(i)/sum
          stpmaxb = stpmaxb + temp0b
          sumb = sumb - stpmax*temp0b/sum
          pb(i) = stpmax*pb(i)/sum
        END DO
      END IF
      CALL POPREAL4(sum)
      IF (sum .EQ. 0.0) THEN
        sumb = 0.0
      ELSE
        sumb = sumb/(2.0*SQRT(sum))
      END IF
      DO i=n,1,-1
        pb(i) = pb(i) + 2*p(i)*sumb
      END DO
      END SUBROUTINE LNSRCH_B
  
!  Differentiation of fminv in reverse (adjoint) mode:
!   gradient     of useful results: f x /newtinp/[0,4[
!   with respect to varying inputs: x /newtinp/[0,4[
!-----------------------------------------------------------------------
      SUBROUTINE FMINV_B(n, x, xb, ct, ctb, cs, imw, m, mb, fvec, fvecb, f)
      IMPLICIT NONE
!
      INTEGER :: n
      REAL :: x(n), f, fvec(n)
      REAL :: xb(n), fvecb(n)
      REAL :: ct(n), cs(n), imw(n), m
      REAL :: ctb(n), mb
      INTEGER :: i
      REAL :: sum
      CALL FUNCV_B(n, x, xb, ct, ctb, cs, imw, m, mb, fvec, fvecb)
      END SUBROUTINE FMINV_B
!  Differentiation of funcv in reverse (adjoint) mode:
!   gradient     of useful results: m fvec x
!   with respect to varying inputs: m x
!-----------------------------------------------------------------------
	SUBROUTINE FUNCV_B(n, x, xb, ct, ctb, cs, imw, m, mb, fvec, fvecb)
!  Hint: SIZE1OFbbINfuncv should be the value of n
!  Hint: SIZE1OFcbINfuncv should be the value of n
      IMPLICIT NONE
!
      INTEGER :: n
      REAL :: x(*)
      REAL :: xb(*)
      REAL :: fvec(n_vapor)
      REAL :: fvecb(n_vapor)
!
      REAL :: ct(n)
      REAL :: ctb(n)
      REAL :: cs(n)
      REAL :: imw(n)
      REAL :: m
      REAL :: mb
!
      INTEGER :: i, j
      REAL :: sum_jnei
      REAL :: sum_jneib
	REAL :: a(n)
      REAL :: b(n)
      REAL :: c(n)
      REAL :: cb(n_vapor)
      REAL :: bb(n_vapor)
      INTEGER :: ii1
!
      DO i=1,n
        a(i) = imw(i)
        CALL PUSHREAL4(sum_jnei)
        sum_jnei = 0.
        DO j=1,n
          sum_jnei = sum_jnei + x(j)*imw(j)
        END DO
        sum_jnei = sum_jnei - x(i)*imw(i)
        b(i) = sum_jnei + m + (cs(i)-ct(i))*imw(i)
      END DO
      DO ii1=1,n
        bb(ii1) = 0.0
      END DO
      DO ii1=1,n
        cb(ii1) = 0.0
      END DO
      DO i=n,1,-1
        bb(i) = bb(i) + x(i)*fvecb(i)
        cb(i) = cb(i) + fvecb(i)
        sum_jneib = bb(i) - ct(i)*cb(i)
        xb(i) = xb(i) + (x(i)*a(i)+a(i)*x(i)+b(i))*fvecb(i) - imw(i)*sum_jneib
        fvecb(i) = 0.0
        ctb(i) = ctb(i) - imw(i)*bb(i) - (sum_jnei+m)*cb(i)
        mb = mb + bb(i) - ct(i)*cb(i)
        cb(i) = 0.0
        bb(i) = 0.0
        DO j=n,1,-1
          xb(j) = xb(j) + imw(j)*sum_jneib
        END DO
        CALL POPREAL4(sum_jnei)
      END DO
      END SUBROUTINE FUNCV_B
!  Differentiation of lubksb in reverse (adjoint) mode:
!   gradient     of useful results: a b
!   with respect to varying inputs: a b
!-----------------------------------------------------------------------
!-----------------------------------------------------------------------
      SUBROUTINE LUBKSB_B(a, ab, n, indx, b, bb)
	IMPLICIT NONE
!
	INTEGER :: n, indx(n)
! A now has dimension NxN.
	REAL :: a(n, n), b(n)
      REAL :: ab(n, n), bb(n)
!
      INTEGER :: i, ii, j, ll
      REAL :: sum
      REAL :: sumb
	REAL :: tmp
      INTEGER :: ad_from
      INTEGER :: ad_to
      INTEGER :: branch
      INTEGER :: ad_from0
	    REAL :: tmpb
	    REAL :: tempb
	    INTEGER :: ii2
	    INTEGER :: ii1
	!
	    ii = 0
	    DO i=1,n
		ll = indx(i)
		sum = b(ll)
		tmp = b(i)
		CALL PUSHREAL4(b(ll))
		b(ll) = tmp
		IF (ii .NE. 0) THEN
		  ad_from = ii
		  DO j=ad_from,i-1
		    sum = sum - a(i, j)*b(j)
		  END DO
		  CALL PUSHINTEGER4(j - 1)
		  CALL PUSHINTEGER4(ad_from)
		  CALL PUSHINTEGER4(1)
		ELSE
		  CALL PUSHINTEGER4(0)
		  IF (sum .NE. 0) ii = i
		END IF
		CALL PUSHREAL4(b(i))
		b(i) = sum
	    END DO
	    DO i=n,1,-1
		CALL PUSHREAL4(sum)
		sum = b(i)
		ad_from0 = i + 1
		DO j=ad_from0,n
		  sum = sum - a(i, j)*b(j)
		END DO
		CALL PUSHINTEGER4(ad_from0)
		CALL PUSHREAL4(b(i))
		b(i) = sum/a(i, i)
	    END DO
	    DO ii1=1,n
		DO ii2=1,n
		  ab(ii2, ii1) = 0.0
		END DO
	    END DO
	    DO i=1,n,1
		CALL POPREAL4(b(i))
		tempb = bb(i)/a(i, i)
		sumb = tempb
		ab(i, i) = ab(i, i) - sum*tempb/a(i, i)
		bb(i) = 0.0
		CALL POPINTEGER4(ad_from0)
		DO j=n,ad_from0,-1
		  ab(i, j) = ab(i, j) - b(j)*sumb
		  bb(j) = bb(j) - a(i, j)*sumb
		END DO
		CALL POPREAL4(sum)
		bb(i) = bb(i) + sumb
	    END DO
	    DO i=n,1,-1
		CALL POPREAL4(b(i))
		sumb = bb(i)
		bb(i) = 0.0
		CALL POPINTEGER4(branch)
		IF (.NOT.branch .LT. 1) THEN
		  CALL POPINTEGER4(ad_from)
		  CALL POPINTEGER4(ad_to)
		  DO j=ad_to,ad_from,-1
		    ab(i, j) = ab(i, j) - b(j)*sumb
		    bb(j) = bb(j) - a(i, j)*sumb
		  END DO
		END IF
		ll = indx(i)
		CALL POPREAL4(b(ll))
		tmpb = bb(ll)
		bb(ll) = 0.0
		bb(i) = bb(i) + tmpb
		bb(ll) = bb(ll) + sumb
	    END DO
	  END SUBROUTINE LUBKSB_B
!  Differentiation of ludcmp in reverse (adjoint) mode:
!   gradient     of useful results: a
!   with respect to varying inputs: a
!-----------------------------------------------------------------------
        SUBROUTINE LUDCMP_B(a, ab, n, indx, d)
          IMPLICIT NONE
!
          INTEGER :: n, indx(n)
!     INTEGER NMAX
!     PARAMETER (NMAX = 10)      !largest expected N
! note that A now has dimension NxN
! NCVAP is ignored
          REAL :: d, a(n, n)
          REAL :: ab(n, n)
          REAL :: tiny
          PARAMETER (tiny=1.0e-20)
!
          INTEGER :: i, imax, j, k
          REAL :: aamax, dum, sum, vv(n)
          REAL :: dumb, sumb
!
          REAL :: tmp
          REAL :: tmp0
          INTEGER :: branch
          INTEGER :: ad_to
          INTEGER :: ad_to0
          INTEGER :: ad_from
          INTEGER :: ad_to1
          INTEGER :: ad_from0
          REAL :: tmpb
          INTRINSIC ABS
          REAL :: abs2
          REAL :: abs1
          DO i=1,n
            aamax = 0.
            DO j=1,n
              IF (a(i, j) .GE. 0.) THEN
                abs1 = a(i, j)
              ELSE
                abs1 = -a(i, j)
              END IF
              IF (abs1 .GT. aamax) THEN
                IF (a(i, j) .GE. 0.) THEN
                  aamax = a(i, j)
                ELSE
                  aamax = -a(i, j)
                END IF
              END IF
            END DO
            vv(i) = 1./aamax
          END DO
          DO j=1,n
            DO i=1,j-1
              sum = a(i, j)
              DO k=1,i-1
                sum = sum - a(i, k)*a(k, j)
              END DO
              CALL PUSHINTEGER4(k - 1)
              CALL PUSHREAL4(a(i, j))
              a(i, j) = sum
            END DO
            CALL PUSHINTEGER4(i - 1)
            aamax = 0.
            ad_from = j
            DO i=ad_from,n
              sum = a(i, j)
              DO k=1,j-1
                sum = sum - a(i, k)*a(k, j)
              END DO
              CALL PUSHINTEGER4(k - 1)
              CALL PUSHREAL4(a(i, j))
              a(i, j) = sum
              IF (sum .GE. 0.) THEN
                abs2 = sum
              ELSE
                abs2 = -sum
              END IF
              CALL PUSHREAL4(dum)
              dum = vv(i)*abs2
              IF (dum .GE. aamax) THEN
                CALL PUSHINTEGER4(imax)
                imax = i
                aamax = dum
                CALL PUSHINTEGER4(2)
              ELSE
                CALL PUSHINTEGER4(1)
              END IF
            END DO
            CALL PUSHINTEGER4(ad_from)
            IF (j .NE. imax) THEN
              DO k=1,n
                CALL PUSHREAL4(dum)
                dum = a(imax, k)
                tmp = a(j, k)
                CALL PUSHREAL4(a(imax, k))
                a(imax, k) = tmp
                CALL PUSHREAL4(a(j, k))
                a(j, k) = dum
              END DO
              CALL PUSHINTEGER4(1)
              tmp0 = vv(j)
              vv(imax) = tmp0
            ELSE
              CALL PUSHINTEGER4(0)
            END IF
            IF (a(j, j) .EQ. 0.) THEN
              CALL PUSHREAL4(a(j, j))
              a(j, j) = tiny
              CALL PUSHINTEGER4(1)
            ELSE
              CALL PUSHINTEGER4(0)
            END IF
            IF (j .NE. n) THEN
              CALL PUSHREAL4(dum)
              dum = 1./a(j, j)
              ad_from0 = j + 1
              DO i=ad_from0,n
                CALL PUSHREAL4(a(i, j))
                a(i, j) = a(i, j)*dum
              END DO
              CALL PUSHINTEGER4(ad_from0)
              CALL PUSHINTEGER4(2)
            ELSE
              CALL PUSHINTEGER4(1)
            END IF
          END DO
          DO j=n,1,-1
            CALL POPINTEGER4(branch)
            IF (.NOT.branch .LT. 2) THEN
              dumb = 0.0
              CALL POPINTEGER4(ad_from0)
              DO i=n,ad_from0,-1
                CALL POPREAL4(a(i, j))
                dumb = dumb + a(i, j)*ab(i, j)
                ab(i, j) = dum*ab(i, j)
              END DO
              CALL POPREAL4(dum)
              ab(j, j) = ab(j, j) - dumb/a(j, j)**2
            END IF
            CALL POPINTEGER4(branch)
            IF (.NOT.branch .LT. 1) THEN
              CALL POPREAL4(a(j, j))
              ab(j, j) = 0.0
            END IF
            CALL POPINTEGER4(branch)
            IF (.NOT.branch .LT. 1) THEN
              DO k=n,1,-1
                CALL POPREAL4(a(j, k))
                dumb = ab(j, k)
                ab(j, k) = 0.0
                CALL POPREAL4(a(imax, k))
                tmpb = ab(imax, k)
                ab(imax, k) = 0.0
                ab(j, k) = ab(j, k) + tmpb
                CALL POPREAL4(dum)
                ab(imax, k) = ab(imax, k) + dumb
              END DO
            END IF
            CALL POPINTEGER4(ad_from)
            DO i=n,ad_from,-1
              CALL POPINTEGER4(branch)
              IF (.NOT.branch .LT. 2) CALL POPINTEGER4(imax)
              CALL POPREAL4(dum)
              CALL POPREAL4(a(i, j))
              sumb = ab(i, j)
              ab(i, j) = 0.0
              CALL POPINTEGER4(ad_to1)
              DO k=ad_to1,1,-1
                ab(i, k) = ab(i, k) - a(k, j)*sumb
                ab(k, j) = ab(k, j) - a(i, k)*sumb
              END DO
              ab(i, j) = ab(i, j) + sumb
            END DO
            CALL POPINTEGER4(ad_to)
            DO i=ad_to,1,-1
              CALL POPREAL4(a(i, j))
              sumb = ab(i, j)
              ab(i, j) = 0.0
              CALL POPINTEGER4(ad_to0)
              DO k=ad_to0,1,-1
                ab(i, k) = ab(i, k) - a(k, j)*sumb
                ab(k, j) = ab(k, j) - a(i, k)*sumb
              END DO
              ab(i, j) = ab(i, j) + sumb
            END DO
          END DO
        END SUBROUTINE LUDCMP_B
      END MODULE SOA_DEFN_B
