C                           DISCLAIMER
C
C   This file was generated by TAMC version 5.3.2
C
C   THE AUTHOR DOES NOT MAKE  ANY WARRANTY, EXPRESS OR IMPLIED, OR ASSUMES
C   ANY LEGAL LIABILITY OR  RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS,
C   OR USEFULNESS  OF ANY INFORMATION OR PROCESS  DISCLOSED, OR REPRESENTS
C   THAT ITS USE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS.
C
C   THIS CODE IS FOR NON-PROFIT-ORIENTED ACADEMIC RESEARCH AND EDUCATION
C   ONLY.  ANY COMMERCIAL OR OTHER PROFIT-ORIENTED USE OR  EVALUATION IS
C   STRICTLY  FORBIDDEN.  PASSING  THIS CODE  TO  ANY THIRD  PARTY IS  NOT
C   ALLOWED.
C
C   FOR COMMERCIAL OR  OTHER PROFIT-ORIENTED APPLICATIONS PLEASE CONTACT
C   info@FastOpt.com
C
      subroutine vdiff_bwd( cgrid_bwd, cgrid_em_bwd, cgrid_em_sf_bwd,
     &                      jdate, jtime, tstep )
C***************************************************************
C***************************************************************
C** This routine was generated by the                         **
C** Tangent linear and Adjoint Model Compiler,  TAMC 5.3.2    **
C***************************************************************
C***************************************************************

C Revision History:
C   Oct 2010 by Peter Percell at UH-IMAQS: created for adjoint/4dvar
C   Aug 2013 by Peter Percell at UH-IMAQS:
C   -- fixed bug in adjoint for bi-directional flux
C   -- reduced vdiff checkpoint file to just layer 1 of cgrid
C   Nov 2013 S.Capps (US EPA): shifted emissions-related sensitivity
C            arrays to module; incorporated M.Turner (CU-Boulder) 
C            emissions-related sensitivity calculations

      USE PCGRID_DEFN
      USE EMIS_DEFN             ! inherits GRID_CONF
      USE DEPV_DEFN
      USE VDIFF_MAP
      USE CHK_FILES_DEFS        ! adjoint checkpoint files definition
      USE CHK_FILES             ! adjoint checkpoint files routines
      USE ADJ_ARRAY_MOD         ! adjoint sensitivity arrays
      USE ADJOINT_FILES, ONLY : LGRID_OUTPUT_FREQ ! reset cgrid_em_bwd after every output
      !USE EMIS_DEFN, ONLY : EMSENSL

C==============================================
C all entries are defined explicitly
C==============================================
      IMPLICIT NONE

      INCLUDE SUBST_CONST       ! constants
      INCLUDE SUBST_FILES_ID    ! file name parameters
      INCLUDE SUBST_IOPARMS     ! I/O parameters definitions
#     INCLUDE SUBST_IODECL      ! I/O definitions and declarations

C Arguments:

      REAL, POINTER :: CGRID_BWD( :,:,:,: ) ! sensitivities of J w.r.t. concentration
!      Now defining these pointers inside the adj_array_mod
      REAL, POINTER :: CGRID_EM_BWD( :,:,:,: ) ! sensitivities of J w.r.t. emissions
      REAL, POINTER :: CGRID_EM_SF_BWD( :,:,:,: ) ! sensitivities of J w.r.t. emissions multiplied by emissions
 
      INTEGER :: JDATE          ! current model date, coded YYYYDDD
      INTEGER :: JTIME          ! current model time, coded HHMMSS
      INTEGER :: TSTEP( 2 )     ! time step vector (HHMMSS)
                                ! TSTEP(1) = local output step
                                ! TSTEP(2) = sciproc sync. step (chem)

C Parameters:

C explicit, THETA = 0, implicit, THETA = 1
      REAL, PARAMETER :: THETA = 0.5 ! For dry deposition term
      REAL, PARAMETER :: THBAR = 1.0 - THETA

C ACM parameters

!      REAL, PARAMETER :: CRANKP = 0.5
!      REAL, PARAMETER :: CRANKQ = 1.0 - CRANKP
      REAL, PARAMETER :: CRANKP = 0.
      REAL, PARAMETER :: CRANKQ = 0.
      REAL, PARAMETER :: KARMAN = 0.4
      REAL, PARAMETER :: EPS = 1.0E-06

      INTEGER, PARAMETER :: IFACM = 0 ! 1 = acm, 0 = no acm

C External Functions not previously declared in IODECL3.EXT:

      INTEGER, EXTERNAL :: SEC2TIME, TIME2SEC

C File variables:

      REAL :: RDEPVHT( NCOLS,NROWS ) ! air dens / dep vel height
      REAL :: RJACM  ( NCOLS,NROWS,NLAYS ) ! reciprocal mid-layer Jacobian
      REAL :: RVJACMF( NCOLS,NROWS,NLAYS ) ! 1/ mid-full layer vert Jac
      REAL :: RRHOJ  ( NCOLS,NROWS,NLAYS ) ! reciprocal density X Jacobian
      REAL :: DENS1  ( NCOLS,NROWS ) ! layer 1 air density

C Local Variables:

      LOGICAL, SAVE :: FIRSTIME = .TRUE.
      INTEGER, SAVE :: LOGDEV

      CHARACTER( 16 ), SAVE :: PNAME = 'VDIFFACM2_BWD'
      CHARACTER( 120 ) :: XMSG = ' '

      INTEGER :: ALLOCSTAT

      REAL, ALLOCATABLE, SAVE :: DX3F ( : )
      REAL, ALLOCATABLE, SAVE :: RDX3F( : ) ! reciprocal layer thickness
      REAL, ALLOCATABLE, SAVE :: RDX3M( : ) ! reciprocal layer thickness
      REAL :: X3M  ( NLAYS )    ! middle layer height

      INTEGER, SAVE :: N_COL_CGRID ! no. of CGRID cols
      INTEGER, SAVE :: N_ROW_CGRID ! no. of CGRID rows
      INTEGER, SAVE :: N_LAY_CGRID ! no. of CGRID layer
      INTEGER, SAVE :: N_SPC_CGRID ! no. of CGRID species

      REAL, POINTER, SAVE :: CGRID( :,:,:,: ) ! forward concentrations
      REAL, ALLOCATABLE, SAVE :: CNGRD_BWD( :,:,:,: ) ! cgrid_bwd replacement
      ! Allocate arrays for emissions-related and semi-normalized sensitivities
      REAL, ALLOCATABLE, SAVE :: CNGRD_EM_BWD( :,:,:,: ) ! cgrid_bwd replacement
      REAL, ALLOCATABLE, SAVE :: CNGRD_EM_SF_BWD( :,:,:,: ) ! cgrid_bwd replacement

      ! Limiting to two dimensional array because the CNGRD_EM_BWD and CNGRD_EM_BWD_SF
      !    matrices are now calculated in the loops according to the forward formulation
      REAL :: EMIS( N_SPC_DIFF,NLAYS )   ! emissions subexpression

      REAL :: CONVPA            ! conversion factor to pressure in Pascals

      REAL :: EDDYV ( NCOLS,NROWS,NLAYS ) ! from EDYINTB
      REAL :: SEDDY ( NLAYS,NCOLS,NROWS ) ! flipped EDDYV
      INTEGER :: NSTEPS( NCOLS,NROWS ) ! diffusion time steps
      REAL :: DTSEC             ! model time step in seconds
      
      INTEGER :: OUTSEC         ! output time step in seconds
      INTEGER, SAVE :: ITER_COUNT = 0 ! No. of times vdiff_bwd has been called

C ACM Local Variables
      REAL :: MBAR              ! ACM2 mixing rate (S-1)
      REAL :: HOL   ( NCOLS,NROWS ) ! PBL over Monin-Obukhov Len
      REAL :: XPBL  ( NCOLS,NROWS ) ! PBL HT in gen coords
      INTEGER :: LPBL  ( NCOLS,NROWS ) ! layer containing PBL HT
      LOGICAL :: CONVCT( NCOLS,NROWS ) ! flag for ACM
      REAL :: MEDDY
      REAL :: EDDY  ( NLAYS )
      REAL :: MBARKS( NLAYS )   ! by layer
      REAL :: MDWN  ( NLAYS )   ! ACM down mix rate
      REAL :: MFAC              ! intermediate loop factor
      REAL :: AA    ( NLAYS )   ! matrix column one
      REAL :: BB    ( NLAYS )   ! diagonal
      REAL :: CC    ( NLAYS )   ! subdiagonal
      REAL :: EE    ( NLAYS )   ! superdiagonal
      REAL :: XPLUS
      REAL :: XMINUS
      REAL, ALLOCATABLE, SAVE :: DEPVCR ( : ) ! dep vel in one cell
      REAL, ALLOCATABLE, SAVE :: EFAC1 ( : )
      REAL, ALLOCATABLE, SAVE :: EFAC2 ( : )
      REAL :: POL(1:3)          ! prodn/lossrate = PVDD/DEPV
      REAL :: FNL
      INTEGER :: NLP, NL, LCBL
      INTEGER, SAVE :: NO2_HIT, HONO_HIT, HNO3_HIT, NO2_MAP, HONO_MAP, HNO3_MAP
      INTEGER, SAVE :: NH3_HIT, SO2_HIT, NH3_MAP, SO2_MAP
      REAL :: DTLIM, DTS, DTACM, RZ, DELC, LFAC1, LFAC2

      INTEGER :: C, R, L, V     ! loop induction variables
      ! Now use EMSENSL instead to be consistent (dbg.2.2015.slc)
      !INTEGER, PARAMETER :: M = 1 ! em_sf dimension length (e.g., for layers)
      INTEGER :: MDATE, MTIME, MSTEP ! internal simulation date&time
                                                ! array in vert. mixing

      ! For comparing recalculated emissions to the checkpointed ones
      REAL :: EMIST( NCOLS, NROWS, NLAYS, N_SPC_DIFF )   ! emissions from checkpoint subexpression
                           

      REAL, POINTER :: L1_CGRID( :,:,:,: )      ! layer 1 concentrations
                                     
      REAL, ALLOCATABLE, SAVE :: VDEMIS_VD(:,:,:,:)
      REAL, ALLOCATABLE :: PERT (:, :, :, :) ! emis perturbation

      INTEGER :: N_SPC_LGRID_EM   ! slc.dbg.6.2014

C==============================================
C define local adjoint variables
C==============================================
      real :: conc_bwd(n_spc_diff,nlays)
      real :: conc_em_bwd(n_spc_diff,emsensl)
      real :: conc_em_sf_bwd(n_spc_diff,emsensl)
      real :: dd_bwd(n_spc_diff,nlays)
      real :: delc_bwd
      real :: uu_bwd(n_spc_diff,nlays)
      real :: conc_no2b
      real :: conc_so2b

      INTERFACE
         SUBROUTINE RDMET( MDATE, MTIME, RDEPVHT, RJACM, RVJACMF, RRHOJ,
     &                     DENS1 )
            IMPLICIT NONE
            INTEGER, INTENT( IN )       :: MDATE, MTIME
            REAL, INTENT( OUT )         :: RDEPVHT( :,: )
            REAL, INTENT( OUT )         :: RJACM  ( :,:,: )
            REAL, INTENT( OUT )         :: RVJACMF( :,:,: )
            REAL, INTENT( OUT )         :: RRHOJ  ( :,:,: )
            REAL, INTENT( OUT )         :: DENS1  ( :,: )
         END SUBROUTINE RDMET
         ! CONV_CGRID_BWD only works for the LGRID array
         SUBROUTINE CONV_CGRID_BWD ( CGRID_BWD, JDATE, JTIME, CNGRD_BWD )
            IMPLICIT NONE
            REAL, POINTER :: CGRID_BWD( :,:,:,: )
            INTEGER, INTENT( IN )        :: JDATE, JTIME
            REAL, INTENT( IN ) :: CNGRD_BWD( :,:,:,: )
         END SUBROUTINE CONV_CGRID_BWD
         ! REV_CGRID_BWD only works for the LGRID array
         SUBROUTINE REV_CGRID_BWD ( CNGRD_BWD, JDATE, JTIME, CGRID_BWD )
            IMPLICIT NONE
            REAL, INTENT( OUT ) :: CNGRD_BWD( :,:,:,: )
            INTEGER, INTENT( IN )        :: JDATE, JTIME
            REAL, POINTER :: CGRID_BWD( :,:,:,: )
         END SUBROUTINE REV_CGRID_BWD
         ! CONV_CGRID_EM_BWD loops over _DIFF species, applies to 
         ! LGRID_EM and LGRID_EM_SF
         SUBROUTINE CONV_EM_BWD ( CGRID_EM_BWD, JDATE, JTIME, CNGRD_EM_BWD )
            IMPLICIT NONE
            REAL, POINTER :: CGRID_EM_BWD( :,:,:,: )
            INTEGER, INTENT( IN )        :: JDATE, JTIME
            REAL, INTENT( IN ) :: CNGRD_EM_BWD( :,:,:,: )
         END SUBROUTINE CONV_EM_BWD
         ! REV_CGRID_EM_BWD  loops over _DIFF species, applies to
         ! LGRID_EM and LGRID_EM_SF
         SUBROUTINE REV_EM_BWD ( CNGRD_EM_BWD, JDATE, JTIME, CGRID_EM_BWD )
            IMPLICIT NONE
            REAL, INTENT( OUT ) :: CNGRD_EM_BWD( :,:,:,: )
            INTEGER, INTENT( IN )        :: JDATE, JTIME
            REAL, POINTER :: CGRID_EM_BWD( :,:,:,: )
         END SUBROUTINE REV_EM_BWD
         SUBROUTINE EDDYX ( JDATE, JTIME, TSTEP,
     &                      EDDYV, HOL, XPBL, LPBL, CONVCT )
            IMPLICIT NONE
            INTEGER, INTENT( IN )       :: JDATE, JTIME, TSTEP
            REAL, INTENT( OUT )         :: EDDYV ( :,:,: )
            REAL, INTENT( OUT )         :: HOL   ( :,: )
            REAL, INTENT( OUT )         :: XPBL  ( :,: )
            INTEGER, INTENT( OUT )      :: LPBL  ( :,: )
            LOGICAL, INTENT( OUT )      :: CONVCT( :,: )
         END SUBROUTINE EDDYX
      END INTERFACE

C-----------------------------------------------------------------------

      IF ( FIRSTIME ) THEN

         FIRSTIME = .FALSE.
         LOGDEV = INIT3()

         ! Since CGRID_BWD is an argument, but we don't want to pass
         ! CCRID_BWD_EM or CGRID_EM_SF_BWD through every subroutine,
         ! just allocate them here. The first time only is necessary
         ! because they are kept in the adj_array_mod module.
         N_SPC_CGRID = SIZE ( CGRID_BWD,4 )
         
         !write(*,*) 'N_SPC_DIFF: ',N_SPC_DIFF
         !write(*,*) 'emsensl: ',emsensl

!     &        CGRID_BWD( MY_NROWS,MY_NCOLS,NLAYS,N_SPC_CGRID ),
!     &        CGRID_EM_BWD( MY_NROWS,MY_NCOLS,EMSENSL,N_SPC_DIFF  ),
!     &        CGRID_EM_SF_BWD( MY_NROWS,MY_NCOLS,EMSENSL,N_SPC_DIFF ),

         ALLOCATE(
     &        CGRID( 1:NCOLS,1:NROWS,1:NLAYS,1:N_SPC_CGRID ),
     &        CNGRD_BWD( 1:N_SPC_CGRID,1:NLAYS,1:MY_NCOLS,1:MY_NROWS ),
     &        CNGRD_EM_BWD( 1:N_SPC_DIFF,1:EMSENSL,1:MY_NCOLS,1:MY_NROWS ),
     &        CNGRD_EM_SF_BWD( 1:N_SPC_DIFF,1:EMSENSL,1:MY_NCOLS,1:MY_NROWS ),
     &        STAT = ALLOCSTAT )
         IF ( ALLOCSTAT .NE. 0 ) THEN
            XMSG = 'Failure allocating CGRID, CNGRD_BWD'
            CALL M3EXIT( PNAME, JDATE, JTIME, XMSG, XSTAT1 )
         END IF

         ALLOCATE ( EM_SF( 1:MY_NCOLS,1:MY_NROWS,1:EMSENSL,1:N_SPC_DIFF ),
     &              STAT = ALLOCSTAT )
         IF ( ALLOCSTAT .NE. 0 ) THEN
            XMSG = 'EM_SF memory allocation failed'
            CALL M3EXIT ( PNAME, JDATE, JTIME, XMSG, XSTAT1 )
         END IF

         IF ( .NOT. EMIS_INIT ( JDATE, JTIME, TSTEP( 1 ) ) ) THEN
            XMSG = 'Failure initializing emissions module'
            CALL M3EXIT ( PNAME, JDATE, JTIME, XMSG, XSTAT1 )
         END IF

         ALLOCATE ( VDEMIS_VD( 1:MY_NCOLS,1:MY_NROWS,1:NLAYS,1:N_SPC_EMIS+1 ), 
     &              STAT = ALLOCSTAT )
         IF ( ALLOCSTAT .NE. 0 ) THEN
            XMSG = 'VDEMIS_VD memory allocation failed'
            CALL M3EXIT ( PNAME, JDATE, JTIME, XMSG, XSTAT1 )
         END IF

         !write(*,*) 'before opening ADJ_VDIFF_CHK at JDATE & JTIME'
         !dbg.slc.7.2014
C Open checkpoint file as read-only
         CALL CHK_FILE_OPEN ( ADJ_VDIFF_CHK, JDATE, JTIME, .FALSE. )

C set vertical layer definitions from COORD.EXT

         ALLOCATE ( DX3F( NLAYS ),
     &              RDX3F( NLAYS ),
     &              RDX3M( NLAYS ), STAT = ALLOCSTAT )
         IF ( ALLOCSTAT .NE. 0 ) THEN
            XMSG = 'Failure allocating DX3F, RDX3F or RDX3M'
            CALL M3EXIT( PNAME, JDATE, JTIME, XMSG, XSTAT1 )
         END IF

         DO L = 1, NLAYS
            DX3F( L )  = X3FACE_GD( L ) - X3FACE_GD( L-1 )
            RDX3F( L ) = 1.0 / DX3F( L )
            X3M( L ) = 0.5 * ( X3FACE_GD( L ) + X3FACE_GD( L-1 ) )
         END DO

         DO L = 1, NLAYS - 1
            RDX3M( L ) = 1.0 / ( X3M( L+1 ) - X3M( L ) )
         END DO
         RDX3M( NLAYS ) = 0.0

!         IF ( .NOT. EMIS_INIT ( JDATE, JTIME, TSTEP( 1 ) ) ) THEN
!            XMSG = 'Failure initializing emissions module'
!            CALL M3EXIT ( PNAME, JDATE, JTIME, XMSG, XSTAT1 )
!         END IF

         ! dbg.slc.7.2014
         !write(*,*) 'before reading ADJ_VDIFF_CHK'
C Read vertical diffusion checkpoint at sync step
         CALL CHK_FILE_READ ( ADJ_VDIFF_CHK, JDATE, JTIME, CGRID )
         ! dbg.slc.7.2014
         !write(*,*) 'after reading ADJ_VDIFF_CHK'       

         IF ( .NOT. DEPV_INIT ( JDATE, JTIME, TSTEP( 1 ) ) ) THEN
            XMSG = 'Failure initializing deposition velocities module'
            CALL M3EXIT ( PNAME, JDATE, JTIME, XMSG, XSTAT1 )
         END IF

C create global maps

         IF ( .NOT. VDIFF_MAP_INIT( NDEPV_SPC ) ) THEN
            XMSG = 'Failure initializing index mapping module'
            CALL M3EXIT ( PNAME, JDATE, JTIME, XMSG, XSTAT1 )
         END IF

         IF ( NDEPV_SPC > 0 ) THEN
            HONO_HIT = 0; HNO3_HIT = 0; NO2_HIT = 0
            HONO_MAP = 0; HNO3_MAP = 0; NO2_MAP = 0
            NH3_HIT = 0; SO2_HIT = 0
            NH3_MAP = 0; SO2_MAP = 0
            DO V = 1, NDEPV_SPC
               IF ( TRIM( DV2DF_SPC( V ) ) .EQ. 'NO2' ) THEN
                  NO2_HIT = V
                  NO2_MAP = DV2DF( V )
               ELSE IF ( TRIM( DV2DF_SPC( V ) ) .EQ. 'HONO' ) THEN
                  HONO_HIT = V
                  HONO_MAP = DV2DF( V )
               ELSE IF ( TRIM( DV2DF_SPC( V ) ) .EQ. 'HNO3' ) THEN
                  HNO3_HIT = V
                  HNO3_MAP = DV2DF( V )
               ELSE IF ( TRIM( DV2DF_SPC( V ) ) .EQ. 'SO2' ) THEN
                  SO2_HIT = V
                  SO2_MAP = DV2DF( V )
               ELSE IF ( TRIM( DV2DF_SPC( V ) ) .EQ. 'NH3' ) THEN
                  NH3_HIT = V
                  NH3_MAP = DV2DF( V )
               END IF
            END DO
         END IF

C Open the met files

         CALL OPMET ( JDATE, JTIME, CONVPA )

         IF ( NDEPV_SPC > 0 ) THEN

C set auxiliary depv arrays

            ALLOCATE ( DEPVCR( NDEPV_SPC ),
     &           EFAC1 ( NDEPV_SPC ),
     &           EFAC2 ( NDEPV_SPC ), STAT = ALLOCSTAT )
            IF ( ALLOCSTAT .NE. 0 ) THEN
               XMSG = 'Failure allocating DEPVCR, EFAC1 or EFAC2'
               CALL M3EXIT( PNAME, JDATE, JTIME, XMSG, XSTAT1 )
            END IF

         END IF

C Open adjoint file for reading
         CALL  CHK_FILE_OPEN ( ADJ_VDIFF_CHK, JDATE, JTIME, .FALSE. )
      END IF                    ! FIRSTIME

C Read vertical diffusion checkpoint at sync step
      !L1_CGRID => CGRID(:, :, 1:1, :)
      L1_CGRID => CGRID(:, :, :, :)
      CALL CHK_FILE_READ ( ADJ_VDIFF_CHK, JDATE, JTIME, L1_CGRID )
      L1_CGRID => L1_CGRID(:, :, 1:1, :)

      OUTSEC = TIME2SEC( TSTEP( 1 ) )
      MDATE = JDATE
      MTIME = JTIME
      MSTEP = TIME2SEC( TSTEP( 2 ) )
      DTSEC = FLOAT( MSTEP )
      CALL NEXTIME ( MDATE, MTIME, SEC2TIME( MSTEP / 2 ) )

C read & interpolate met data

      CALL RDMET ( MDATE, MTIME, RDEPVHT, RJACM, RVJACMF, RRHOJ, DENS1 )

      CALL  CHK_FILE_OPEN ( ADJ_EMIS_CHK, MDATE, MTIME, .FALSE. )
      CALL  CHK_FILE_OPEN ( ADJ_EMIST_CHK, MDATE, MTIME, .FALSE. )

C read & interpolate deposition velocities

      IF ( NDEPV_SPC > 0 ) CALL GET_DEPV ( MDATE, MTIME, TSTEP,L1_CGRID )

      CALL EDDYX ( JDATE, JTIME, TSTEP( 2 ),
     &             EDDYV, HOL, XPBL, LPBL, CONVCT )

C EDDYV returned = Kz, where Kz is in m**2/sec

      !write(*,*) 'before calculating SEDDY, vdiff' ! dbg.6.2015.slc
      DO R = 1, MY_NROWS
         DO C = 1, MY_NCOLS
            DO L = 1, NLAYS
               SEDDY( L,C,R ) = EDDYV( C,R,L )
     &                        * RVJACMF( C,R,L ) * RDX3M( L )
            END DO
         END DO
      END DO

      IF ( IFACM .EQ. 0 ) CONVCT = .FALSE.   ! no ACM

C Read emissions from checkpoint file
      !write(*,*) 'before reading CHK files, vdiff' ! dbg.6.2015.slc
      CALL CHK_FILE_READ ( ADJ_EMIS_CHK, MDATE, MTIME, VDEMIS_VD )
      CALL CHK_FILE_READ ( ADJ_EMIST_CHK, MDATE, MTIME, EMIST )
      !write(*,*) 'after reading CHK files, vdiff' ! dbg.6.2015.slc

C----------------------------------------------
C RESET GLOBAL ADJOINT VARIABLES
C----------------------------------------------
      cngrd_bwd(:,:,:,:) = 0.
      cngrd_em_bwd(:,:,:,:) = 0.
      cngrd_em_sf_bwd(:,:,:,:) = 0.
      em_sf = 1.0     !debug, mdt

C----------------------------------------------
C RESET LOCAL ADJOINT VARIABLES
C----------------------------------------------
      conc_bwd(:,:) = 0.
      conc_em_bwd(:,:) = 0.
      conc_em_sf_bwd(:,:) = 0.
      !conc_em_bwd_nrm(:,:) = 0.
      dd_bwd(:,:) = 0.
      delc_bwd = 0.
      uu_bwd(:,:) = 0.

C----------------------------------------------
C ROUTINE BODY
C----------------------------------------------

      N_SPC_CGRID = SIZE ( CGRID_BWD,4 )
      N_SPC_LGRID_EM = SIZE (cgrid_em_bwd, 4)

       ! Recalculate emissions from checkpoint file (mdt|slc.1.2014)
!       IF ( JDATE == 2007161 .AND.  JTIME < 10000 ) THEN
!          ! Allocate PERT Array
!!          ALLOCATE ( PERT ( MY_NCOLS, MY_NROWS, EMSENSL, N_SPC_DIFF )
!     &                 , STAT = ALLOCSTAT )
!          IF ( ALLOCSTAT .NE. 0 ) THEN
!             XMSG = 'PERT  memory allocation failed'
!             CALL M3EXIT ( PNAME, JDATE, JTIME, XMSG, XSTAT1 )
!          END IF
!          ! Always include the PERT = 1.0 to ensure that all
!          ! emissions
!          ! other than that perturbed are constant.
!          PERT( :,:,:,: ) = 1.0
!          EM_SF = 1.0
!!          WRITE(LOGDEV,*) 'Not applying emission perturbation'
!         ! Perturb one species in specific location or column
!!          PERT(25,:,:,: ) = 1.0000001   ! ASO4J
!!          PERT(31,:,:,: ) = 1.0001    ! AECJ
!!          PERT(8,:,2:6,17:22 ) = 1.10    ! CO
!!          PERT(:,:,1,16 ) = 1.10    ! CO
!          WRITE(LOGDEV,*) 'Applying emission perturbation'
!!debug,mdt
!          DO V = 1, N_SPC_DIFF
!             DO L = 1, EMSENSL   ! scaling factor only applies to level 1
!                DO R = 1, MY_NROWS
!                   DO C = 1, MY_NCOLS
!                      EM_SF(C, R, 1, V) = EM_SF(C, R, 1, V) *
!     &                                    PERT( C, R, 1, V)
!                   END DO ! Col
!                END DO ! Row
!             END DO ! Layer
!          END DO ! Species
!       ELSE
!          ! Always include em_sf  = 1.0 to ensure that all emissions
!          ! other than that perturbed are constant.
          EM_SF = 1.0
!       END IF ! Date and time qualification

      ! Reset emission sensitivity after every output step
      IF ( TRIM(LGRID_OUTPUT_FREQ) == 'SYNC_STEP' ) THEN
         cgrid_em_bwd = 0.0
         cgrid_em_sf_bwd = 0.0
      ELSE IF ( TRIM(LGRID_OUTPUT_FREQ) == 'OUTPUT_STEP' ) THEN
         IF ( MOD( ITER_COUNT, INT(OUTSEC) / INT(DTSEC) ) == 0 ) THEN
            cgrid_em_bwd = 0.0
            cgrid_em_sf_bwd = 0.0
         END IF
      ELSE IF ( TRIM(LGRID_OUTPUT_FREQ) == 'ONCE' ) THEN
         IF ( ITER_COUNT == 0 ) THEN
            cgrid_em_bwd = 0.0
            cgrid_em_sf_bwd = 0.0
         END IF
      END IF

      call rev_cgrid_bwd( cngrd_bwd, mdate, mtime, cgrid_bwd )
      call rev_em_bwd( cngrd_em_bwd, mdate, mtime, cgrid_em_bwd )
      call rev_em_bwd( cngrd_em_sf_bwd, mdate, mtime, cgrid_em_sf_bwd )
      do r = 1, my_nrows
        do c = 1, my_ncols
          dtlim = dtsec
          do l = 1, nlays-1
            dtlim = min(dtlim,0.75/(seddy(l,c,r)*rdx3f(l)))
          end do
          mbarks = 0.
          mdwn = 0.
          if (convct(c,r)) then
            lcbl = lpbl(c,r)
            meddy = seddy(1,c,r)/(xpbl(c,r)-x3face_gd(1))
            fnl = 1./(1.+(karman/(-hol(c,r)))**0.3333/(0.72*karman))
            mbar = meddy*fnl
            do l = 1, lcbl-1
              seddy(l,c,r) = seddy(l,c,r)*(1.-fnl)
            end do
            if (mbar .lt. eps) then
              write(logdev, *) ' EDDYV, MBAR, FNL, HOL = ',
     &              eddyv(c,r,1), mbar, fnl, hol(c,r)
              convct(c,r) =  .false. 
              lcbl = 1
              xmsg = '*** ACM fails ***'
              call m3exit(pname, mdate, mtime, xmsg, xstat2)
            endif
            if ( ( fnl .le. 0.0 ) .or.            ! never gonna happen for CONVCT
     &           ( lcbl .ge. nlays-1 ) .or.       ! .GT. never gonna happen
     &           ( hol( c,r ) .gt. -0.00001 ) )   ! never gonna happen
     &         write(logdev, '(a, i3, 1x, 5(1pe13.5))')
     &           ' LCBL, MBAR, FNL, SEDDY1, HOL:',
     &           lcbl, mbar, fnl, eddyv(c,r,1), seddy(1,c,r), hol(c,r)
            do l = 1, lcbl-1
              mbarks(l) = mbar
              mdwn(l) = mbar*(xpbl(c,r)-x3face_gd(l-1))*rdx3f(l)
            end do
            mbarks(lcbl) = mbar*(xpbl(c,r)-x3face_gd(lcbl-1))*rdx3f(lcbl)
            mdwn(lcbl) = mbarks(lcbl)
            rz = (x3face_gd(lcbl)-x3face_gd(1))*rdx3f(1)
            dtacm = 1./(mbar*rz)
            dtlim = min(0.75*dtacm,dtlim)
          else
            lcbl = 1
          endif
          
          nlp = int(dtsec/dtlim+0.99)
          dts = dtsec/nlp
          emis = 0.0
          do l  = 1, emlays
             do v = 1, n_spc_diff
                emis( v,l ) = vdemis_vd( c,r,l,df2em( v ) ) * dts * em_sf(c,r,l,v)
             end do
          end do
          
          ! dbg.slc.7.2014
          !if (c == 5 .and. r == 2 ) then
          !   write(logdev,*) 'current minus checkpointed CO emis (5,5): ', emis(16,1)-EMIST(5,2,1,16)
          !   write(logdev,*) 'NO2 emis: ', emis(1,1) 
          !endif  
          
          do l = 1, nlays
            eddy(l) = seddy(l,c,r)
          end do
          do v = 1, ndepv_spc
            depvcr(v) = depv(v,c,r)
            efac1(v) = exp(-(depvcr(v)*rdepvht(c,r)*thbar*dts))
            efac2(v) = exp(-(depvcr(v)*rdepvht(c,r)*theta*dts))
          end do
          if ( nh3_hit > 0 ) then
             pol(nh3_so2) = pvdd(nh3_so2,c,r)/depvcr(nh3_hit)
             pol(nh3_nh3) = pvdd(nh3_nh3,c,r)/depvcr(nh3_hit)
          end if
          if ( hono_hit > 0 ) then
             pol(hono_no2) = pvdd(hono_no2,c,r)/depvcr(hono_hit)
          end if
          ! Split do loop into two - treat emissions only up to EMSENSL (dbg.2.2015.slc)
          do l = 1, nlays
            do v = 1, n_spc_diff
              conc_bwd(v,l) = conc_bwd(v,l)+cngrd_bwd(diff_map(v),l,c,r)
              cngrd_bwd(diff_map(v),l,c,r) = 0.
              ! only apply at layers that have emissions (dbg.2.2015.slc)
              if ( l .le. emsensl ) then
                 conc_em_bwd(v,l) = conc_em_bwd(v,l)+cngrd_em_bwd(v,l,c,r)
                 cngrd_em_bwd(v,l,c,r) = 0.
                 conc_em_sf_bwd(v,l) = conc_em_sf_bwd(v,l)+cngrd_em_sf_bwd(v,l,c,r)
                 cngrd_em_sf_bwd(v,l,c,r) = 0.
              endif
            end do
          end do
          do nl = nlp, 1, -1
            do l = 1, nlays
              aa(l) = 0.
              bb(l) = 0.
              cc(l) = 0.
              ee(l) = 0.
            end do
            if (convct(c,r)) then
              do l = 2, lcbl
                aa(l) = -(crankp*mbarks(l)*dts)
                bb(l) = 1.+crankp*mdwn(l)*dts
                ee(l-1) = -(crankp*mdwn(l)*dts*dx3f(l)*rdx3f(l-1))
              end do
            endif
            aa(2) = aa(2)-eddy(1)*crankp*rdx3f(2)*dts
            ee(1) = ee(1)-eddy(1)*crankp*rdx3f(1)*dts
            do l = 2, nlays
              if (l .gt. lcbl) then
                bb(l) = 1.
              endif
              xplus = eddy(l)*rdx3f(l)*dts
              xminus = eddy(l-1)*rdx3f(l)*dts
              bb(l) = bb(l)+(xplus+xminus)*crankp
              cc(l) = -(xminus*crankp)
              ee(l) = ee(l)-xplus*crankp
            end do
            bb(1) = 1.
            if (convct(c,r)) then
              lfac1 = (xpbl(c,r)-x3face_gd(1))*rdx3f(1)*dts
              bb(1) = bb(1)+crankp*mbarks(1)*lfac1
            endif
            bb(1) = bb(1)+crankp*eddy(1)*rdx3f(1)*dts
            lfac1 = crankq*eddy(1)*rdx3f(1)*dts
            do v = ndepv_spc, 1, -1
              if (v .eq. hono_hit) then
                conc_no2b = pol(hono_no2)*(1.0-efac2(v))*conc_bwd(hono_map,1)
                conc_bwd(hono_map,1) = conc_bwd(hono_map,1)*efac2(v)
              else if (v .eq. hno3_hit) then
                conc_bwd(hno3_map,1) = conc_bwd(hno3_map,1)*efac2(v)
              else if (v .eq. no2_hit) then
                conc_bwd(no2_map,1) = conc_bwd(no2_map,1)*efac2(v)
              else if (v .eq. nh3_hit) then
                conc_so2b = pol(nh3_so2)*(1.0-efac2(v))*conc_bwd(nh3_map,1)
                conc_bwd(nh3_map,1) =
     &               pol(nh3_nh3)*(1.0-efac2(v))*conc_bwd(nh3_map,1)
     &               +conc_bwd(nh3_map,1)*efac2(v)
              else if (v .eq. so2_hit) then
                conc_bwd(so2_map,1) = conc_bwd(so2_map,1)*efac2(v)
              else
                conc_bwd(dv2df(v),1) = conc_bwd(dv2df(v),1)*efac2(v)
              endif
            end do
            if ( no2_map > 0 ) then
               conc_bwd(no2_map,1) = conc_bwd(no2_map,1) + conc_no2b
            end if
            if ( so2_map > 0 ) then
               conc_bwd(so2_map,1) = conc_bwd(so2_map,1) + conc_so2b
            end if
            do l = 1, nlays
              do v = 1, n_spc_diff
                uu_bwd(v,l) = uu_bwd(v,l)+conc_bwd(v,l)
                conc_bwd(v,l) = 0.
              end do
            end do
            if (convct(c,r)) then
              call matrix_bwd( aa,bb,cc,ee,dd_bwd,uu_bwd )
            else
              call tri_bwd( cc,bb,ee,dd_bwd,uu_bwd )
            endif
            !write(LOGDEV,*) 'NO2 dd_bwd(1,1): ',dd_bwd(1,1)            
            do v = 1, n_spc_diff

!!! Eliminated duplicate application of scaling factor in forward; 
!!!     now making adjoint congruent(dbg.7.2015.slc)
!           From vdiffacm2.F (forward code) as a reference for the emissions-related 
!              sensitivity calculations FOR LEVEL ONE (6.2014.slc|mdt)
!              Because the species indices used in the forward code for EMIS and EM_SF require
!              no mapping for 1 to N_SPC_DIFF, no use of diff_map is required here.
!            DO V = 1, N_SPC_DIFF
!               DD( V,1 ) = DD( V,1 )
!     &                   + LFAC1 * ( CONC( V,2 ) - CONC( V,1 ) )
!     &                   + EMIS( V,1 ) ! * EM_SF( C, R, M, V )
!            END DO
!
!             Semi-normalized and scaling factor-related sensitivities 
!                   by propagating arrays through all of vdiff as CNGRD_EM_BWD 
!                   and CNGRD_EM_BWD_SF (6.2014.slc|mdt)
!              conc_em_sf_bwd(v,1) = conc_em_sf_bwd(v,1) + emis(v,1) 
!     &                      * dd_bwd(v,1)
              conc_em_bwd(v,1) = conc_em_bwd(v,1) + dd_bwd(v,1)*dts
              conc_bwd(v,2) = conc_bwd(v,2)+dd_bwd(v,1)*lfac1
              conc_bwd(v,1) = conc_bwd(v,1)-dd_bwd(v,1)*lfac1
            end do
            if (convct(c,r)) then
              lfac1 = (xpbl(c,r)-x3face_gd(1))*rdx3f(1)*dts
              lfac2 = crankq*mdwn(2)*dx3f(2)*rdx3f(1)*dts
              lfac1 = crankq*mbarks(1)*lfac1
              do v = 1, n_spc_diff
                conc_bwd(v,2) = conc_bwd(v,2)+dd_bwd(v,1)*lfac2
                conc_bwd(v,1) = conc_bwd(v,1)-dd_bwd(v,1)*lfac1
              end do
            endif
            do v = 1, n_spc_diff
              conc_bwd(v,1) = conc_bwd(v,1)+dd_bwd(v,1)
              dd_bwd(v,1) = 0.
            end do
            do l = 2, nlays
              xplus = eddy(l)*rdx3f(l)*dts
              xminus = eddy(l-1)*rdx3f(l)*dts
              if (l .eq. nlays) then
                do v = 1, n_spc_diff
                  conc_bwd(v,l-1) = conc_bwd(v,l-1)+dd_bwd(v,l)*crankq*xminus
                  conc_bwd(v,l) = conc_bwd(v,l)-dd_bwd(v,l)*crankq*xminus
                end do
              else
                lfac1 = crankq*xplus
                lfac2 = crankq*xminus
                do v = 1, n_spc_diff
                  conc_bwd(v,l-1) = conc_bwd(v,l-1)+dd_bwd(v,l)*lfac2
                  conc_bwd(v,l+1) = conc_bwd(v,l+1)+dd_bwd(v,l)*lfac1
                  conc_bwd(v,l) = conc_bwd(v,l)-dd_bwd(v,l)*(lfac1+lfac2)
!!! Eliminated duplicate application of scaling factor in forward; 
!!!     now making adjoint congruent(dbg.8.2015.slc)
!      From vdiffacm2.F (forward code) as a reference for the emissions-related sensitivity
!         calculations for layers 2 to EMSENSL (6.2014.slc)
!                     IF ( L .LE. EMSENSL ) DD( V,L ) = DD( V,L ) + EMIS( V,L ) 
!            DO V = 1, N_SPC_DIFF
!               DD( V,1 ) = CONC( V,1 )
!            END DO
!      Semi-normalized and scaling factor-related sensitivities after conv_cgrid_bwd (6.2014.slc)
                  if ( l .le. emsensl ) then
!                    conc_em_sf_bwd(v,l) = conc_em_sf_bwd(v,l) + emis(v,l)
!     &                                 * dd_bwd(v,l)
                    conc_em_bwd(v,l) = conc_em_bwd(v,l) + dd_bwd(v,l)*dts
                  end if
                end do
              endif
              if (l .gt. lcbl) then
                do v = 1, n_spc_diff
                  conc_bwd(v,l) = conc_bwd(v,l)+dd_bwd(v,l)
                  dd_bwd(v,l) = 0.
                end do
              endif
            end do
            if (convct(c,r)) then
              do l = 2, lcbl
                delc_bwd = 0.
                mfac = dx3f(l+1)*rdx3f(l)*mdwn(l+1)
                do v = 1, n_spc_diff
                  delc_bwd = 0.
                  conc_bwd(v,l) = conc_bwd(v,l)+dd_bwd(v,l)
                  delc_bwd = delc_bwd+dd_bwd(v,l)*crankq
                  dd_bwd(v,l) = 0.
                  conc_bwd(v,l+1) = conc_bwd(v,l+1)+delc_bwd*dts*mfac
                  conc_bwd(v,l) = conc_bwd(v,l)-delc_bwd*dts*mdwn(l)
                  conc_bwd(v,1) = conc_bwd(v,1)+delc_bwd*dts*mbarks(l)
                  delc_bwd = 0.
                end do
              end do
            endif
            do l = 1, nlays
              do v = 1, n_spc_diff
                dd_bwd(v,l) = 0.
              end do
            end do
            do v = ndepv_spc, 1, -1
              if (v .eq. hono_hit) then
                conc_no2b = pol(hono_no2)*(1.0-efac1(v))*conc_bwd(hono_map,1)
                conc_bwd(hono_map,1) = conc_bwd(hono_map,1)*efac1(v)
              else if (v .eq. hno3_hit) then
                conc_bwd(hno3_map,1) = conc_bwd(hno3_map,1)*efac1(v)
              else if (v .eq. no2_hit) then
                conc_bwd(no2_map,1) = conc_bwd(no2_map,1)*efac1(v)
              else if (v .eq. nh3_hit) then
                conc_so2b = pol(nh3_so2)*(1.0-efac1(v))*conc_bwd(nh3_map,1)
                conc_bwd(nh3_map,1) =
     &               pol(nh3_nh3)*(1.0-efac1(v))*conc_bwd(nh3_map,1)
     &               +conc_bwd(nh3_map,1)*efac1(v)
              else if (v .eq. so2_hit) then
                conc_bwd(so2_map,1) = conc_bwd(so2_map,1)*efac1(v)
              else
                conc_bwd(dv2df(v),1) = conc_bwd(dv2df(v),1)*efac1(v)
              endif
            end do
            if ( no2_map > 0 ) then
               conc_bwd(no2_map,1) = conc_bwd(no2_map,1) + conc_no2b
            end if
            if ( so2_map > 0 ) then
               conc_bwd(so2_map,1) = conc_bwd(so2_map,1) + conc_so2b
            end if
          end do
          
! Forward code: 
!    Currently where the emissions scaling factor is applied (8.2015.slc)
!        DO L = 1, EMLAYS
!           DO V = 1, N_SPC_DIFF
!              EMIS( V,L ) = VDEMIS( DF2EM( V ),L,C,R ) * DTS * EM_SF(C, R, L, V)
!           END DO
!        END DO

! Backward code:
!    pass sensitivity information to em_sf sensitivity array
          do l = 1, emlays
             do v = 1, n_spc_diff
                conc_em_sf_bwd(v,l) = vdemis_vd( c,r,l,df2em( v ) ) * dts * 
     &                                conc_em_bwd(v,l)
             end do
          end do 
             
          do l = 1, nlays
            do v = 1, n_spc_diff
              cngrd_bwd(diff_map(v),l,c,r) = cngrd_bwd(diff_map(v),l,c,r)+conc_bwd(v,l)
              conc_bwd(v,l) = 0.
              ! only apply at layers that have emissions (dbg.2.2015.slc)
              if ( l .le. emsensl ) then
                 cngrd_em_bwd(v,l,c,r) = cngrd_em_bwd(v,l,c,r)+conc_em_bwd(v,l)
                 conc_em_bwd(v,l) = 0.
                 cngrd_em_sf_bwd(v,l,c,r) = cngrd_em_sf_bwd(v,l,c,r)+conc_em_sf_bwd(v,l)
                 conc_em_sf_bwd(v,l) = 0.
              endif
            end do
          end do
        end do
      end do
              
      call conv_cgrid_bwd( cgrid_bwd, mdate, mtime, cngrd_bwd )
      call conv_em_bwd( cgrid_em_bwd, mdate, mtime, cngrd_em_bwd )
      call conv_em_bwd( cgrid_em_sf_bwd, mdate, mtime, cngrd_em_sf_bwd )
      
      ITER_COUNT = ITER_COUNT + 1
      
      end subroutine vdiff_bwd
